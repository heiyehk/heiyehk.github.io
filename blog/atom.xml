<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeiYe</title>
  
  <subtitle>不忘初心，方得始终</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://heiyehk.github.io/blog/"/>
  <updated>2020-04-30T09:27:49.165Z</updated>
  <id>https://heiyehk.github.io/blog/</id>
  
  <author>
    <name>HeiYehk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试灵魂十大问，你们都会回答了吗？</title>
    <link href="https://heiyehk.github.io/blog/%E9%9D%A2%E8%AF%95%E7%81%B5%E9%AD%82%E5%8D%81%E5%A4%A7%E9%97%AE%EF%BC%8C%E4%BD%A0%E4%BB%AC%E9%83%BD%E4%BC%9A%E5%9B%9E%E7%AD%94%E4%BA%86%E5%90%97%EF%BC%9F/"/>
    <id>https://heiyehk.github.io/blog/%E9%9D%A2%E8%AF%95%E7%81%B5%E9%AD%82%E5%8D%81%E5%A4%A7%E9%97%AE%EF%BC%8C%E4%BD%A0%E4%BB%AC%E9%83%BD%E4%BC%9A%E5%9B%9E%E7%AD%94%E4%BA%86%E5%90%97%EF%BC%9F/</id>
    <published>2020-04-30T09:03:48.000Z</published>
    <updated>2020-04-30T09:27:49.165Z</updated>
    
    <content type="html"><![CDATA[<ul><li>你最大的优点和缺点</li><li>你是否接受加班？</li><li>你对薪资有什么要求吗？</li><li>在五年的时间内，你的职业规划？</li><li>我们为什么要聘用你？</li><li>你对于我们公司了解多少？</li><li>你为什么愿意到我们公司？</li><li>与上级意见不一致，如何处理？</li><li>你缺乏工作经验，如何能胜任这份工作？</li><li>工作中与同事发生争执，你会怎么处理？</li></ul><a id="more"></a><h3 id="下面来带大家看看，如何轻松拆解十大问"><a href="#下面来带大家看看，如何轻松拆解十大问" class="headerlink" title="下面来带大家看看，如何轻松拆解十大问"></a>下面来带大家看看，如何轻松拆解十大问</h3><h4 id="1-你最大的优点和缺点"><a href="#1-你最大的优点和缺点" class="headerlink" title="1.你最大的优点和缺点"></a>1.你最大的优点和缺点</h4><p><strong>谈优点</strong></p><p>不要笼统地说自己的优点，例如助人为乐，善解人意这些，没有意义。需要根据应聘岗位所需的特性有针对性地谈自己的有点。例如应聘产品经理，优点为逻辑能力强、善于与人沟通；应聘运营，优点为善于站在他人的角度为人着想，善于与人打交道等等。</p><p><strong>谈缺点需要注意2点</strong></p><p>1）避免谈职业致命缺点，比如：应聘产品经理，你说自己的缺点是思维混乱、没有时间观念，性格内向，那基本上就GG了<br>2）避免避重就轻，谈不算缺点的缺点，比如：工作进度快，容易让其他同事赶不上进度这些<br>可以谈已经找到方法并正在改正的缺点，并说清楚自己的改正计划，或者谈一个利用你的优点改正的缺点，顺便带出自己的一个优点等。例如：喜欢追求完美，导致任务延期，已经通过学习时间管理，有意识地改变工作方式，争取如期完成自己的工作</p><h4 id="2-你是否接受加班？"><a href="#2-你是否接受加班？" class="headerlink" title="2.你是否接受加班？"></a>2.你是否接受加班？</h4><p>面试官这样问，一般有2个意图。一就是公司经常加班，需要你明确表达个人意愿；二就是公司只是想了解你对这个问题的个人看法，以及你的工作态度。</p><p><strong>对于这种问题，作死的回答是：</strong></p><ul><li>我无条件接受加班</li><li>我会在工作时间完成自己的工作</li><li>我不喜欢加班，不能接受加班</li></ul><p>前两个回答太绝对，可信度不高，面试官也不会相信这个答案，最后的回答，大家都懂，没有面试官喜欢听到这样的答案。</p><p>建议大家回答的时候遵循以下原则：</p><ul><li><p>从言语中体现自己的抗压能力、责任心、以及工作效率</p></li><li><p>强调工作需要，表现出积极心态，对于加班，具体情况具体对待。</p></li></ul><p>大家可以这样机智回答：我很愿意接受挑战，但我会提高工作时间的效率，争取在规定的时间内完成工作。但如果工作任务紧急，我愿意和同事们一起加班完成工作，这也是我个人职责。</p><h4 id="3-你对薪资有什么要求吗？"><a href="#3-你对薪资有什么要求吗？" class="headerlink" title="3.你对薪资有什么要求吗？"></a>3.你对薪资有什么要求吗？</h4><p>这个问题往往是求职者认为很难回答的一个问题，说高了怕丢了offer，说低了，自己不愿意。有的同学干脆会说自己不太追求薪资，对薪资没要求。这样的回答，不仅让面试官觉得你对行业薪资没有最基本的认知，甚至认为你对自己没有信心，不敢谈薪资。</p><p>大家可以在面试前多去了解自己应聘的行业、企业、岗位的大概薪资范围，再自我评估一下自己各方面的条件，定一个自己满意的薪资区间。最后再现场评估自己面试的表现，面试官的态度，觉得有把握，可以在预设好薪资区间内多要点，反之可以保守一些。</p><h4 id="4-在五年的时间内，你的职业规划？"><a href="#4-在五年的时间内，你的职业规划？" class="headerlink" title="4.在五年的时间内，你的职业规划？"></a>4.在五年的时间内，你的职业规划？</h4><p>一个对未来有规划的人，会认真踏实地工作，并有意识地提升自己，这是面试官需要确认的。这个问题需要你对该岗位的职业发展路径有一定的了解，知道晋升路径、花费的时间以及相应的能力需求。可以做以时间线做一个规划，例如1-3年，如何培养自己的什么技能、晋升为什么岗位。</p><h4 id="5-我们为什么要聘用你？"><a href="#5-我们为什么要聘用你？" class="headerlink" title="5.我们为什么要聘用你？"></a>5.我们为什么要聘用你？</h4><p>这句话的潜台词是“你凭什么胜任这个岗位”，这时候你就要向面试官展现出你的能力了。</p><p>一般可以围绕以下三回答这个问题：</p><ul><li><p>强调自己的能力与职位匹配，用数据、实例来证明自己可以胜任这个职位。</p></li><li><p>描述你加入公司后能为公司带来什么，要达成什么的目标，为公司业绩带来多少增长等。</p></li><li><p>展现自己的与职位相关的自身优势。</p></li></ul><h4 id="6-你对于我们公司了解多少？"><a href="#6-你对于我们公司了解多少？" class="headerlink" title="6.你对于我们公司了解多少？"></a>6.你对于我们公司了解多少？</h4><p>这个问题就很难有当场取巧的回答方式了，建议大家应聘前要提前做好功课，到百度或者公司官网上了解一下该公司大概情况，例如：主营业务、近几年的重点业务、发展方向，近期的重大战略调整等等。</p><h4 id="7-你为什么愿意到我们公司？"><a href="#7-你为什么愿意到我们公司？" class="headerlink" title="7.你为什么愿意到我们公司？"></a>7.你为什么愿意到我们公司？</h4><p>面试官想通过你的回答了解2点。第一点是你的求职动机。第二点是你对企业是否有一定的了解。</p><p>那要怎么进行回答呢，建议从行业、企业、岗位三个角度去回答</p><ul><li><p><strong>行业层面</strong>：通过宏观分析行业情况，表达你对行业发展前景的看好以及个人喜欢这个行业</p></li><li><p><strong>企业层面</strong>：提前熟悉公司的基本情况，表达出你对公司哪一方面的认同和赞赏（氛围/工作环境/发展前景等等）。</p></li><li><p><strong>岗位层面</strong>：充分了解应聘岗位的实际情况、职能范围与能力要求，表达自己对岗位的喜欢，并通过展现自己的自身优势，说服面试官你适合这个岗位。</p></li></ul><h4 id="8-与上级意见不一致，如何处理？"><a href="#8-与上级意见不一致，如何处理？" class="headerlink" title="8.与上级意见不一致，如何处理？"></a>8.与上级意见不一致，如何处理？</h4><p>面试官希望通过这个问题，了解你为人处世，沟通交流的能力。</p><p>回答可以围绕这几个点进行展开：具体情况具体分析、沟通、换位思考、尊重</p><p>可以这样回答：首先我会尊重上级的意见，对于非原则性问题，我会选择去服从上级的安排。但对于涉及公司利益或者其他重大性的问题，我会选择换位思考，了解上级的想法后去和上级进行积极的沟通，告诉他我的想法，给予上级一些建议。</p><h4 id="9-你缺乏工作经验，如何能胜任这份工作？"><a href="#9-你缺乏工作经验，如何能胜任这份工作？" class="headerlink" title="9.你缺乏工作经验，如何能胜任这份工作？"></a>9.你缺乏工作经验，如何能胜任这份工作？</h4><p>遇到这个问题，大家不需要惊慌，因为大家都是应届生，没有工作经验是很正常的。只需要回答的时候能给出一个令人信服的答案即可。首先要谦虚地承认自己地经验不足，然后可以谈一下自己对岗位地理解，并表示出自己正在不断地学习，并举出实例。如果有相关地实习、项目经历，也可用来进行分析，充分展示自己。最后可以表明一下自己的决心。</p><h4 id="10-工作中与同事发生争执，你会怎么处理？"><a href="#10-工作中与同事发生争执，你会怎么处理？" class="headerlink" title="10.工作中与同事发生争执，你会怎么处理？"></a>10.工作中与同事发生争执，你会怎么处理？</h4><p>工作中遇到争执、意见不统一是经常事情，面试官想通过这个问题，了解你的处事能力，能不能很好地处理同事问题。</p><p><strong>回答问题事抓住3点即可：</strong></p><ol><li>积极与同事进行沟通，并会在沟通前做好准备，对工作进行梳理，看看哪里有问题，提高沟通时的效率</li><li>沟通的时候多去倾听同事的意见，并作深入的思考，不会固执己见，不会一味盲目地坚持自己的管的</li><li>会通过一些数据、事实去印证自己观点，说服同事</li></ol><blockquote><p>作者：憨憨李<br>链接：<a href="https://www.nowcoder.com/discuss/414288" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/414288</a><br>来源：牛客网</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;你最大的优点和缺点&lt;/li&gt;
&lt;li&gt;你是否接受加班？&lt;/li&gt;
&lt;li&gt;你对薪资有什么要求吗？&lt;/li&gt;
&lt;li&gt;在五年的时间内，你的职业规划？&lt;/li&gt;
&lt;li&gt;我们为什么要聘用你？&lt;/li&gt;
&lt;li&gt;你对于我们公司了解多少？&lt;/li&gt;
&lt;li&gt;你为什么愿意到我们公司？&lt;/li&gt;
&lt;li&gt;与上级意见不一致，如何处理？&lt;/li&gt;
&lt;li&gt;你缺乏工作经验，如何能胜任这份工作？&lt;/li&gt;
&lt;li&gt;工作中与同事发生争执，你会怎么处理？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://heiyehk.github.io/blog/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://heiyehk.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中常见设计模式整理</title>
    <link href="https://heiyehk.github.io/blog/JavaScript-%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/"/>
    <id>https://heiyehk.github.io/blog/JavaScript-%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/</id>
    <published>2020-04-30T08:42:27.000Z</published>
    <updated>2020-04-30T09:28:02.209Z</updated>
    
    <content type="html"><![CDATA[<p>开发中，我们或多或少地接触了设计模式，但是很多时候不知道自己使用了哪种设计模式或者说该使用何种设计模式。本文意在梳理常见设计模式的特点，从而对它们有比较清晰的认知。</p><h3 id="JavaScript-中常见设计模式"><a href="#JavaScript-中常见设计模式" class="headerlink" title="JavaScript 中常见设计模式"></a>JavaScript 中常见设计模式</h3><a id="more"></a><ul><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">单例模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">策略模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">代理模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">迭代器模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">发布-订阅模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">命令模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">组合模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">模板方法模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">享元模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">职责链模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">中介者模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">装饰者模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">状态模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">适配者模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">观察者模式</a></li></ul><h3 id="各设计模式关键词"><a href="#各设计模式关键词" class="headerlink" title="各设计模式关键词"></a>各设计模式关键词</h3><p>看完了上述设计模式后，把它们的关键词特点罗列出来，以后提到某种设计模式，进而联想相应的关键词和例子，从而心中有数。</p><table><thead><tr><th>设计模式</th><th>特点</th><th>案例</th></tr></thead><tbody><tr><td>单例模式</td><td>一个类只能构造出唯一实例</td><td>创建菜单对象</td></tr><tr><td>策略模式</td><td>根据不同参数可以命中不同的策略</td><td>动画库里的算法函数</td></tr><tr><td>代理模式</td><td>代理对象和本体对象具有一致的接口</td><td>图片预加载</td></tr><tr><td>迭代器模式</td><td>能获取聚合对象的顺序和元素</td><td>each([1, 2, 3], cb)</td></tr><tr><td>发布-订阅模式</td><td>PubSub</td><td>瀑布流库</td></tr><tr><td>命令模式</td><td>不同对象间约定好相应的接口</td><td>按钮和命令的分离</td></tr><tr><td>组合模式</td><td>组合模式在对象间形成一致对待的树形结构</td><td>扫描文件夹</td></tr><tr><td>模板方法模式</td><td>父类中定好执行顺序</td><td>咖啡和茶</td></tr><tr><td>享元模式</td><td>减少创建实例的个数</td><td>男女模具试装</td></tr><tr><td>职责链模式</td><td>通过请求第一个条件，会持续执行后续的条件，直到返回结果为止</td><td>if else 优化</td></tr><tr><td>中介者模式</td><td>对象和对象之间借助第三方中介者进行通信</td><td>测试结束告知结果</td></tr><tr><td>装饰者模式</td><td>动态地给函数赋能</td><td>天冷了穿衣服，热了脱衣服</td></tr><tr><td>状态模式</td><td>每个状态建立一个类，状态改变会产生不同行为</td><td>电灯换挡</td></tr><tr><td>适配者模式</td><td>一种数据结构改成另一种数据结构</td><td>枚举值接口变更</td></tr><tr><td>观察者模式</td><td>当观察对象发生变化时自动调用相关函数</td><td>vue 双向绑定</td></tr></tbody></table><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote><p>《JavaScript设计模式与开发实践》</p></blockquote><blockquote><p>作者：牧云云<br>链接：<a href="https://juejin.im/post/5afe6430518825428630bc4d" target="_blank" rel="noopener">https://juejin.im/post/5afe6430518825428630bc4d</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中，我们或多或少地接触了设计模式，但是很多时候不知道自己使用了哪种设计模式或者说该使用何种设计模式。本文意在梳理常见设计模式的特点，从而对它们有比较清晰的认知。&lt;/p&gt;
&lt;h3 id=&quot;JavaScript-中常见设计模式&quot;&gt;&lt;a href=&quot;#JavaScript-中常见设计模式&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中常见设计模式&quot;&gt;&lt;/a&gt;JavaScript 中常见设计模式&lt;/h3&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://heiyehk.github.io/blog/categories/js/"/>
    
      <category term="设计模式" scheme="https://heiyehk.github.io/blog/categories/js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://heiyehk.github.io/blog/tags/js/"/>
    
      <category term="设计模式" scheme="https://heiyehk.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端面试：谈谈 JS 垃圾回收机制</title>
    <link href="https://heiyehk.github.io/blog/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%EF%BC%9A%E8%B0%88%E8%B0%88-JS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://heiyehk.github.io/blog/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%EF%BC%9A%E8%B0%88%E8%B0%88-JS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-30T08:25:16.000Z</published>
    <updated>2020-04-30T09:27:53.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。</p><p>当不再需要某样东西时会发生什么? JavaScript 引擎是如何发现并清理它?</p><h3 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h3><p>JavaScript 中内存管理的主要概念是可达性。</p><a id="more"></a><p>简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。</p><ol><li>有一组基本的固有可达值，由于显而易见的原因无法删除。例如:<ul><li>本地函数的局部变量和参数</li><li>当前嵌套调用链上的其他函数的变量和参数</li><li>全局变量</li><li>还有一些其他的，内部的</li></ul></li></ol><p><strong>这些值称为根。</strong></p><ol start="2"><li>如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。</li></ol><p>例如，如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为可达性， 它引用的那些也是可以访问的，详细的例子如下。</p><p>JavaScript 引擎中有一个后台进程称为<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="noopener">垃圾回收器</a>，它监视所有对象，并删除那些不可访问的对象。</p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>下面是最简单的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user 具有对象的引用</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://image-static.segmentfault.com/289/469/2894691528-5c92e57b9339d_articlex" alt="例子"></p><p>这里箭头表示一个对象引用。全局变量“user”引用对象 {name:“John”} (为了简洁起见，我们将其命名为John)。John 的 “name” 属性存储一个基本类型，因此它被绘制在对象中。</p><p>如果 user 的值被覆盖，则引用丢失:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://image-static.segmentfault.com/138/680/1386806337-5c93267a5206f_articlex" alt="例子"></p><p>现在 John 变成不可达的状态，没有办法访问它，没有对它的引用。垃圾回收器将丢弃 John 数据并释放内存。</p><h3 id="两个引用"><a href="#两个引用" class="headerlink" title="两个引用"></a>两个引用</h3><p>现在让我们假设我们将引用从 user 复制到 admin:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user具有对象的引用</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = user;</span><br></pre></td></tr></table></figure><p><img src="https://image-static.segmentfault.com/133/655/133655656-5c9327b57caa3_articlex" alt="例子"></p><p>现在如果我们做同样的事情:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>该对象仍然可以通过 admin 全局变量访问，所以它在内存中。如果我们也覆盖admin，那么它可以被释放。</p><h3 id="相互关联的对象"><a href="#相互关联的对象" class="headerlink" title="相互关联的对象"></a>相互关联的对象</h3><p>现在来看一个更复杂的例子， family 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">marry</span> (<span class="params">man, woman</span>) </span>&#123;</span><br><span class="line">  woman.husban = man;</span><br><span class="line">  man.wife = woman;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    father: man,</span><br><span class="line">    mother: woman</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> family = marry(&#123;</span><br><span class="line">  name: <span class="string">"John"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: <span class="string">"Ann"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>函数 <code>marry</code> 通过给两个对象彼此提供引用来“联姻”它们，并返回一个包含两个对象的新对象。</p><p>产生的内存结构:</p><p><img src="https://image-static.segmentfault.com/447/270/447270667-5c9329b9e28bb_articlex" alt="结构"></p><p>到目前为止，所有对象都是可访问的。</p><p>现在让我们删除两个引用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> family.father;</span><br><span class="line"><span class="keyword">delete</span> family.mother.husband;</span><br></pre></td></tr></table></figure><p><img src="https://image-static.segmentfault.com/359/593/3595939355-5c932ad1e5d2d_articlex" alt="流程"></p><p>仅仅删除这两个引用中的一个是不够的，因为所有对象仍然是可访问的。</p><p>但是如果我们把这两个都删除，那么我们可以看到 John 不再有传入的引用:</p><p><img src="https://image-static.segmentfault.com/162/805/1628058185-5c932b9750b6d_articlex" alt="流程"></p><p>输出引用无关紧要。只有传入的对象才能使对象可访问，因此，John 现在是不可访问的，并将从内存中删除所有不可访问的数据。</p><p>垃圾回收之后：</p><p><img src="https://image-static.segmentfault.com/129/587/1295875551-5c932c350dd1e_articlex" alt="流程"></p><h3 id="无法访问的数据块"><a href="#无法访问的数据块" class="headerlink" title="无法访问的数据块"></a>无法访问的数据块</h3><p>有可能整个相互连接的对象变得不可访问并从内存中删除。</p><p>源对象与上面的相同。然后:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">family = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>内存中的图片变成:</p><p><img src="https://image-static.segmentfault.com/420/035/420035998-5c932d8f3b867_articlex" alt="流程"></p><p>这个例子说明了可达性的概念是多么重要。</p><p>很明显，John和Ann仍然链接在一起，都有传入的引用。但这还不够。</p><p>“family”对象已经从根上断开了链接，不再有对它的引用，因此下面的整个块变得不可到达，并将被删除。</p><h3 id="内部算法"><a href="#内部算法" class="headerlink" title="内部算法"></a>内部算法</h3><p>基本的垃圾回收算法称为<strong>*“标记-清除”</strong>，定期执行以下“垃圾回收”步骤:</p><ul><li>垃圾回收器获取根并<strong>“标记”</strong>(记住)它们。</li><li>然后它访问并“标记”所有来自它们的引用。</li><li>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</li><li>以此类推，直到有未访问的引用(可以从根访问)为止。</li><li>除标记的对象外，所有对象都被删除。</li></ul><p>例如，对象结构如下:</p><p><img src="https://image-static.segmentfault.com/170/734/1707342869-5c9358c332559_articlex" alt="结构"></p><p>我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看<strong>“标记并清除”</strong>垃圾回收器如何处理它。</p><h4 id="第一步标记根"><a href="#第一步标记根" class="headerlink" title="第一步标记根"></a>第一步标记根</h4><p><img src="https://image-static.segmentfault.com/269/043/269043904-5c9359379ef4a_articlex" alt="标记"></p><h4 id="然后标记他们的引用"><a href="#然后标记他们的引用" class="headerlink" title="然后标记他们的引用"></a>然后标记他们的引用</h4><p><img src="https://image-static.segmentfault.com/423/514/4235146972-5c9359632ee4e_articlex" alt="引用"></p><h4 id="以及子孙代的引用"><a href="#以及子孙代的引用" class="headerlink" title="以及子孙代的引用:"></a>以及子孙代的引用:</h4><p><img src="https://image-static.segmentfault.com/198/890/1988905638-5c9359b1138ea_articlex" alt="引用"></p><h4 id="现在进程中不能访问的对象被认为是不可访问的，将被删除"><a href="#现在进程中不能访问的对象被认为是不可访问的，将被删除" class="headerlink" title="现在进程中不能访问的对象被认为是不可访问的，将被删除:"></a>现在进程中不能访问的对象被认为是不可访问的，将被删除:</h4><p><img src="https://image-static.segmentfault.com/434/932/434932871-5c9359fc2ac1b_articlex" alt="引用"></p><p>这就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。</p><p>一些优化:</p><ul><li><code>分代回收</code>——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。</li><li><code>增量回收</code>——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。</li><li><code>空闲时间收集</code>——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。</li></ul><h3 id="面试怎么回答"><a href="#面试怎么回答" class="headerlink" title="面试怎么回答"></a>面试怎么回答</h3><h4 id="1）问什么是垃圾"><a href="#1）问什么是垃圾" class="headerlink" title="1）问什么是垃圾"></a>1）问什么是垃圾</h4><p>一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。</p><h4 id="2）如何检垃圾"><a href="#2）如何检垃圾" class="headerlink" title="2）如何检垃圾"></a>2）如何检垃圾</h4><p>一种算法是标记 <code>标记-清除</code> 算法，还想说出不同的算法可以参考<a href="https://www.jianshu.com/p/a8a04fd00c3c" target="_blank" rel="noopener">这里</a>。</p><p>更深入一些的讲解 <a href="http://newhtml.net/v8-garbage-collection/" target="_blank" rel="noopener">http://newhtml.net/v8-garbage…</a></p><p>还有一种牛逼的答法就是说看我的博客，当然是要自己总结的博客。</p><p>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href="https://www.fundebug.com/?utm_source=xiaozhi" target="_blank" rel="noopener">Fundebug</a>。</p><blockquote><p>作者：前端小智<br>链接：<a href="https://segmentfault.com/a/1190000018605776" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018605776</a><br>来源：思否</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;垃圾回收&quot;&gt;&lt;a href=&quot;#垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收&quot;&gt;&lt;/a&gt;垃圾回收&lt;/h3&gt;&lt;p&gt;JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。&lt;/p&gt;
&lt;p&gt;当不再需要某样东西时会发生什么? JavaScript 引擎是如何发现并清理它?&lt;/p&gt;
&lt;h3 id=&quot;可达性&quot;&gt;&lt;a href=&quot;#可达性&quot; class=&quot;headerlink&quot; title=&quot;可达性&quot;&gt;&lt;/a&gt;可达性&lt;/h3&gt;&lt;p&gt;JavaScript 中内存管理的主要概念是可达性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://heiyehk.github.io/blog/categories/js/"/>
    
      <category term="垃圾回收" scheme="https://heiyehk.github.io/blog/categories/js/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="js底层" scheme="https://heiyehk.github.io/blog/categories/js/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/js%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="js" scheme="https://heiyehk.github.io/blog/tags/js/"/>
    
      <category term="垃圾回收" scheme="https://heiyehk.github.io/blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="js底层" scheme="https://heiyehk.github.io/blog/tags/js%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="https://heiyehk.github.io/blog/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://heiyehk.github.io/blog/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2020-04-30T07:25:00.000Z</published>
    <updated>2020-04-30T09:28:06.744Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在md中你需要某个字符或标签不被编译的话在前面加上<code>\</code>斜杠<br>MarkDown在线编辑器<br><a href="http://mahua.jser.me/" target="_blank" rel="noopener">MaHua 在线markdown编辑器</a><br><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">Cmd Markdown 编辑阅读器 - 作业部落出品</a>  </p></blockquote><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># h1</span></span><br><span class="line"><span class="section">## h2</span></span><br><span class="line"><span class="section">### h3</span></span><br><span class="line">....</span><br><span class="line"><span class="section">###### h6</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**加粗**</span></span><br></pre></td></tr></table></figure><p>示例: <strong>加粗后</strong></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br></pre></td></tr></table></figure><p>示例: <em>斜体</em></p><h3 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">***斜体加粗**</span>*</span><br></pre></td></tr></table></figure><p>示例: <strong><em>斜体加粗</em></strong></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>示例: <del>删除线</del></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用</span></span><br><span class="line">&gt;&gt; 可以嵌套</span><br></pre></td></tr></table></figure><blockquote><p>示例: 引用</p><blockquote><p>可以嵌套</p></blockquote></blockquote><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以下字符都需要3个以上</span><br><span class="line">---</span><br><span class="line"><span class="emphasis">***</span></span><br></pre></td></tr></table></figure><p>示例: </p><hr><hr><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">图片alt就是当图片不能显示或者显示错误时的文字，图片title可选</span><br><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 '图片title'</span>)</span><br></pre></td></tr></table></figure><p>示例: <img src="http://heiyehk.top/public/img/logo.jpg" alt="图片alt" title="title"></p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title可选</span><br><span class="line">[<span class="string">超链接文案</span>](<span class="link">地址 'title'</span>)</span><br></pre></td></tr></table></figure><p>示例: <a href="https://www.baidu.com" target="_blank" rel="noopener" title="百度">baidu</a></p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">记得符号后面有个空格,嵌套换行加空格再加符号空格的方式</span><br><span class="line"><span class="bullet">- </span>内容</span><br><span class="line"><span class="bullet">  - </span>嵌套内容</span><br><span class="line"><span class="bullet">+ </span>内容</span><br><span class="line"><span class="bullet">* </span>内容</span><br></pre></td></tr></table></figure><p>示例:</p><ul><li>减号内容<ul><li>嵌套内容</li></ul></li></ul><ul><li>加号内容</li></ul><ul><li>星号内容</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>需要注意的是,不同的编辑器和编译md方式不一样,那么使用方法也不一样,有些不能使用有序嵌套</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数字加点加空格,嵌套换行加空格再加符号空格的方式</span><br><span class="line"><span class="bullet">1. </span>第一</span><br><span class="line"><span class="bullet"> 1. </span>第一个中的第一个</span><br><span class="line"><span class="bullet">2. </span>第二</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>示例:</p><ol><li>第一个<ol><li>第一个中的第一个</li></ol></li><li>第二个</li></ol><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表格内容允许为空</span><br><span class="line">标题1 | 标题2 | 标题3</span><br><span class="line">-|-|-</span><br><span class="line">内容1 | 内容2 | 内容3</span><br><span class="line"> | 内容2 |</span><br></pre></td></tr></table></figure><p>示例:</p><table><thead><tr><th>标题1</th><th>标题2</th><th>标题3</th></tr></thead><tbody><tr><td>内容1</td><td>内容2</td><td>内容3</td></tr><tr><td></td><td>内容2</td><td></td></tr></tbody></table><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`高亮内容`</span></span><br></pre></td></tr></table></figure><p>示例: <code>高亮</code></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">去掉多余的\</span><br><span class="line"><span class="code">```</span> js</span><br><span class="line">var a = 0;</span><br><span class="line">console.log(a);</span><br><span class="line">\</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line">\</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = <span class="number">1</span></span><br><span class="line">strs = <span class="string">'aaa'</span></span><br><span class="line">\</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; js</span><br><span class="line">var a &#x3D; 0;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 1<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = <span class="number">1</span></span><br><span class="line">strs = <span class="string">'aaa'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在md中你需要某个字符或标签不被编译的话在前面加上&lt;code&gt;\&lt;/code&gt;斜杠&lt;br&gt;MarkDown在线编辑器&lt;br&gt;&lt;a href=&quot;http://mahua.jser.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MaHua 在线markdown编辑器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zybuluo.com/mdeditor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cmd Markdown 编辑阅读器 - 作业部落出品&lt;/a&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h3&gt;&lt;figure class=&quot;highlight md&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;# h1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;## h2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;### h3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;###### h6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="MarkDown" scheme="https://heiyehk.github.io/blog/categories/MarkDown/"/>
    
    
      <category term="MarkDown" scheme="https://heiyehk.github.io/blog/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>JS事件循环机制（event loop）之宏任务/微任务</title>
    <link href="https://heiyehk.github.io/blog/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%EF%BC%88event-loop%EF%BC%89%E4%B9%8B%E5%AE%8F%E4%BB%BB%E5%8A%A1-%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <id>https://heiyehk.github.io/blog/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%EF%BC%88event-loop%EF%BC%89%E4%B9%8B%E5%AE%8F%E4%BB%BB%E5%8A%A1-%E5%BE%AE%E4%BB%BB%E5%8A%A1/</id>
    <published>2020-04-30T06:39:18.000Z</published>
    <updated>2020-04-30T09:28:04.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a><br>同类文章 <a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></p></blockquote><p>鉴于上篇文章有提到过 微任务与宏任务，所以，在此做个细致补充： 话不多说，直接进入正文：</p><blockquote><ul><li>[1] 本文主要根据网上资源总结而来，如有不对，请斧正。</li><li>[2] 需要知道的专业名词术语：synchronous：同步任务、asynchronous：异步任务、task queue/callback queue：任务队列、execution context stack：执行栈、heap：堆、stack：栈、macro-task：宏任务、micro-task：微任务</li></ul></blockquote><a id="more"></a><h3 id="首先我们要知道两点："><a href="#首先我们要知道两点：" class="headerlink" title="首先我们要知道两点："></a>首先我们要知道两点：</h3><ul><li>JavaScript是单线程的语言</li><li>Event Loop是javascript的执行机制</li></ul><h3 id="javascript事件循环"><a href="#javascript事件循环" class="headerlink" title="javascript事件循环"></a>javascript事件循环</h3><p>js是单线程，就像学生排队上厕所，学生需要排队一个一个上厕所，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fa38dcffce?imageslim" alt="执行图片"><br>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p><hr><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制</p><h4 id="先看一段代码："><a href="#先看一段代码：" class="headerlink" title="先看一段代码："></a>先看一段代码：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><p>打印顺序是什么？ 正确答案是：script start, script end, promise1, promise2, setTimeout 已蒙圈。。。</p><h4 id="为什么会出现这样打印顺序呢？"><a href="#为什么会出现这样打印顺序呢？" class="headerlink" title="为什么会出现这样打印顺序呢？"></a>为什么会出现这样打印顺序呢？</h4><ul><li>如下导图（此图从网站下载）<br><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fb89da87c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="执行顺序"></li></ul><p>解读：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>我们不禁要问了，那怎么知道主线程执行栈为空呢？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url:www.javascript.com,</span><br><span class="line">  data:data,</span><br><span class="line">  success:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'发送成功!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码执行结束'</span>);</span><br></pre></td></tr></table></figure><p>上面是一段简易的ajax请求代码：</p><ul><li>ajax进入Event Table，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入Event Queue。</li><li>主线程从Event Queue读取回调函数success并执行。<br>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。</li></ul><hr><h3 id="微任务-Microtasks-、宏任务-task-？"><a href="#微任务-Microtasks-、宏任务-task-？" class="headerlink" title="微任务(Microtasks)、宏任务(task)？"></a>微任务(Microtasks)、宏任务(task)？</h3><p>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢？</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fa4b42e4af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="执行顺序"></p><blockquote><p>一个掘金的老哥（ssssyoki）的文章摘要：<br>那么如此看来我给的答案还是对的。但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。 我当时看到这我就服了还有这种骚操作。</p></blockquote><ul><li>而宏任务一般是：包括整体代码script，setTimeout，setInterval、setImmediate。</li><li>微任务：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver</li><li>记住就行了。</li><li>process是什么？</li></ul><hr><p>不废话，看以下例子：</p><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><p>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'延时3秒'</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  task();</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行console'</span>);</span><br></pre></td></tr></table></figure><p>根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行console</span></span><br><span class="line"><span class="comment">// task()</span></span><br></pre></td></tr></table></figure><p>去验证一下，结果正确！ 然后我们修改一下前面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  task()</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">10000000</span>)</span><br></pre></td></tr></table></figure><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解<code>setTimeout</code>的定义。我们先说上述代码是怎么执行的：</p><ul><li>ask()进入Event Table并注册,计时开始。</li><li>执行sleep函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。</li><li>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。</li></ul><p>上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p><hr><p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？<br>答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>)</span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>代码1的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先执行这里</span><br><span class="line">执行啦</span><br></pre></td></tr></table></figure><p>代码2的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先执行这里</span><br><span class="line">&#x2F;&#x2F; ... 3s later</span><br><span class="line">&#x2F;&#x2F; 执行啦</span><br></pre></td></tr></table></figure><p><strong>关于<code>setTimeout</code>要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据<code>HTML</code>的标准，最低是<code>4毫秒</code>。有兴趣的同学可以自行了解。</strong></p><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入<code>Event Queue</code>，如果前面的任务耗时太久，那么同样需要等待。</p><p>唯一需要注意的一点是，对于<code>setInterval(fn,ms)</code>来说，我们已经知道不是每过<code>ms</code>秒会执行一次<code>fn</code>，而是每过<code>ms</code>秒，会有<code>fn</code>进入<code>Event Queue</code>。一旦<code>setInterval</code>的回调函数<code>fn</code>执行时间超过了延迟时间<code>ms</code>，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p><h3 id="Promise与process-nextTick-callback"><a href="#Promise与process-nextTick-callback" class="headerlink" title="Promise与process.nextTick(callback)"></a>Promise与process.nextTick(callback)</h3><p><code>Promise</code>的定义和功能本文不再赘述，可以学习一下 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰老师的Promise</a><br>而<code>process.nextTick(callback)</code>类似<code>node.js</code>版的”<code>setTimeout</code>“，在事件循环的下一次循环中调用 <code>callback</code> 回调函数。</p><p><strong>不同类型的任务会进入对应的<code>Event Queue</code>，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的<code>Event Queue</code>。</strong></p><p>看例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>最后输出结果是Promise1，Promise2，setTimeout1</strong></p><p><code>Promise</code>参数中的<code>Promise1</code>是同步执行的 其次是因为<code>Promise</code>是<code>microtasks</code>，会在同步任务执行完后会去清空<code>microtasks queues</code>， 最后<code>清空完微任务再去宏任务队列取值</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)  </span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>这回是嵌套，大家可以看看，最后输出结果是<code>Promise1，setTimeout1，Promise2，setTimeout2</code></strong></p><ul><li>一开始执行栈的同步任务执行完毕，会去 <code>microtasks queues</code> 找清空 <code>microtasks queues</code> ，输出<code>Promise1</code>，同时会生成一个异步任务 <code>setTimeout1</code></li><li>去宏任务队列查看此时队列是 <code>setTimeout1</code> 在 <code>setTimeout2</code> 之前，因为<code>setTimeout1</code>执行栈一开始的时候就开始异步执行,所以输出 <code>setTimeout1</code></li><li>在执行<code>setTimeout1</code>时会生成Promise2的一个 <code>microtasks</code> ，放入 <code>microtasks queues</code> 中，接着又是一个循环，去清空 <code>microtasks queues</code> ，输出 <code>Promise2</code></li><li>清空完 <code>microtasks queues</code> ，就又会去宏任务队列取一个，这回取的是 <code>setTimeout2</code></li></ul><p>如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/1649751a2eb3953f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="执行图"></p><p>最后我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ul><li>整体script作为第一个宏任务进入主线程，遇到console.log，输出<code>1</code>。</li><li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务<code>Event Queue</code>中。我们暂且记为<code>setTimeout1</code>。</li><li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li><li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出<code>7</code>。<code>then</code>被分发到微任务<code>Event Queue</code>中。我们记为<code>then1</code>。</li><li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务<code>Event Queue</code>中，我们记为<code>setTimeout2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td>process1</td></tr><tr><td>setTimeout2</td><td>then1</td></tr></tbody></table><p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了<code>1</code>和<code>7</code>。<br>我们发现了<code>process1</code>和<code>then1</code>两个微任务。</p><ul><li>执行<code>process1</code>,输出<code>6</code>。</li><li>执行<code>then1</code>，输出<code>8</code>。</li></ul><p>好了，第一轮事件循环正式结束，这一轮的结果是输出<code>1，7，6，8</code>。那么第二轮时间循环从<code>setTimeout1</code>宏任务开始：</p><ul><li>首先输出<code>2</code>。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务<code>Event Queue</code>中，记为<code>process2</code>。</li><li><code>new Promise</code>立即执行输出<code>4</code>，<code>then</code>也分发到微任务<code>Event Queue</code>中，记为<code>then2</code></li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td>process3</td></tr><tr><td></td><td>then3</td></tr></tbody></table><ul><li>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</li><li>输出10。</li><li>输出12。</li><li>第三轮事件循环结束，第三轮输出9，11，10，12。</li><li>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</li></ul><blockquote><p>作者：张倩qianniuer<br>链接：<a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">https://juejin.im/post/5b498d245188251b193d4059</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tasks, microtasks, queues and schedules&lt;/a&gt;&lt;br&gt;同类文章 &lt;a href=&quot;https://juejin.im/post/59e85eebf265da430d571f89&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这一次，彻底弄懂 JavaScript 执行机制&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;鉴于上篇文章有提到过 微任务与宏任务，所以，在此做个细致补充： 话不多说，直接进入正文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;[1] 本文主要根据网上资源总结而来，如有不对，请斧正。&lt;/li&gt;
&lt;li&gt;[2] 需要知道的专业名词术语：synchronous：同步任务、asynchronous：异步任务、task queue/callback queue：任务队列、execution context stack：执行栈、heap：堆、stack：栈、macro-task：宏任务、micro-task：微任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JS" scheme="https://heiyehk.github.io/blog/categories/JS/"/>
    
      <category term="event loop" scheme="https://heiyehk.github.io/blog/categories/JS/event-loop/"/>
    
      <category term="微任务" scheme="https://heiyehk.github.io/blog/categories/JS/event-loop/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="宏任务" scheme="https://heiyehk.github.io/blog/categories/JS/event-loop/%E5%BE%AE%E4%BB%BB%E5%8A%A1/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="JS" scheme="https://heiyehk.github.io/blog/tags/JS/"/>
    
      <category term="event loop" scheme="https://heiyehk.github.io/blog/tags/event-loop/"/>
    
      <category term="微任务" scheme="https://heiyehk.github.io/blog/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="宏任务" scheme="https://heiyehk.github.io/blog/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Web前端开发工程师编程能力飞升之路</title>
    <link href="https://heiyehk.github.io/blog/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E9%A3%9E%E5%8D%87%E4%B9%8B%E8%B7%AF/"/>
    <id>https://heiyehk.github.io/blog/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E9%A3%9E%E5%8D%87%E4%B9%8B%E8%B7%AF/</id>
    <published>2020-04-30T05:50:26.000Z</published>
    <updated>2020-04-30T09:28:11.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【背景】"><a href="#【背景】" class="headerlink" title="【背景】"></a>【背景】</h3><p>如果你是刚进入web前端研发领域，想试试这潭水有多深，看这篇文章吧；<br>如果你是做了两三年web产品前端研发，迷茫找不着提高之路，看这篇文章吧；<br>如果你是四五年的前端开发高手，没有难题能难得住你的寂寞高手，来看这篇文章吧；</p><p>web前端研发工程师，在国内是一个朝阳职业，自07-08年正式有这个职业以来，也不过三四年的时间。这个领域没有学校的正规教育，没有行内成体 系的理论指引，几乎所有从事这个职业的人都是靠自己自学成才。自学成才，一条艰辛的坎坷路，我也是这样一路走来。从2002年开始接触web前端研发至今 已然有了9个年头，如今再回首，期间的走了很多弯路。推已及人，如果能让那些后来者少走些弯路，辛甚辛甚！</p><a id="more"></a><h3 id="【前言】"><a href="#【前言】" class="headerlink" title="【前言】"></a>【前言】</h3><p>所谓的天才，只不过是比平常人更快的掌握技能、完成工作罢了；只要你找到了正确的方向，并辅以足够的时间，你一样能够踏上成功彼岸。</p><p>本文将web前端研发编程能力划分了八个等级，每个等级都列举出了对应的特征及破级提升之方法，希望每位在看本文的同学先准确定位自己的等级（不要以你目前能力的最高点，而是以你当前能力的中档与之等级作对比，以免多走弯路），参考突破之法破之。</p><p>所谓的级别，只是你面对需求时的一种态度：能够完成、能够完美地完成、能够超出预期地完成。以追求完美的态度加以扎实的编程功力，那就是你的编程水平。<br>切记心浮气燥，级别够了，那级别里的东西自然就懂了。悟了就是悟了，没悟也没关系，静下心来，投入时间而已。</p><h3 id="【入门】"><a href="#【入门】" class="headerlink" title="【入门】"></a>【入门】</h3><p>能够解决一些问题的水平。有一定的基础（比如最常见的html标签及其属性、事件、方法；最常见的css属性；基础的javascript编程能力），能够完成一些简单的web前端研发需求。<br>举个例子：删除一字符串中指定的字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"www.baidu.com/?page"</span>;  </span><br><span class="line">str=str.replace(<span class="string">'?page'</span>,<span class="string">""</span>);  </span><br><span class="line">alert(str);  </span><br><span class="line">str=str.substring(<span class="number">0</span>,str.indexof(<span class="string">"/"</span>));  </span><br><span class="line">alert(str);</span><br></pre></td></tr></table></figure><p>首先不要苛责代码的对错严谨，毕竟每个程序员都有这样的一个过程；其次，这两段代码在这个实例里没有什么大过错，可能会有瑕疵，但能够解决问题（删除指定的字符），这就是这个级别的特征。<br>再举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算系统当前是星期几  </span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> week = <span class="keyword">new</span> date().getday();</span><br><span class="line"><span class="keyword">if</span> (week == <span class="number">0</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期日"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">1</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期一"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">2</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期二"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">3</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期三"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">4</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期四"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">5</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期五"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">6</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期六"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者更好一些  </span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">"今天是星期"</span>;</span><br><span class="line"><span class="keyword">var</span> week = <span class="keyword">new</span> date().getday();</span><br><span class="line"><span class="keyword">switch</span> (week) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    str1 += <span class="string">"日"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    str1 += <span class="string">"一"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    str1 += <span class="string">"二"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    str1 += <span class="string">"三"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    str1 += <span class="string">"四"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    str1 += <span class="string">"五"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    str1 += <span class="string">"六"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(str);</span><br><span class="line">alert(str1);</span><br></pre></td></tr></table></figure><p>入门”阶段是每个程序员的必经之路，只要”入门”，你就上路了。所谓”师傅领进门，修行靠个人”，有了这个”入门”的基础，自己就可以摸索着前进了。</p><p>进阶之路</p><p>将javascript、html、css之类的编码帮助手册里的每个方法/属性都通读几遍！只有将基础打好，以后的路才能走的顺畅。参考这些帮助文档，力争写出无瑕疵的代码。<br>这些编码文档建议不仅是在入门提高期看，在你以后每个阶段破阶的时候都应该看看，最基础的东西往往也是最给力的东西，有时能够给你带来意想不到的收获。</p><h3 id="【登堂】"><a href="#【登堂】" class="headerlink" title="【登堂】"></a>【登堂】</h3><p>能够正确地解决问题。不管你是通过搜索网络，或者通过改造某些成品代码（jquery/dojo/ext/yui）案例，只要能够无错地完成需求。<br>同样以上面的那段”字符串剪裁”代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"www.baidu.com/?page"</span>;</span><br><span class="line">str=str.replace(<span class="regexp">/?page/</span>,<span class="string">""</span>);</span><br><span class="line">alert(str);</span><br></pre></td></tr></table></figure><p>仅仅解决问题对于”登堂”阶段来说已经不是问题，这个级别所给出方案不能是漏洞百出。以上面这段代码为例：replace方法的第一个参数虽然可以支持字符串，但最佳的类型是正则表达式；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> array(<span class="string">"日"</span>, <span class="string">"一"</span>, <span class="string">"二"</span>, <span class="string">"三"</span>, <span class="string">"四"</span>, <span class="string">"五"</span>, <span class="string">"六"</span>);</span><br><span class="line"><span class="keyword">var</span> week = <span class="keyword">new</span> date().getday();</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"今天是星期"</span>+ a[week];</span><br><span class="line">alert(str);</span><br></pre></td></tr></table></figure><p>对比”入门级”的代码，不管是从代码量、代码效率、代码优美性、代码思路来说，”登堂”级的这个日期处理代码都要优秀很多。</p><p>进阶之路</p><p>这个阶段虽然能够给出正确的解题方案，但是不一定是最优秀的方案。如何才能得到最优秀的方案呢？首先就是积累各种能够解决需求的方案，然后再验证每个方案，在这些方案中选择最好的一种。因此该阶段的进阶之路就是”行万里路，看万卷书”，积累各个需求的各个解决方案。</p><p>你可以扎身在专业论坛（蓝色理想、无忧、csdn）里，通读所有的faq及帖子；你可以打开搜索引擎，穷举所有的搜索结果。自己建立测试环境一一 验  证这些代码：去揣摩每段代码的意图，去比较每段代码之间的差异。这两条路可以让你快速完成原始积累，当你再面对大多数需求时能够说这些问题我以前做过， 那  你就水到渠成地晋阶了。</p><h3 id="【入室】"><a href="#【入室】" class="headerlink" title="【入室】"></a>【入室】</h3><p>最强代码，知道所有能够解决需求的各种方案，能够选择使用最优秀的方案满足需求。这个级别基本上产品开发编程中的代码主力。给出的一招一式，招招都是绝招。<br>还以上面的那个例子为例，你能说出1、2、3之间的差别，以及适用于那种环境吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"www.baidu.com/?page"</span>;</span><br><span class="line"><span class="comment">// 1、字符串剪裁</span></span><br><span class="line">str.substring(<span class="number">0</span>, str.indexof(<span class="string">"?page"</span>));</span><br><span class="line"><span class="comment">// 2、正则表达式</span></span><br><span class="line">str.replace(<span class="regexp">/?page/</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">// 3、字符串分拆、合并</span></span><br><span class="line">str.split(<span class="string">"?page"</span>).join(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>能够解决问题的方法会有很多，但是对于程序员来说应该选择最优秀的。上面这段代码从代码量来说”正则表达式”最优秀；从代码执行效率来说： “字符串剪裁”法最高（chrome中”正则表达式”效率最高），split法最次；从可扩展性上来说，”正则表达式”法最优。具体使用那种方案视具体 的  需求环境而定。</p><p>“入室”阶段，程序员应该能够肯定的回答：对于这个需求而言，我的代码就是最优秀的代码。</p><p>再以”今天是星期几”为例，”登堂”级的代码你敢说是最优秀的代码了吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算系统当前是星期几</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"今天是星期"</span> + <span class="string">"日一二三四五六"</span>.charat(<span class="keyword">new</span> date().getday());</span><br></pre></td></tr></table></figure><p>对比”登堂”级的示例代码，上面这段代码给你什么感受？程序员追求的就是完美。”入室”级别追求的就是每一招每一式的完美无缺。</p><p>从web前端编程来说，通过2年左右的努力，很多人能够达到这个水平，但是，很大一部分人的编程能力也就止步于此。或限于产品的需求单一性，或限于需求开发的时间紧迫性，或限于人的惰性，能够完美地解决当前的需求就够了。</p><p>由于长期处于技术平台期，技术上得不到提高，通常这个级别的工程师会比较燥。技术上小有所成；或追求个人的突破；或追求产品差异性带来的新鲜感；或者只是想换个心情；因此很多此级别的工程师会经常换公司。</p><p>戒骄戒躁：</p><p>切勿以为自己能写一手漂亮的代码而自满；<br>切莫以为别人”尊称”你一声”大侠”你就以 “大侠”自居；<br>切莫以为自己积累了一些得意的代码就成了框架式开发。</p><p>细节决定成败，优秀的方案并不能保证最终的成功。还以”删除指定字符串”为例，原始字符串从格式上来看应该是了个url链接，在去除”pn=0″之 后，最末尾处留了一个尾巴”?”；如果原始字符串是”<code>http://www.xxx.com/?pn=0&amp;a=1</code>″，去除”pn=0″之后 ? 和 &amp; 两个符号紧贴一起，这更是明显的bug。</p><p>进阶之路</p><p>此阶段进阶之路就是：切勿心浮气躁；你不再被需求牵着走，而是你牵着需求走。注重细节，注意那些当前需求里没有明文给出的细节：代码性能的差异、运行平台（浏览器）的差异、需求的隐性扩展、代码的向后兼容等等。</p><p>再通读几遍html/css/javascript帮助文档。</p><p>我建议这个级别的工程师做一做webtreeview控件，要求总节点量一万左右操作流畅，你的晋升之路就在这个控件的编码过程中。</p><h3 id="【入微】"><a href="#【入微】" class="headerlink" title="【入微】"></a>【入微】</h3><p>最强解决方案。你能够走在需求的前面，将当前需求里有的、没有直接提出来的、现在暂时没有但将来可能有的等等，及前端编程潜规则等各个方方面面都综合考虑，给出最优方案。以一招胜万招。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.xxx.com/?pn=0"</span>; <span class="comment">// 删除指定字符 pn=0</span></span><br><span class="line"><span class="comment">// 我将这个字符串里所可能想到的各种情况都列举出来</span></span><br><span class="line"><span class="keyword">var</span> a = [</span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?pn=0"</span>, <span class="comment">// pn= 可能出现在 ? 前</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?pn="</span>, <span class="comment">// url里允许pn 值为空</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?pn=0&amp;a=1"</span>, <span class="comment">// url 里可有多个字段</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?a=1&amp;pn=0"</span>, <span class="comment">// 可能排在最后</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1"</span>, <span class="comment">// 可能有多个 pn 字段</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=2"</span>, <span class="comment">// 可能在中间</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1&amp;b=1"</span>, <span class="comment">// 可能在中间成组</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=1&amp;pn=1"</span> <span class="comment">// 可能零星分布</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">/* 需求的不言之秘</span></span><br><span class="line"><span class="comment">? 若出现在字符串最尾则要去之</span></span><br><span class="line"><span class="comment">? &amp; 两个符号不可重叠</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/((\?)(pn=[^&amp;]*&amp;)+(?!pn=))|(((\?|&amp;)pn=[^&amp;]*)+$)|(&amp;pn=[^&amp;]*)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  alert(a + <span class="string">"\n"</span> + a.replace(reg, <span class="string">"$2"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个阶段已经不再追求一招一式，对你来说不是使用什么创新绝招解决需求，而是给出成熟稳重的方案，从根上解决问题。针对某个当前需求你的代码可能不是最优，但是针对此类的需求你的代码却是最优秀的代码。</p><p>进阶之路</p><p>很多web前端研发工程师在做了3-4年之后就会进入一个瓶颈期：产品开发需求是小菜一碟，没有新鲜的可以挑战的东西；代码开发中的稀奇的解题方 法  都已经尝试过。没有了可挑战的难题，失去了探索的激情，也就没有了再上升的动力，好不容易走过”入室”级别的人又会有八九成止步于此。或转做技术领导 人，  或转到其它的领域，或换公司。</p><p>这些人的上升之路在哪里呢？</p><p>这个阶段单单依靠技巧和数量的累积已经没有什么效果了，突破之路在第5层《化蝶》里会详细说明，我建议你在这个阶段末尾着重关注编程理论：面向对象/过程、代码组织形式、编译、代码规范、其它的框架设计等等。</p><p>我建议这个级别的工程师做一做webeditor控件，不要求完整功能，但是该控件里的模块划分、代码组织、编程思想做到位，给出一个系统的解决方案。</p><h3 id="【化蝶】"><a href="#【化蝶】" class="headerlink" title="【化蝶】"></a>【化蝶】</h3><p>破茧重生，这个层次关注的是编程语言本身，而不再关心产品需求。什么是茧？产品需求就是茧。当你一招胜万招，打遍天下需求之时，你如果还拘泥于需求开发，那就是你限于茧中而不自知。要么就在这个茧里默默地老去，要么就破开茧获得新生。</p><p>还是以那个”字符串剪裁”的老例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:meizz</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>: 2010/12/16</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>str     被正则表达式字符串保护编码的字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return              <span class="type">&#123;string&#125;</span>                </span>被保护处理过后的字符串</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapereg</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="keyword">new</span> regexp(<span class="string">"([.*+?^=!:\x24&#123;&#125;()|[\\]\/\\\\])"</span>, <span class="string">"g"</span>), <span class="string">"\\\x241"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除url字符串中指定的 query</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:meizz</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>:2010/12/16</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>url     url字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>key     被删除的query名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return              <span class="type">&#123;string&#125;</span>                </span>被删除指定 query 后的url字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delurlquery</span>(<span class="params">url, key</span>) </span>&#123;</span><br><span class="line">  key = escapereg(key);</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> regexp(<span class="string">"((\\?)("</span>+ key +<span class="string">"=[^&amp;]*&amp;)+(?!"</span>+ key + <span class="string">"=))|(((\\?|&amp;)"</span>+ key +<span class="string">"=[^&amp;]*)+$)|(&amp;"</span>+ key +<span class="string">"=[^&amp;]*)"</span>, <span class="string">"g"</span>);</span><br><span class="line">  <span class="keyword">return</span> url.replace(reg, <span class="string">"\x241"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用实例</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.xxx.com/?pn=0"</span>; <span class="comment">// 删除指定字符 pn=0</span></span><br><span class="line">delurlquery(str, <span class="string">"pn"</span>);</span><br></pre></td></tr></table></figure><p>这段代码相对于层次4《入微》有什么区别吗？从代码实现上来说没有太大的区别，但是从思路上来说却有着本质的区别：1、不再是就事论事，头疼医头，而是把一类问题抽象理论化，一招破万招；2、有封装的概念，不再是每次从零开始，而是站在半山腰开始爬。</p><p>在web前端研发队伍里也有很大一部分人《入室》层次时就自我感觉良好，直接跨跃到《化蝶》，积累自己的代码库，抽象化问题。但没有基础，缺少强 大  的后劲，即使能够破茧也经受不了风吹雨打。一份不成熟的架构设计对团队开发带来的危害远大于它带来的好处，这种例子在业界屡见不鲜。不要拔苗助长，不要 不  会走就想着跑，夯实基础，水到渠成地成长，厚积薄发，强力地破茧而出。</p><p>进阶之路</p><p>你已经从原始积累，到厚积薄发，到破茧而出之后，你所关注的应该不再是一招一式、一个项目、一个模块，而应该是一种思路，一种理论。你可以做以下 几  个步骤以突破到更高层次：再仔细看几遍html/css/javascript接口帮助文档；选择一门强语言（c++/c#/java等）观察理解这些 语  言的组织结构，语言设计；看看原型链，链式语法编程，泛型，接口编程，dom遥控器等等；仔细阅读成熟的web前端开发框架的设计文档，看他们为什么要 这  样设计。</p><h3 id="【大侠】"><a href="#【大侠】" class="headerlink" title="【大侠】"></a>【大侠】</h3><p>这里所说的大侠，不是大家互相吹捧的”大侠”，而是实至名归的高手。这个级别的人完全有能力写出不差于bindows/jquery/ext/yui/dojo的同等级别规模的前端开发框架。应用成熟的开发框架指导、解决问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库文件 /mz/string/escapereg.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:meizz</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>: 2010/12/16</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>str     被正则表达式字符串保护编码的字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return              <span class="type">&#123;string&#125;</span>                </span>被保护处理过后的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mz.string.escapereg = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="keyword">new</span> regexp(<span class="string">"([.*+?^=!:\x24&#123;&#125;()|[\\]\/\\\\])"</span>, <span class="string">"g"</span>), <span class="string">"\\\x241"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库文件 /mz/url/delquery.js</span></span><br><span class="line"><span class="comment">/// include mz.string.escapereg;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除url字符串中指定的 query</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:meizz</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>:2010/12/16</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>url     url字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>key     被删除的query名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return              <span class="type">&#123;string&#125;</span>                </span>被删除指定 query 后的url字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mz.url.delquery = <span class="function"><span class="keyword">function</span>(<span class="params">url, key</span>) </span>&#123;</span><br><span class="line">  key = mz.string.escapereg(key);</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> regexp(<span class="string">"((\\?)("</span> + key + <span class="string">"=[^&amp;]*&amp;)+(?!"</span> + key + <span class="string">"=))|(((\\?|&amp;)"</span> + key + <span class="string">"=[^&amp;]*)+$)|(&amp;"</span> + key + <span class="string">"=[^&amp;]*)"</span>, <span class="string">"g"</span>);</span><br><span class="line">  <span class="keyword">return</span> url.replace(reg, <span class="string">"\x241"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用实例</span></span><br><span class="line"><span class="comment">/// include mz.url.delquery;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.xxx.com/?pn=0"</span>; <span class="comment">// 删除指定字符 pn=0</span></span><br><span class="line">mz.url.delquery(str, <span class="string">"pn"</span>);</span><br></pre></td></tr></table></figure><p>自成体系，有基础，也有理论高度。知道为什么这样设计，也知道什么样的设计最好。比如这个例子可以有这样的封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库文件 /mz/url/delquery.js</span></span><br><span class="line"><span class="comment">/// include mz.string.escapereg;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除url字符串中指定的 query</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:meizz</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>:2010/12/16</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>url     url字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>key     被删除的query名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return              <span class="type">&#123;string&#125;</span>                </span>被删除指定 query 后的url字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">string.prototype.delquery = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    key = mz.string.escapereg(key);</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> regexp(<span class="string">"((\\?)("</span> + key + <span class="string">"=[^&amp;]*&amp;)+(?!"</span> + key + <span class="string">"=))|(((\\?|&amp;)"</span> + key + <span class="string">"=[^&amp;]*)+$)|(&amp;"</span> + key + <span class="string">"=[^&amp;]*)"</span>, <span class="string">"g"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(reg, <span class="string">"\x241"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用实例</span></span><br><span class="line"><span class="comment">/// include mz.url.delquery;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.xxx.com/?pn=0"</span>; <span class="comment">// 删除指定字符 pn=0</span></span><br><span class="line">str.delquery(<span class="string">"pn"</span>);</span><br></pre></td></tr></table></figure><p>而为什么不采用下面的那种封装呢？经过了《知微》和《化蝶》你就懂了。</p><p>进阶出路</p><p>道法自然，从根上去寻找突破的契机。你可以研读html解析引擎设计与实现，js解析引擎设计与实现，其它语言的代码解析与编译实现等等。<br>或者出些书。低级别的人写的书要么是一大抄，空无一物；要么是害人。</p><h3 id="【宗师】"><a href="#【宗师】" class="headerlink" title="【宗师】"></a>【宗师】</h3><p>这个级别的人已然到了无招胜有招的境界。项目开发中的难题？没有难题！运行平台的差异？从根本上搞定！代码规范、开发模式，早已经被抛在身后。这个级别的人已经不再关注于某个前端开发框架，而是应对具体的环境给出最佳的理论指导。</p><p>这个级别的人所注意的应该是以最合理的系统架构引领着整个团队的进步，在什么样的场景下该用什么样的架构设计。3个、10个、50个、100个人的团队最应该用哪种模式？等你到了宗师级别，你再来回答吧。</p><p>进阶出路</p><p>每一个宗师就是一个高山，就是一个领域里的神，但是你仅满足于在一群比你弱的群体展现你的强大吗？如果还你是止步原地，那总会有人乘着飞机、宇宙飞船从你的头领掠过，高处不胜寒！</p><p>要突破这片领域，那就必须跳出这片领域。要想突破web前端研发的宗师级，那就跳出web前端吧，上面还有web开发。即使你是web前端的宗师， 但没有快速的数据响应，没有高速的网络架构，没有优美的系统支持，你又能如何？所以突破之路就是把目光投到整条web开发的链条中去。</p><h3 id="【飞升】"><a href="#【飞升】" class="headerlink" title="【飞升】"></a>【飞升】</h3><p>其实严格来说，飞升已经不是原领域的范围了。在web研发领域，对于这个层次的有一个很好听的称谓：架构师。当然那些”伪架构师”另当别论。</p><p>一法通，万法通。在其它的技术领域，也可以按照《入门》《登堂》《入室》《入微》《化蝶》《大侠》《宗师》来划分等级；一样也可以按照我这里所写的每个级别的【进阶之路】来快速提升。</p><p>祝贺你再获辉煌！</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><blockquote><p>原文地址已经找不到了,最早2011年3月23日只从CSDN别人转载处找到地址(不确定是不是这个是原文): <a href="http://hszy00232.blog.163.com/blog/static/430227532011119105237357/" target="_blank" rel="noopener">http://hszy00232.blog.163.com/blog/static/430227532011119105237357/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【背景】&quot;&gt;&lt;a href=&quot;#【背景】&quot; class=&quot;headerlink&quot; title=&quot;【背景】&quot;&gt;&lt;/a&gt;【背景】&lt;/h3&gt;&lt;p&gt;如果你是刚进入web前端研发领域，想试试这潭水有多深，看这篇文章吧；&lt;br&gt;如果你是做了两三年web产品前端研发，迷茫找不着提高之路，看这篇文章吧；&lt;br&gt;如果你是四五年的前端开发高手，没有难题能难得住你的寂寞高手，来看这篇文章吧；&lt;/p&gt;
&lt;p&gt;web前端研发工程师，在国内是一个朝阳职业，自07-08年正式有这个职业以来，也不过三四年的时间。这个领域没有学校的正规教育，没有行内成体 系的理论指引，几乎所有从事这个职业的人都是靠自己自学成才。自学成才，一条艰辛的坎坷路，我也是这样一路走来。从2002年开始接触web前端研发至今 已然有了9个年头，如今再回首，期间的走了很多弯路。推已及人，如果能让那些后来者少走些弯路，辛甚辛甚！&lt;/p&gt;
    
    </summary>
    
    
      <category term="能力提升" scheme="https://heiyehk.github.io/blog/categories/%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="能力提升" scheme="https://heiyehk.github.io/blog/tags/%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>你应该知道的前端--缓存</title>
    <link href="https://heiyehk.github.io/blog/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E5%89%8D%E7%AB%AF-%E7%BC%93%E5%AD%98/"/>
    <id>https://heiyehk.github.io/blog/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E5%89%8D%E7%AB%AF-%E7%BC%93%E5%AD%98/</id>
    <published>2020-04-30T05:36:11.000Z</published>
    <updated>2020-04-30T09:27:50.892Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web-缓存"><a href="#web-缓存" class="headerlink" title="web 缓存"></a>web 缓存</h3><p>web 缓存是可以通过自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时,如果本地有以缓存的副本,就可以从本地存储设备而不是原始服务器中提取这个文档。</p><h3 id="1-为什么需要缓存"><a href="#1-为什么需要缓存" class="headerlink" title="1. 为什么需要缓存"></a>1. 为什么需要缓存</h3><ul><li>冗余的数据传输</li></ul><p>有很多客户端访问一个流行的原始服务器页面时,服务器会多次传输同一份文档,每次传送给一个客户端,一些相同的字节会在网络中一遍遍的传输。这些冗余的数据传输会耗尽昂贵的网络带宽。而通过缓存我们可以保留第一家服务器响应的副本,后继请求就可以由缓存的副本来应对</p><ul><li>带宽瓶颈</li></ul><a id="more"></a><p>缓存还可以缓解网络的瓶颈问题。很多网络会为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器。如果客户端从一个快速局域网的缓存中得到一份副本,那么缓存就可以提高性能——尤其是要传输比较大的文件时</p><ul><li>瞬间拥塞</li></ul><p>缓存在破环瞬间拥塞时显得非常中重要。突发事件(比如爆炸性新闻,批量 E-mail 公告, 或者某个名人事件)是很多人几乎同时去访问一个 web 文档时,就会出现瞬间拥塞。由此造成的过多流量峰值可能会使网络和 web 服务器发生灾难性的崩溃</p><ul><li>距离时延</li></ul><p>即使带宽不是问题,距离也可能称为问题。每台网络路由器都会增加因特网流量的时延,即使客户端和服务器之间没有太多路由器,光速本身也会造成时延长。将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米</p><h3 id="2-缓存的命中和未命中"><a href="#2-缓存的命中和未命中" class="headerlink" title="2. 缓存的命中和未命中"></a>2. 缓存的命中和未命中</h3><p>但是缓存无法保存世界上每份文档的副本,这样就会分成两种情况：</p><ul><li>可以用已有的副本为某些到达缓存的请求提供服务,这被称之为缓存命中</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfaa771243b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><ul><li>其他一些到达缓存的请求可能会由于没有副本可用,而被转发给原始服务器,这被称之为缓存未命中</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfab46a3b1c3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><h3 id="3-新鲜度检测规则"><a href="#3-新鲜度检测规则" class="headerlink" title="3. 新鲜度检测规则"></a>3. 新鲜度检测规则</h3><p>HTTP通过缓存将服务器文档的副本保留一段时间。在这段时间里,都认为文档时新鲜的,缓存可以在不联系服务器的情况下,直接提供该文档。我们称之为<strong>强缓存命中</strong>,此时浏览器会返回200状态码(from cache)</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfaa771243b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><p>但一旦以缓存副本停留的时间太长,超过了文档的新鲜度限值,就认为文档过期了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfaa7726cf25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><p>再提供文档之前,缓存要再次与服务器进行再验证,已查看文档是否发生了变化。我们称之为<strong>协商缓存</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfaa770151bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><ul><li>在验证命中: 如果服务器对象没有被修改,服务器会向客户端发送一个小的HTTP 304 Not Modeified响应</li><li>再验证未命中: 如果服务器对象与以缓存副本不同,服务器向客户端送一条普通的带有完整内容的HTTP 200 ok 响应</li><li>对象被删除: 如果服务器对象已经被删除了,服务器就回送一个404 Not Found 响应,缓存也会将其副本删除</li></ul><h3 id="4-强缓存原理"><a href="#4-强缓存原理" class="headerlink" title="4. 强缓存原理"></a>4. 强缓存原理</h3><p>通过特殊的<strong>HTTPCache-Control</strong>首部和<strong>Expries</strong>首部,HTTP让原始服务器向每个文档附加了一个<strong>过期日期</strong>,这些首部说明了在多长时间内可以将这些内容视为新鲜的。</p><p>浏览器第二次发送请求相同资源时,拿出过期时间和当前时间进行比较,如果在过期日期之前,则强缓存命中,如果缓存文档过期,缓存就必须与服务器进行核对,询问文档是否过期,如果被修改过,就要获取一份新鲜(带有新的过期日期)的副本</p><h4 id="4-1-强缓存首部"><a href="#4-1-强缓存首部" class="headerlink" title="4.1 强缓存首部"></a>4.1 强缓存首部</h4><ul><li><strong>Cache-Control: max-age:</strong></li></ul><p><strong>max-age</strong>值定义了文档的最大使用期——从第一次生成文档到文档不再新鲜,无法使用为止,最大的合法生存时间(以秒为单位)</p><ul><li><strong>Expires:</strong></li></ul><p>指定一个绝对的过期日期,如果过期日期已经过了,就说明文档不在新鲜了,不过由于我们可以去更改客户端的时间,因此可以更改缓存命中的结果。因此我们优先使用<strong>Cache-Control</strong><br><strong>Cache-Control</strong>指令：</p><ul><li><strong>no-cache和no-store:</strong></li></ul><p><strong>no-cache</strong>表示必须先与服务器确认返回的响应是否发生了变化,然后才能使用响应来满足后续对同意网址的请求。因此如果存在合适的验证令牌(<strong>ETag</strong>),<strong>no-cache</strong>会发起往返通信来验证缓存的响应,但如果资源未发生变化,则可避免下载<br><strong>no-store</strong>表示直接禁止浏览器以及所有中间缓存存储任何版本的返回响应,例如,包含个人隐私数据或银行业务数据的响应。每次用户请求该资产时,都会向服务器发送请求,并下载完整的响应</p><ul><li><strong>public与private:</strong></li></ul><p><strong>public</strong>出现再响应首部,则即使他有关联的HTTP验证,甚至响应状态代码代码通常无法缓存,也可以缓存响应。大多数情况下,<strong>public</strong>不是必须的,因为明确的缓存信息(例如<strong>max-age</strong>)已表示响应是可以缓存<br>相比之下,浏览器可以缓存private响应。不过这些响应通常只为单个用户缓存,因此不允许任何中间缓存对其进行缓存,例如,用户的浏览器可以缓存包含用户私人信息的HTML网页,但CDN不能缓存</p><ul><li><strong>max-age:</strong></li></ul><p>指令指定从请求的时间开始,允许获取的响应被重用的最长时间。例如<strong>max-age=60</strong>表示可以在接下来的60s缓存和重用响应</p><ul><li><strong>must-revalidate:</strong></li></ul><p><strong>must-revalidate</strong>告诉缓存,再事先没有跟原始服务器进行再验证的情况下,不能提供这个对象的陈旧副本,缓存仍然可以随意提供新鲜的副本。如果在缓存进行<strong>must-revalidate</strong>新鲜度检查时,原始服务器不可用,缓存就必须返回一条504错误</p><p>最佳Cache-Control策略:</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfab954de5e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><h3 id="5-协商缓存原理"><a href="#5-协商缓存原理" class="headerlink" title="5. 协商缓存原理"></a>5. 协商缓存原理</h3><p>仅仅是以缓存过期了并不意味着他和原始服务器目前处于活跃状态的文档有实际的区别,这只是意味着到了要进行核对的时间了,这种情况被称为<strong>协商缓存</strong>,说明缓存需要询问原始服务器是否发生变化</p><ul><li>如果再验证显示内容发生了变化,缓存会获取一份新的文档副本,并将其存储在旧文档的位置上,然后将文档发送给客户端。</li><li>如果再验证内容没有发生变化,缓存只需要获取新的首部,包括一个新的过期日期,并对缓存中的首部进行更新,并对缓存中的首部进行更新就行了</li></ul><h4 id="5-1-用条件方法进行再验证"><a href="#5-1-用条件方法进行再验证" class="headerlink" title="5.1 用条件方法进行再验证"></a>5.1 用条件方法进行再验证</h4><p>HTTP的条件方法可以高效的实现再验证。HTTP允许缓存向原始服务器发送一个条件GET,请求服务器只有在文档与缓存中现有的副本不同时,才回送对象主体,对于缓存在验证来说最有用的2个首部时</p><ul><li><code>If-Modified-Since: &lt;date&gt;</code>  </li></ul><p>如果从指定日期之后,文档被修改了,就执行请求的方法。可以与<strong>Last-Modfied</strong>服务器响应首部配合使用,只有在内容修改后与已缓存版本有所不同的时候才去获取内容</p><ul><li><code>If-None-Match:&lt;tags&gt;:</code></li></ul><p>服务器可以为文档提供特殊的标签(ETag),而不是将其与最近修改日期向匹配,这些标签就像序列号一样。如果已缓存标签与服务器文档中的标签有所不同,<strong>If-None-Match</strong>首部就会执行所请求的方法</p><h4 id="5-2-If-Modified-Since-Last-Modified"><a href="#5-2-If-Modified-Since-Last-Modified" class="headerlink" title="5.2 If-Modified-Since:  / Last-Modified####"></a>5.2 If-Modified-Since:  / Last-Modified####</h4><p>具体流程如下:</p><ol><li>客户端第一次向服务器发起请求,服务器将最后的修改日期(<strong>Last-Modified</strong>)附加到所提供的文档上去</li><li>当再一次请求资源时间,如果没有命中强缓存,在执行在验证时,会包含一个<strong>If-Modifed-Since</strong>首部,其中携带有最后修改已缓存副本的日期: <code>If-Modified-Since: &lt;cached last-modified data&gt;</code></li><li>如果内容被修改了,服务器回送新的文档,返回200状态码和最新的修改日期</li><li>如果内容没有被修改,会返回一个<strong>304 Not Modified</strong>响应</li></ol><h4 id="5-3-If-None-Match-ETag"><a href="#5-3-If-None-Match-ETag" class="headerlink" title="5.3 If-None-Match / ETag"></a>5.3 If-None-Match / ETag</h4><p>有些情况下仅使用最后修改日期进行再验证是不够的</p><ul><li>有些文档有可能会被周期性的重写(比如: 从一个后台进程中写入),但实际上包含的数据常常是一样分,尽管内容没有变化,但修改日期会发生变化</li><li>有些文档可能被修改了,但所做修改并不重要.不需要让世界范围内的缓存都重装数据(比如填写注释)</li><li>有些服务器无法准确判定其页面的最后修改日期</li><li>有些服务器提供的文档会在毫秒间隙发生变化(比如,实时监视器),对这些服务器来说,以一秒为粒度的修改日期可能就不够用了</li></ul><p>因此HTTP允许用户对被称为实体标签的(<strong>ETag</strong>)的版本标识符进行比较。实体标签是附加到文档上的任意标签(引用字符串),服务器生成并返回的随机令牌通常是文件内容的哈希值或其他指纹。客户端不需要指纹是如何生成的，只需在下一次请求时将其发送至服务器。如果指纹仍然相同，则表示资源未发生变化，您就可以跳过下载。</p><p>在上例中，客户端自动在<strong>“If-None-Match” HTTP 请求标头内提供 ETag 令牌</strong>。服务器根据当前资源核对令牌。如果它未发生变化，服务器将返回304 Not Modified响应，告知浏览器缓存中的响应未发生变化，可以再延用 120 秒。请注意，您不必再次下载响应，这节约了时间和带宽。</p><p><strong>更新和废弃响应</strong></p><p>浏览器发出的所有HTTP请求会首先路由到浏览器缓存,已确认是否缓存可用于请求的有效响应。如果有匹配的响应,则从缓存中读取响应,这样就避免了网路延迟和传送产生的流量费用</p><p>*<em>不过如果我们向更新或废弃缓存的响应,该怎么办, *</em>例如我们有一个css样式表缓存长达24小时,但是我们需要立即更新他,我们如何通知已过时的CSS缓存副本的所有访问者更新其缓存。在不更改资源网址的情况下,是做不到的。</p><p>所以,如何才能实现客户端缓存和快速更新,你可以在资源内容发生变化时,更改它的网址,强制用户下载新响应。通常情况下,可以通过再文件名中嵌入文件的指纹或版本号来实现</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfaaf3b76754?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><ul><li>HTML被标记为<strong>no-cache</strong>,这意味着浏览器再每次请求时都始终重新验证文档,并在内容变化时获取最新版本。此外再HTML标记内,再CSS和javascript中嵌入指纹,如果这些文件的内容发生变化,网页的HTML也会随之改变,并会下载HTML响应的新副本</li><li>允许浏览器和中间缓存(例如CDN)缓存CSS,并将CSS设置为1年后到期,因为再文件名中嵌入了文件的指纹,CSS更新时网址也会随之变化</li><li>JavaScript同样设置为1年后到期,但标记为<strong>private</strong>,这或许是因为它包含的某些用户私人数据是CDN不应缓存的。</li><li>图像缓存时不包含版本或唯一指纹,并设置为一天后到期</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="noopener">HTTP缓存</a></li><li><a href="https://www.cnblogs.com/lyzg/p/5125934.html#_label4" target="_blank" rel="noopener">浏览器缓存知识小结及应用</a></li><li><a href="http://www.yzmspirit.com/2017/03/28/http%E7%88%86%E7%82%B8%E9%87%8D%E7%82%B9%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">http爆炸重点学习——缓存</a></li></ul><blockquote><p>作者：SGAMER-rain<br>链接：<a href="https://juejin.im/post/5ae081aaf265da0b767d263a" target="_blank" rel="noopener">https://juejin.im/post/5ae081aaf265da0b767d263a</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;web-缓存&quot;&gt;&lt;a href=&quot;#web-缓存&quot; class=&quot;headerlink&quot; title=&quot;web 缓存&quot;&gt;&lt;/a&gt;web 缓存&lt;/h3&gt;&lt;p&gt;web 缓存是可以通过自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时,如果本地有以缓存的副本,就可以从本地存储设备而不是原始服务器中提取这个文档。&lt;/p&gt;
&lt;h3 id=&quot;1-为什么需要缓存&quot;&gt;&lt;a href=&quot;#1-为什么需要缓存&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要缓存&quot;&gt;&lt;/a&gt;1. 为什么需要缓存&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;冗余的数据传输&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有很多客户端访问一个流行的原始服务器页面时,服务器会多次传输同一份文档,每次传送给一个客户端,一些相同的字节会在网络中一遍遍的传输。这些冗余的数据传输会耗尽昂贵的网络带宽。而通过缓存我们可以保留第一家服务器响应的副本,后继请求就可以由缓存的副本来应对&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带宽瓶颈&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="缓存" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="缓存" scheme="https://heiyehk.github.io/blog/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>从输入url到显示网页发生了什么</title>
    <link href="https://heiyehk.github.io/blog/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://heiyehk.github.io/blog/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2020-04-30T05:29:44.000Z</published>
    <updated>2020-04-30T09:27:42.758Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在浏览器中输入url到显示网页主要包含两个部分： <strong>网络通信和页面渲染</strong></p><p>互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走</p><a id="more"></a><h3 id="1-浏览器的地址栏输入URL并按下回车"><a href="#1-浏览器的地址栏输入URL并按下回车" class="headerlink" title="1.浏览器的地址栏输入URL并按下回车"></a>1.浏览器的地址栏输入URL并按下回车</h3><p>我们常见的RUL是这样的: <code>www.baidu.com</code>,域名通常由3部分组成：<strong>协议 域名 端口号</strong></p><ol><li>协议：主要是HTTP协议，HTTPS协议，FTP协议，FILe协议</li><li>域名：url中间部分为域名或者IP</li><li>端口号：通常默认都是隐藏的 http默认端口号为80 https默认端口号为443</li></ol><p>涉及知识点： 跨域<br>在前端进行数据请求时，由于浏览器的同源策略，协议，域名，端口号有一个不同会存在跨域请求，需要进行跨域处理，相关的跨域方法点击<a href="https://user-gold-cdn.xitu.io/2018/11/19/1672a68aae05f7f6" target="_blank" rel="noopener">https://user-gold-cdn.xitu.io/2018/11/19/1672a68aae05f7f6</a></p><h3 id="2-DNS域名解析"><a href="#2-DNS域名解析" class="headerlink" title="2.DNS域名解析"></a>2.DNS域名解析</h3><p>互联网上每一台计算机的唯一标识是它的<strong>IP地址</strong>，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析，即实现了网址到IP地址的转换</p><p>解析过程<br>DNS解析是一个递归查询的过程。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a5a206a7e309" alt="avatar"></p><p>上述图片是查找<code>www.google.com</code>的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。</p><p>从上述过程中，可以看出网址的解析是一个从右向左的过程: <code>com</code> -&gt; <code>google.com</code> -&gt; <code>www.google.com</code>。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是<code>www.google.com</code>.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: <code>.</code> -&gt; <code>.com</code> -&gt; <code>google.com</code>. -&gt; <code>www.google.com</code>.。</p><h4 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h4><p>DNS缓存和DNS负载均衡</p><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p><ol><li>在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。</li><li>系统缓存主要存在/etc/hosts(Linux系统)中:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a566f8cebd65" alt="avatar"></p><p>DNS负载均衡</p><p>真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向</p><h3 id="3-建立TCP连接"><a href="#3-建立TCP连接" class="headerlink" title="3.建立TCP连接"></a>3.建立TCP连接</h3><p>在通过DNS域名解析后，获取到了服务器的IP地址，在获取到IP地址后，便会开始建立一次连接，这是由TCP协议完成的，主要通过三次握手进行连接。</p><ol><li>第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；</li><li>第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 这里需要了解下<strong>ACK，SYN</strong>的意义</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a5a206a7e309" alt="avatar"><br>完成TCP连接后开使向服务器进行请求</p><h3 id="4-向服务器发送请求"><a href="#4-向服务器发送请求" class="headerlink" title="4.向服务器发送请求"></a>4.向服务器发送请求</h3><p>完整的HTTP请求包含<strong>请求起始行、请求头部、请求主体</strong>三部分。<br><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a5d02bc0d8fd" alt="avatar"></p><h3 id="5-服务器接受响应"><a href="#5-服务器接受响应" class="headerlink" title="5.服务器接受响应"></a>5.服务器接受响应</h3><p>服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。<br>状态码主要包括以下部分:</p><p>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。<br><strong>响应头</strong>主要由Cache-Control、 Connection、Date、Pragma等组成。<br><strong>响应体</strong>为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成。</p><h3 id="6-页面渲染"><a href="#6-页面渲染" class="headerlink" title="6.页面渲染"></a>6.页面渲染</h3><p> 如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。  在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：<strong>Reflow</strong>和<strong>Repaint</strong>。<br><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a637a7508bca" alt="avatar"></p><ol><li>Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。  </li><li>Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。</li></ol><p>所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。</p><h3 id="7-关闭TCP连接或继续保持连接"><a href="#7-关闭TCP连接或继续保持连接" class="headerlink" title="7.关闭TCP连接或继续保持连接"></a>7.关闭TCP连接或继续保持连接</h3><p>通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a64fbd06d50d" alt="avatar"></p><ol><li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li><li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li><li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li><li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li></ol><blockquote><p>作者：rosenWang<br>链接：<a href="https://juejin.im/post/5bf23afa6fb9a049be5d1494" target="_blank" rel="noopener">https://juejin.im/post/5bf23afa6fb9a049be5d1494</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在浏览器中输入url到显示网页主要包含两个部分： &lt;strong&gt;网络通信和页面渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="DNS" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/DNS/"/>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="DNS" scheme="https://heiyehk.github.io/blog/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>11道浏览器原理面试题</title>
    <link href="https://heiyehk.github.io/blog/11%E9%81%93%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://heiyehk.github.io/blog/11%E9%81%93%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-30T04:53:59.000Z</published>
    <updated>2020-04-30T09:27:28.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见的浏览器内核有哪些"><a href="#常见的浏览器内核有哪些" class="headerlink" title="常见的浏览器内核有哪些?"></a>常见的浏览器内核有哪些?</h3><table><thead><tr><th>浏览器/RunTime</th><th>内核（渲染引擎）</th><th>JavaScript 引擎</th></tr></thead><tbody><tr><td>Chrome</td><td>Blink（28~）Webkit（Chrome 27）</td><td>V8</td></tr><tr><td>FireFox</td><td>Gecko</td><td>SpiderMonkey</td></tr><tr><td>Safari</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>Edge</td><td>EdgeHTML</td><td>Chakra(for JavaScript)</td></tr><tr><td>IE</td><td>Trident</td><td>Chakra(for JScript)</td></tr><tr><td>PhantomJS</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>Node.js</td><td>-</td><td>V8</td></tr></tbody></table><a id="more"></a><h3 id="浏览器的主要组成部分是什么？"><a href="#浏览器的主要组成部分是什么？" class="headerlink" title="浏览器的主要组成部分是什么？"></a>浏览器的主要组成部分是什么？</h3><ol><li>用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li><li>浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</li><li>呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li>网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li><li>用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li><li>JavaScript 解释器。用于解析和执行 JavaScript 代码。</li><li>数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li></ol><p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p><h3 id="浏览器是如何渲染UI的？"><a href="#浏览器是如何渲染UI的？" class="headerlink" title="浏览器是如何渲染UI的？"></a>浏览器是如何渲染UI的？</h3><ol><li>浏览器获取HTML文件，然后对文件进行解析，形成<code>DOM Tree</code></li><li>与此同时，进行<code>CSS</code>解析，生成<code>Style Rules</code></li><li>接着将<code>DOM Tree</code>与<code>Style Rules</code>合成为 <code>Render Tree</code></li><li>接着进入布局<code>（Layout）</code>阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标</li><li>随后调用<code>GPU</code>进行绘制<code>（Paint）</code>，遍历<code>Render Tree</code>的节点，并将元素呈现出来</li></ol><h3 id="浏览器如何解析css选择器？"><a href="#浏览器如何解析css选择器？" class="headerlink" title="浏览器如何解析css选择器？"></a>浏览器如何解析css选择器？</h3><p>浏览器会『从右往左』解析CSS选择器。<br>我们知道<code>DOM Tree</code>与<code>Style Rules</code>合成为 <code>Render Tree</code>，实际上是需要将<code>Style Rules</code>附着到DOM Tree上，因此需要根据选择器提供的信息对<code>DOM Tree</code>进行遍历，才能将样式附着到对应的DOM元素上。<br>以下这段css为例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mod-nav</span> <span class="selector-tag">h3</span> <span class="selector-tag">span</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>;&#125;</span><br></pre></td></tr></table></figure><p>若从左向右的匹配，过程是：  </p><ol><li>从 <code>.mod-nav</code> 开始，遍历子节点 <code>header</code> 和子节点 <code>div</code></li><li>然后各自向子节点遍历。在右侧 <code>div</code> 的分支中</li><li>最后遍历到叶子节点 <code>a</code> ，发现不符合规则，需要回溯到 <code>ul</code> 节点，再遍历下一个 <code>li-a</code>，一颗<code>DOM</code>树的节点动不动上千，这种效率很低。</li></ol><p>如果从右至左的匹配：  </p><ol><li>先找到所有的最右节点 <code>span</code>，对于每一个 <code>span</code>，向上寻找节点 <code>h3</code></li><li>由 <code>h3</code>再向上寻找 <code>class=mod-nav</code> 的节点</li><li>最后找到根元素 <code>html</code> 则结束这个分支的遍历。</li></ol><p>后者匹配性能更好，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）；而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p><h3 id="DOM-Tree是如何构建的？"><a href="#DOM-Tree是如何构建的？" class="headerlink" title="DOM Tree是如何构建的？"></a>DOM Tree是如何构建的？</h3><ol><li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串</li><li>生成<code>Tokens</code>: 之后开始parser，浏览器会将HTML字符串解析成<code>Tokens</code></li><li>构建<code>Nodes</code>: 对Node添加特定的属性，通过指针确定 <code>Node</code> 的父、子、兄弟关系和所属 <code>treeScope</code></li><li>生成<code>DOM Tree</code>: 通过<code>node</code>包含的指针确定的关系构建出<code>DOM Tree</code></li></ol><h3 id="浏览器重绘与重排的区别？"><a href="#浏览器重绘与重排的区别？" class="headerlink" title="浏览器重绘与重排的区别？"></a>浏览器重绘与重排的区别？</h3><ul><li>重排: 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素</li><li>重绘: 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变</li></ul><p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p><p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p><p>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</p><h3 id="如何触发重排和重绘？"><a href="#如何触发重排和重绘？" class="headerlink" title="如何触发重排和重绘？"></a>如何触发重排和重绘？</h3><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点</li><li>通过<code>display: none</code>隐藏一个DOM节点-触发重排和重绘</li><li>通过<code>visibility: hidden</code>隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的<code>DOM</code>节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><h3 id="如何避免重绘或者重排？"><a href="#如何避免重绘或者重排？" class="headerlink" title="如何避免重绘或者重排？"></a>如何避免重绘或者重排？</h3><h4 id="集中改变样式"><a href="#集中改变样式" class="headerlink" title="集中改变样式"></a>集中改变样式</h4><p>我们往往通过改变class的方式来集中改变样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否是黑色系样式</span></span><br><span class="line"><span class="keyword">const</span> theme = isDark ? <span class="string">'dark'</span> : <span class="string">'light'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据判断来设置不同的class</span></span><br><span class="line">ele.setAttribute(<span class="string">'className'</span>, theme)</span><br></pre></td></tr></table></figure><h4 id="使用DocumentFragment"><a href="#使用DocumentFragment" class="headerlink" title="使用DocumentFragment"></a>使用DocumentFragment</h4><p>我们可以通过<code>createDocumentFragment</code>创建一个游离于DOM树之外的节点，然后在此节点上批量操作，最后插入DOM树中，因此只触发一次重排</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">  node.innerHTML = i;</span><br><span class="line">  fragment.appendChild(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(fragment);</span><br></pre></td></tr></table></figure><h4 id="提升为合成层"><a href="#提升为合成层" class="headerlink" title="提升为合成层"></a>提升为合成层</h4><p>将元素提升为合成层有以下优点：</p><ul><li>合成层的位图，会交由 <code>GPU</code> 合成，比 <code>CPU</code> 处理要快</li><li>当需要 <code>repaint</code> 时，只需要 <code>repaint</code> 本身，不会影响到其他的层</li><li>对于 <code>transform</code> 和 <code>opacity</code> 效果，不会触发 <code>layout</code> 和 <code>paint</code></li></ul><p>提升合成层的最好方式是使用 <code>CSS</code> 的 <code>will-change</code> 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于合成层的详解请移步<a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noopener">无线性能优化：Composite</a></p></blockquote><h3 id="前端如何实现即时通讯？"><a href="#前端如何实现即时通讯？" class="headerlink" title="前端如何实现即时通讯？"></a>前端如何实现即时通讯？</h3><h4 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h4><p>短轮询的原理很简单，每隔一段时间客户端就发出一个请求，去获取服务器最新的数据，一定程度上模拟实现了即时通讯。</p><ul><li>优点：兼容性强，实现非常简单</li><li>缺点：延迟性高，非常消耗请求资源，影响性能</li></ul><h4 id="comet"><a href="#comet" class="headerlink" title="comet"></a>comet</h4><p>comet有两种主要实现手段，一种是基于 <code>AJAX</code> 的长轮询<code>（long-polling）</code>方式，另一种是基于 <code>Iframe</code> 及 <code>htmlfile</code> 的<code>流（streaming）</code>方式，通常被叫做<code>长连接</code>。  </p><blockquote><p>具体两种手段的操作方法请移步<a href="http://www.52im.net/thread-334-1-1.html" target="_blank" rel="noopener">Comet技术详解：基于HTTP长连接的Web端实时通信技术</a></p></blockquote><p>长轮询优缺点：</p><ul><li>优点：兼容性好，资源浪费较小</li><li>缺点：服务器<code>hold</code>连接会消耗资源，返回数据顺序无保证，难于管理维护</li></ul><p>长连接优缺点：</p><ul><li>优点：兼容性好，消息即时到达，不发无用请求</li><li>缺点：服务器维护长连接消耗资源<h4 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h4><blockquote><p>使用指南请看<a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">Server-Sent Events 教程</a></p></blockquote></li></ul><p>SSE（Server-Sent Event，服务端推送事件）是一种允许服务端向客户端推送新数据的HTML5技术。  </p><ul><li>优点：基于HTTP而生，因此不需要太多改造就能使用，使用方便，而websocket非常复杂，必须借助成熟的库或框架</li><li>缺点：基于文本传输效率没有<code>websocket</code>高，不是严格的双向通信，客户端向服务端发送请求无法复用之前的连接，需要重新发出独立的请求</li></ul><h4 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h4><p>使用指南请看<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a></p><p>Websocket是一个全新的、独立的协议，基于<code>TCP协议</code>，与h<code>ttp协议</code>兼容、却不会融入<code>http协议</code>，仅仅作为<code>html5</code>的一部分，其作用就是在服务器和客户端之间建立实时的双向通信。  </p><ul><li>优点：真正意义上的实时双向通信，性能好，低延迟</li><li>缺点：独立与http的协议，因此需要额外的项目改造，使用复杂度高，必须引入成熟的库，无法兼容低版本浏览器</li></ul><h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><blockquote><p>后面性能优化部分会用到，先做了解</p></blockquote><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">Web Worker教程</a></p></blockquote><h4 id="Service-workers"><a href="#Service-workers" class="headerlink" title="Service workers"></a>Service workers</h4><blockquote><p>后面性能优化部分会用到，先做了解</p></blockquote><p>Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理，创建有效的离线体验。</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service workers教程</a></p></blockquote><h4 id="什么是浏览器同源策略？"><a href="#什么是浏览器同源策略？" class="headerlink" title="什么是浏览器同源策略？"></a>什么是浏览器同源策略？</h4><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。<br>同源是指<code>&quot;协议+域名+端口&quot;</code>三者相同，即便两个不同的域名指向同一个ip地址，也非同源。<br>下表给出了相对<a href="http://store.company.com/dir/page.html同源检测的示例" target="_blank" rel="noopener">http://store.company.com/dir/page.html同源检测的示例</a>:</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/24/16d610123996dc1e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://store.company.com/dir/page.html同源检测的示例"></p><p>浏览器中的大部分内容都是受同源策略限制的，但是以下三个标签可以不受限制：</p><ul><li>&lt;img src=XXX&gt;</li><li>&lt;link href=XXX&gt;</li><li>&lt;script src=XXX&gt;</li></ul><h3 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h3><p>跨域是个比较古老的命题了，历史上跨域的实现手段有很多，我们现在主要介绍三种比较主流的跨域方案，其余的方案我们就不深入讨论了，因为使用场景很少，也没必要记这么多奇技淫巧。</p><h4 id="最经典的跨域方案jsonp"><a href="#最经典的跨域方案jsonp" class="headerlink" title="最经典的跨域方案jsonp"></a>最经典的跨域方案jsonp</h4><p>jsonp本质上是一个<code>Hack</code>，它利用<code>&lt;script&gt;</code>标签不受同源策略限制的<code>特性进行跨域</code>操作。<br>jsonp优点：</p><ul><li>实现简单</li><li>兼容性非常好</li></ul><p>jsonp的缺点：</p><ul><li>只支持get请求（因为<code>&lt;script&gt;</code>标签只能get）</li><li>有安全性问题，容易遭受xss攻击</li><li>需要服务端配合jsonp进行一定程度的改造</li></ul><p>jsonp的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSONP</span>(<span class="params">&#123;  </span></span></span><br><span class="line"><span class="function"><span class="params">  url,</span></span></span><br><span class="line"><span class="function"><span class="params">  params,</span></span></span><br><span class="line"><span class="function"><span class="params">  callbackKey,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在参数里制定 callback 的名字</span></span><br><span class="line">  params = params || &#123;&#125;</span><br><span class="line">  params[callbackKey] = <span class="string">'jsonpCallback'</span></span><br><span class="line">    <span class="comment">// 预留 callback</span></span><br><span class="line">  <span class="built_in">window</span>.jsonpCallback = callback</span><br><span class="line">    <span class="comment">// 拼接参数字符串</span></span><br><span class="line">  <span class="keyword">const</span> paramKeys = <span class="built_in">Object</span>.keys(params)</span><br><span class="line">  <span class="keyword">const</span> paramString = paramKeys</span><br><span class="line">    .map(<span class="function"><span class="params">key</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>)</span><br><span class="line">    .join(<span class="string">'&amp;'</span>)</span><br><span class="line">    <span class="comment">// 插入 DOM 元素</span></span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.setAttribute(<span class="string">'src'</span>, <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;paramString&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSONP(&#123;  </span><br><span class="line">  url: <span class="string">'http://s.weibo.com/ajax/jsonp/suggestion'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    key: <span class="string">'test'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  callbackKey: <span class="string">'_cb'</span>,</span><br><span class="line">  callback(result) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="最流行的跨域方案cors"><a href="#最流行的跨域方案cors" class="headerlink" title="最流行的跨域方案cors"></a>最流行的跨域方案cors</h4><p><code>cors</code>是目前主流的跨域解决方案，跨域资源共享(CORS) 是一种机制，它使用额外的 <code>HTTP 头</code>来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个<code>跨域 HTTP</code> 请求。 </p><p>如果你用<code>express</code>，可以这样在后端设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CORS middleware</span></span><br><span class="line"><span class="keyword">var</span> allowCrossDomain = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://example.com'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET,PUT,POST,DELETE'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type'</span>);</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">app.configure(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    app.use(express.bodyParser());</span><br><span class="line">    app.use(express.cookieParser());</span><br><span class="line">    app.use(express.session(&#123; <span class="attr">secret</span>: <span class="string">'cool beans'</span> &#125;));</span><br><span class="line">    app.use(express.methodOverride());</span><br><span class="line">    app.use(allowCrossDomain);</span><br><span class="line">    app.use(app.router);</span><br><span class="line">    app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在生产环境中建议用成熟的开源中间件解决问题。</p><h3 id="最方便的跨域方案Nginx"><a href="#最方便的跨域方案Nginx" class="headerlink" title="最方便的跨域方案Nginx"></a>最方便的跨域方案Nginx</h3><p>nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</p><p>现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/24/16d610123c354a18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="nginx的反向代理"></p><p>反向代理的原理很简单，即所有客户端的请求都必须先经过nginx的处理，nginx作为代理服务器再讲请求转发给node或者java服务，这样就规避了同源策略。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进程, 可更具cpu数量调整</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment">#连接数</span></span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#连接超时时间，服务器会在这个时间过后关闭连接。</span></span><br><span class="line">    keepalive_timeout  10;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gizp压缩</span></span><br><span class="line">    gzip  on;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 直接请求nginx也是会报跨域错误的这里设置允许跨域</span></span><br><span class="line">    <span class="comment"># 如果代理地址已经允许跨域则不需要这些, 否则报错(虽然这样nginx跨域就没意义了)</span></span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">    add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># srever模块配置是http模块中的一个子模块，用来定义一个虚拟访问主机</span></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根路径指到index.html</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># localhost/api 的请求会被转发到192.168.0.103:8080</span></span><br><span class="line">        location /api &#123;</span><br><span class="line">            rewrite ^/b/(.*)$ /<span class="variable">$1</span> <span class="built_in">break</span>; <span class="comment"># 去除本地接口/api前缀, 否则会出现404</span></span><br><span class="line">            proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            proxy_pass http://192.168.0.103:8080; <span class="comment"># 转发地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 重定向错误页面到/50x.html</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它跨域方案"><a href="#其它跨域方案" class="headerlink" title="其它跨域方案"></a>其它跨域方案</h3><ol><li><code>HTML5 XMLHttpRequest</code> 有一个<code>API</code>，<code>postMessage()</code>方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</li><li><code>WebSocket</code> 是一种<code>双向通信协议</code>，在建立连接之后，<code>WebSocket</code> 的 <code>server</code> 与 <code>client</code> 都能<code>主动向对方发送或接收数据</code>，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的<code>双向通信就与 HTTP 无关</code>了，因此可以跨域。</li><li><code>window.name</code> + <code>iframe：window.name</code>属性值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 <code>name</code> 值，我们可以利用这个特点进行跨域。</li><li><code>location.hash</code> + <code>iframe：a.html</code>欲与<code>c.html</code>跨域相互通信，通过中间页<code>b.html</code>来实现。 三个页面，不同域之间利用<code>iframe</code>的<code>location.hash</code>传值，相同域之间直接<code>js</code>访问来通信。</li><li><code>document.domain + iframe</code>： 该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式，我们只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域，两个页面都通过js强制设置<code>document.domain</code>为基础主域，就实现了同域。</li></ol><blockquote><p>其余方案来源于<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1#heading-19" target="_blank" rel="noopener">九种跨域方式</a></p></blockquote><p>参考文章:</p><ul><li><a href="https://segmentfault.com/q/1010000000713509" target="_blank" rel="noopener">为什么 CSS 选择器解析的时候是从右往左？</a></li></ul><blockquote><p>作者：寻找海蓝96<br>链接：<a href="https://juejin.im/post/5d89798d6fb9a06b102769b1" target="_blank" rel="noopener">https://juejin.im/post/5d89798d6fb9a06b102769b1</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常见的浏览器内核有哪些&quot;&gt;&lt;a href=&quot;#常见的浏览器内核有哪些&quot; class=&quot;headerlink&quot; title=&quot;常见的浏览器内核有哪些?&quot;&gt;&lt;/a&gt;常见的浏览器内核有哪些?&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;浏览器/RunTime&lt;/th&gt;
&lt;th&gt;内核（渲染引擎）&lt;/th&gt;
&lt;th&gt;JavaScript 引擎&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Chrome&lt;/td&gt;
&lt;td&gt;Blink（28~）Webkit（Chrome 27）&lt;/td&gt;
&lt;td&gt;V8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FireFox&lt;/td&gt;
&lt;td&gt;Gecko&lt;/td&gt;
&lt;td&gt;SpiderMonkey&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Safari&lt;/td&gt;
&lt;td&gt;Webkit&lt;/td&gt;
&lt;td&gt;JavaScriptCore&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge&lt;/td&gt;
&lt;td&gt;EdgeHTML&lt;/td&gt;
&lt;td&gt;Chakra(for JavaScript)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IE&lt;/td&gt;
&lt;td&gt;Trident&lt;/td&gt;
&lt;td&gt;Chakra(for JScript)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PhantomJS&lt;/td&gt;
&lt;td&gt;Webkit&lt;/td&gt;
&lt;td&gt;JavaScriptCore&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Node.js&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;V8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="面试" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="面试" scheme="https://heiyehk.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的回流与重绘 (Reflow &amp; Repaint)</title>
    <link href="https://heiyehk.github.io/blog/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98-Reflow-Repaint/"/>
    <id>https://heiyehk.github.io/blog/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98-Reflow-Repaint/</id>
    <published>2020-04-30T04:40:46.000Z</published>
    <updated>2020-04-30T09:27:47.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>在讨论回流与重绘之前，我们要知道：</p><ol><li>浏览器使用流式布局模型 (Flow Based Layout)。</li><li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>Render Tree</code>。</li><li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li><li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一。</li></ol><p>一句话：回流必将引起重绘，重绘不一定会引起回流。</p><a id="more"></a><h3 id="回流-Reflow"><a href="#回流-Reflow" class="headerlink" title="回流 (Reflow)"></a>回流 (Reflow)</h3><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。<br>会导致回流的操作：</p><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><p>一些常用且会导致回流的属性和方法：</p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li><li><code>scrollTo()</code></li></ul><h3 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘 (Repaint)"></a>重绘 (Repaint)</h3><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p><strong>回流比重绘的代价要更高。</strong><br>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。<br>现代浏览器会对频繁的回流或重绘操作进行优化：<br>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。<br>当你访问以下属性或方法时，浏览器会立刻清空队列：</p><p>getComputedStyle()<br>getBoundingClientRect()</p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>width</code>、<code>height</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li></ul><p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p><h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><ul><li>避免使用<code>table</code>布局。</li><li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li><li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li></ul><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul><li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li><li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM</code>操作，最后再把它添加到文档中。</li><li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><blockquote><p>作者：腰花<br>链接：<a href="https://juejin.im/post/5a9923e9518825558251c96a" target="_blank" rel="noopener">https://juejin.im/post/5a9923e9518825558251c96a</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;在讨论回流与重绘之前，我们要知道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器使用流式布局模型 (Flow Based Layout)。&lt;/li&gt;
&lt;li&gt;浏览器会把&lt;code&gt;HTML&lt;/code&gt;解析成&lt;code&gt;DOM&lt;/code&gt;，把&lt;code&gt;CSS&lt;/code&gt;解析成&lt;code&gt;CSSOM&lt;/code&gt;，&lt;code&gt;DOM&lt;/code&gt;和&lt;code&gt;CSSOM&lt;/code&gt;合并就产生了&lt;code&gt;Render Tree&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;有了&lt;code&gt;RenderTree&lt;/code&gt;，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。&lt;/li&gt;
&lt;li&gt;由于浏览器使用流式布局，对&lt;code&gt;Render Tree&lt;/code&gt;的计算通常只需要遍历一次就可以完成，但&lt;code&gt;table&lt;/code&gt;及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用&lt;code&gt;table&lt;/code&gt;布局的原因之一。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一句话：回流必将引起重绘，重绘不一定会引起回流。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="回流" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%9E%E6%B5%81/"/>
    
      <category term="重绘" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%9E%E6%B5%81/%E9%87%8D%E7%BB%98/"/>
    
      <category term="Reflow" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%9E%E6%B5%81/%E9%87%8D%E7%BB%98/Reflow/"/>
    
      <category term="Repaint" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%9E%E6%B5%81/%E9%87%8D%E7%BB%98/Reflow/Repaint/"/>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="回流" scheme="https://heiyehk.github.io/blog/tags/%E5%9B%9E%E6%B5%81/"/>
    
      <category term="重绘" scheme="https://heiyehk.github.io/blog/tags/%E9%87%8D%E7%BB%98/"/>
    
      <category term="Reflow" scheme="https://heiyehk.github.io/blog/tags/Reflow/"/>
    
      <category term="Repaint" scheme="https://heiyehk.github.io/blog/tags/Repaint/"/>
    
  </entry>
  
  <entry>
    <title>HTML5-新特性</title>
    <link href="https://heiyehk.github.io/blog/HTML5-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://heiyehk.github.io/blog/HTML5-%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-04-30T04:34:48.000Z</published>
    <updated>2020-04-30T09:27:57.579Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1.语义化标签"></a>1.语义化标签</h3><p>语义化标签 为页面提供了更好的页面结构。</p><table><thead><tr><th>描述</th><th>属性</th></tr></thead><tbody><tr><td>&lt;header&gt;&lt;/header&gt;</td><td>定义文档的头部区域</td></tr><tr><td>&lt;footer&gt;&lt;/footer&gt;</td><td>定义文档的尾部区域</td></tr><tr><td>&lt;nav&gt;&lt;/nav&gt;</td><td>定义文档的导航区域</td></tr><tr><td>&lt;section&gt;&lt;/section&gt;</td><td>定义文档的段落</td></tr><tr><td>&lt;article&gt;&lt;/article&gt;</td><td>定义页面独立的内容区域</td></tr><tr><td>&lt;aside&gt;&lt;/aside&gt;</td><td>定义页面侧边栏内容</td></tr><tr><td>&lt;command&gt;&lt;/command&gt;</td><td>定义命令按钮</td></tr><tr><td>&lt;details&gt;&lt;/details&gt;</td><td>标签包含 details 元素的标题</td></tr><tr><td>&lt;dialog&gt;&lt;/dialog&gt;</td><td>定义对话框</td></tr></tbody></table><a id="more"></a><h3 id="2-增强型表单"><a href="#2-增强型表单" class="headerlink" title="2.增强型表单"></a>2.增强型表单</h3><p>HTML5 提供了多个新的表单输入类型。</p><table><thead><tr><th>输入类型</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>主要用于选取颜色</td></tr><tr><td>date</td><td>从一个日期选择器选择一个日期</td></tr><tr><td>datetime</td><td>选择一个日期（UTC 时间）</td></tr><tr><td>datetime-local</td><td>选择一个日期和时间 (无时区)</td></tr><tr><td>email</td><td>包含 e-mail 地址的输入域</td></tr><tr><td>month</td><td>选择一个月份</td></tr><tr><td>number</td><td>数值的输入域</td></tr><tr><td>range</td><td>一定范围内数字值的输入域</td></tr><tr><td>search</td><td>用于搜索域</td></tr><tr><td>tel</td><td>定义输入电话号码字段</td></tr><tr><td>time</td><td>选择一个时间</td></tr><tr><td>url</td><td>URL 地址的输入域</td></tr><tr><td>week</td><td>选择周和年</td></tr></tbody></table><p>同时，还增加了新的表单属性：</p><ol><li>placehoder 属性，简短的提示在用户输入值前会显示在输入域上。即我们常见的输入框默认提示，在用户输入后消失。</li><li>required  属性，是一个 boolean 属性。要求填写的输入域不能为空</li><li>pattern 属性，描述了一个正则表达式用于验证<code>&lt;input&gt;</code> 元素的值。</li><li>min 和 max 属性，设置元素最小值与最大值。</li><li>step 属性，为输入域规定合法的数字间隔。</li><li>height 和 width 属性，用于 image 类型的 <code>&lt;input&gt;</code> 标签的图像高度和宽度。</li><li>autofocus 属性，是一个 boolean 属性。规定在页面加载时，域自动地获得焦点。</li><li>multiple 属性 ，是一个 boolean 属性。规定<code>&lt;input&gt;</code> 元素中可选择多个值。　　</li></ol><h3 id="3-音频和视频"><a href="#3-音频和视频" class="headerlink" title="3.音频和视频"></a>3.音频和视频</h3><p>HTML5 提供了 音频和视频 。</p><p><strong>音频：<code>&lt;audio&gt;</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"xxx.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"xxx.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span>&gt;</span></span><br><span class="line">  您的浏览器不支持 audio 元素。</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>视频：<code>&lt;video&gt;</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"300"</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"xxx.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"xxx.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>&gt;</span></span><br><span class="line">  您的浏览器不支持Video标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-canvas-绘图"><a href="#4-canvas-绘图" class="headerlink" title="4.canvas 绘图"></a>4.canvas 绘图</h3><ul><li>HTML5 <code>&lt;canvas&gt;</code> 标签用于绘制图像（通过脚本，通常是 JavaScript）。  </li><li>不过，<code>&lt;canvas&gt;</code> 元素本身并没有绘制能力（它仅仅是图形的容器） - 您必须使用脚本来完成实际的绘图任务。  </li><li>getContext() 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。</li></ul><h3 id="5-SVG-绘图"><a href="#5-SVG-绘图" class="headerlink" title="5.SVG 绘图"></a>5.SVG 绘图</h3><p>SVG 意为可缩放矢量图形（Scalable Vector Graphics）</p><p>SVG 与 Canvas两者间的区别</p><ul><li>SVG 是一种使用 XML 描述 2D 图形的语言。</li><li>Canvas 通过 JavaScript 来绘制 2D 图形。</li><li>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</li><li>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</li><li>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</li></ul><h3 id="6-地理定位（Geolocation）"><a href="#6-地理定位（Geolocation）" class="headerlink" title="6.地理定位（Geolocation）"></a>6.地理定位（Geolocation）</h3><p>HTML5 Geolocation（地理定位）用于定位用户的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.geolocation &#123;</span><br><span class="line">  getCurrentPosition:  fn  <span class="comment">// 用于获取当前的位置数据</span></span><br><span class="line">  watchPosition: fn  <span class="comment">// 监视用户位置的改变</span></span><br><span class="line">  clearWatch: fn  <span class="comment">// 清除定位监视</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取用户定位信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">pos</span>) </span>&#123; <span class="comment">// 定位成功的回调</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用户定位数据获取成功'</span>)</span><br><span class="line">    <span class="comment">// console.log(arguments);</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'定位时间：'</span>,pos.timestamp)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'经度：'</span>,pos.coords.longitude)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'纬度：'</span>,pos.coords.latitude)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'海拔：'</span>,pos.coords.altitude)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'速度：'</span>,pos.coords.speed)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; <span class="comment">// 定位失败的回调</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用户定位数据获取失败'</span>)</span><br><span class="line">    <span class="comment">//console.log(arguments);</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="7-拖放API"><a href="#7-拖放API" class="headerlink" title="7.拖放API"></a>7.拖放API</h3><p>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。<br>在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。</p><h3 id="8-Web-Storage"><a href="#8-Web-Storage" class="headerlink" title="8.Web Storage"></a>8.Web Storage</h3><p>使用HTML5可以在本地存储用户的浏览数据。<br>客户端存储数据的两个对象为：</p><p><strong>localStorage</strong>：没有时间限制的数据存储<br><strong>sessionStorage</strong>： 针对一个 session 的数据存储, 当用户关闭浏览器窗口后，数据会被删除。</p><p>不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：</p><ol><li>保存数据：localStorage.setItem(key,value);</li><li>读取数据：localStorage.getItem(key);</li><li>删除单个数据：localStorage.removeItem(key);</li><li>删除所有数据：localStorage.clear();</li><li>得到某个索引的key：localStorage.key(index);</li></ol><h3 id="9-WebSocket"><a href="#9-WebSocket" class="headerlink" title="9.WebSocket"></a>9.WebSocket</h3><p>WebSocket 是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。<br>在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。<br>两者之间就直接可以数据互相传送。<br>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。<br>当你获取 Web Socket 连接后，你可以通过 <strong>send()</strong> 方法来向服务器发送数据，并通过 <strong>onmessage</strong> 事件来接收服务器返回的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>W3Cschool教程(w3cschool.cn)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">WebSocketTest</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">         <span class="keyword">if</span> (<span class="string">"WebSocket"</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"您的浏览器支持 WebSocket!"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 打开一个 web socket</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:9998/echo"</span>);</span></span><br><span class="line"><span class="actionscript">            ws.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">               <span class="comment">// Web Socket 已连接上，使用 send() 方法发送数据</span></span></span><br><span class="line"><span class="actionscript">               ws.send(<span class="string">"发送数据"</span>);</span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"数据发送中..."</span>);</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            ws.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(evt)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">               <span class="keyword">var</span> received_msg = evt.data;</span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"数据已接收..."</span>);</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            ws.onclose = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">               <span class="comment">// 关闭 websocket</span></span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"连接已关闭..."</span>);</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">         &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 浏览器不支持 WebSocket</span></span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"您的浏览器不支持 WebSocket!"</span>);</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sse"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:WebSocketTest()"</span>&gt;</span>运行 WebSocket<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>非商用，侵删，转自: <a href="https://www.cnblogs.com/gaosirs/p/10756524.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaosirs/p/10756524.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-语义化标签&quot;&gt;&lt;a href=&quot;#1-语义化标签&quot; class=&quot;headerlink&quot; title=&quot;1.语义化标签&quot;&gt;&lt;/a&gt;1.语义化标签&lt;/h3&gt;&lt;p&gt;语义化标签 为页面提供了更好的页面结构。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&amp;lt;header&amp;gt;&amp;lt;/header&amp;gt;&lt;/td&gt;
&lt;td&gt;定义文档的头部区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;footer&amp;gt;&amp;lt;/footer&amp;gt;&lt;/td&gt;
&lt;td&gt;定义文档的尾部区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;nav&amp;gt;&amp;lt;/nav&amp;gt;&lt;/td&gt;
&lt;td&gt;定义文档的导航区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;section&amp;gt;&amp;lt;/section&amp;gt;&lt;/td&gt;
&lt;td&gt;定义文档的段落&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;&lt;/td&gt;
&lt;td&gt;定义页面独立的内容区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;aside&amp;gt;&amp;lt;/aside&amp;gt;&lt;/td&gt;
&lt;td&gt;定义页面侧边栏内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;command&amp;gt;&amp;lt;/command&amp;gt;&lt;/td&gt;
&lt;td&gt;定义命令按钮&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;details&amp;gt;&amp;lt;/details&amp;gt;&lt;/td&gt;
&lt;td&gt;标签包含 details 元素的标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;dialog&amp;gt;&amp;lt;/dialog&amp;gt;&lt;/td&gt;
&lt;td&gt;定义对话框&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="HTML5" scheme="https://heiyehk.github.io/blog/categories/HTML5/"/>
    
    
      <category term="HTML5" scheme="https://heiyehk.github.io/blog/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>HTML5-语义化</title>
    <link href="https://heiyehk.github.io/blog/HTML5-%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    <id>https://heiyehk.github.io/blog/HTML5-%E8%AF%AD%E4%B9%89%E5%8C%96/</id>
    <published>2020-04-30T04:33:37.000Z</published>
    <updated>2020-04-30T09:27:59.452Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>什么是语义化？就是用合理、正确的标签来展示内容，比如h1~h6定义标题。</p><h3 id="语义化优点："><a href="#语义化优点：" class="headerlink" title="语义化优点："></a>语义化优点：</h3><ul><li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</li><li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li><li>方便其他设备解析，如盲人阅读器根据语义渲染网页</li><li>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。</li></ul><a id="more"></a><p><img src="http://www.daqianduan.com/wp-content/uploads/2018/03/html5-768x508.png" alt="avatar"></p><ol><li><code>&lt;header&gt;</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在一个文档中，您可以定义多个&#96;&#96;&#96;&lt;header&gt;&#96;&#96;&#96;元素，但需要注意的是&#96;&#96;&#96;&lt;header&gt;&#96;&#96;&#96;元素不能作为&#96;&#96;&#96;&lt;address&gt;&#96;&#96;&#96;、&#96;&#96;&#96;&lt;footer&gt;&#96;&#96;&#96; 或 &#96;&#96;&#96;&lt;header&gt;&#96;&#96;&#96; 元素的子元素。</span><br><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;&lt;nav&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在一个文档中，可定义多个&#96;&#96;&#96;&lt;nav&gt;&#96;&#96;&#96;元素。</span><br><span class="line"></span><br><span class="line">3. &#96;&#96;&#96;&lt;main&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>定义文档的主要内容，该内容在文档中应当是独一无二的，不包含任何在文档中重复的内容，比如侧边栏，导航栏链接，版权信息，网站logo，搜索框（除非搜索框作为文档的主要功能）。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">需要注意的是在一个文档中不能出现多个&#96;&#96;&#96;&lt;main&gt;&#96;&#96;&#96;标签。</span><br><span class="line"></span><br><span class="line">4. &#96;&#96;&#96;&lt;article&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当&#96;&#96;&#96;&lt;article&gt;&#96;&#96;&#96;元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的&#96;&#96;&#96;&lt;article&gt;&#96;&#96;&#96;元素可嵌套在代表博客文章的&#96;&#96;&#96;&lt;article&gt;&#96;&#96;&#96;元素中。</span><br><span class="line"></span><br><span class="line">5. &#96;&#96;&#96;&lt;aside&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分且可以被单独的拆分出来而不会影响整体。通常表现为侧边栏或嵌入内容。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. &#96;&#96;&#96;&lt;footer&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用footer插入联系信息时，应在 footer 元素内使用 &#96;&#96;&#96;&lt;address&gt;&#96;&#96;&#96; 元素。</span><br><span class="line"></span><br><span class="line">注意不能包含&#96;&#96;&#96;&lt;footer&gt;&#96;&#96;&#96;或者&#96;&#96;&#96;&lt;header&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li><code>&lt;section&gt;</code></li></ol><p><code>&lt;section&gt;</code>表示文档中的一个区域（或节），比如，内容中的一个专题组。</p><p>如果元素内容可以分为几个部分的话，应该使用 <code>&lt;article&gt;</code> 而不是 <code>&lt;section&gt;</code>。<br>不要把 <code>&lt;section&gt;</code> 元素作为一个普通的容器来使用，特别是当<code>&lt;section&gt;</code>仅仅是为了美化样式或方便脚本使用的时候，应使用<code>&lt;div&gt;</code>。</p><p>这几个标签，比较容易混淆的是<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>，所以这里特别说明：</p><p>“Authors are encouraged to use the article element instead of the section element when it would make sense to syndicate the contents of the elemen.”</p><p>通俗来说就是<code>&lt;article&gt;</code>比<code>&lt;section&gt;</code>更具有独立性、完整性。可通过该段内容脱离了所在的语境，是否完整、独立来判断。</p><blockquote><p>非商用，侵删，转自: <a href="http://www.daqianduan.com/6549.html" target="_blank" rel="noopener">http://www.daqianduan.com/6549.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;什么是语义化？就是用合理、正确的标签来展示内容，比如h1~h6定义标题。&lt;/p&gt;
&lt;h3 id=&quot;语义化优点：&quot;&gt;&lt;a href=&quot;#语义化优点：&quot; class=&quot;headerlink&quot; title=&quot;语义化优点：&quot;&gt;&lt;/a&gt;语义化优点：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。&lt;/li&gt;
&lt;li&gt;有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。&lt;/li&gt;
&lt;li&gt;方便其他设备解析，如盲人阅读器根据语义渲染网页&lt;/li&gt;
&lt;li&gt;有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://heiyehk.github.io/blog/categories/HTML/"/>
    
    
      <category term="HTML" scheme="https://heiyehk.github.io/blog/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>SEO关键词</title>
    <link href="https://heiyehk.github.io/blog/SEO%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
    <id>https://heiyehk.github.io/blog/SEO%E5%85%B3%E9%94%AE%E8%AF%8D/</id>
    <published>2020-04-30T03:29:41.000Z</published>
    <updated>2020-04-30T09:28:09.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="title（网站标题）"><a href="#title（网站标题）" class="headerlink" title="title（网站标题）"></a>title（网站标题）</h3><p>title，就是浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到（搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。）title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。 </p><p>用法：<code>&lt;title&gt;网站标题&lt;/title&gt;</code>  </p><a id="more"></a><p>1）首页title写法，一般是“网站名称-主关键词或一句含有主关键词的描述”。小编在做优化时习惯把网站名称放最前面，主关键词放后面，因为搜索引擎给予标题最前面的词比后面的高。比如，做“贷款”这个词，就这样写“家财管加-成都贷款公司_成都个人贷款_成都抵押贷款_成都小额贷款_成都信用贷款”。</p><p>2）栏目页title写法，一般有2种：“栏目名称-网站名称”、“栏目名称栏目关键词-网站名称”。小编建议用“栏目名称-网站名称”。而且栏目名称最好用关键词来确定，比如贷款产品类型栏目最好就用贷款类型，而不要起个让人无法识别的名字如贷款来人，贷款看看，或贷款加上一些特殊符号，这种写法虽然很有个性，但会让你的网站在优化上占了下风。</p><p>3）分类列表页title写法，一般是“分类列表页名称-栏目名称-网站名称”，这个和栏目页差不多。</p><p>4）文章页title写法，一般有3种：“文章标题-网站名称”、“内容标题-栏目名称”、“内容标题-栏目名称-网站名称”。其中，“内容标题-栏目名称-网站名称”的写法最为规范，但也相对复杂，它能给用户很好的提示，让用户知道他在访问哪篇文章，并且是在哪个网站的哪个栏目下。</p><h3 id="keywords（关键词）"><a href="#keywords（关键词）" class="headerlink" title="keywords（关键词）"></a>keywords（关键词）</h3><p>keywords，是用户不查看源代码看不到的。主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此keywords的每个词都要能在内容中找到相应匹配，才有利于排名。keywords一般不超过3个，每个关键词不宜过长，而且词语间要用英文“,”隔开。为什么用英文上文已经说过。而且，尽量将重要的关键字靠前放，因为靠后的关键字排名较差，除非你站有很高的权重。</p><p>小道消息称keywords曾被百度、谷歌、雅虎等搜索引擎剔除，将不会再影响搜索引擎的排序结果，小编认为设置一下总没坏处，还是有一些搜索引擎比较重视keywords标签的。</p><p>用法：<code>&lt;meta name=&quot;Keywords&quot; Content=&quot;关键词1,关键词2,关键词3,关键词4&quot;&gt;</code></p><p>1）首页keywords写法，一般是“网站名称,主要栏目名,主要关键词”。</p><p>2）栏目页keywords写法，一般是“栏目名称,栏目关键字,栏目分类列表名称”。</p><p>3）分类列表页keywords写法，这个就比较简单了，只要将你这个栏目中的主要关键字写入即可。</p><p>4）文章页keywords写法，建议大家提取文章中的关键词，比如我的文章主要是讲信用贷款的，那么我关键词肯定是信用贷款，如果你觉得你提取关键词的能力较差，也可以选择文章中出现比较多的词来作为关键词，比如我现在写的内容是关于title、keywords、description的，那我的文章页关键词就是这3个。</p><h3 id="description（内容摘要）"><a href="#description（内容摘要）" class="headerlink" title="description（内容摘要）"></a>description（内容摘要）</h3><p>description，和上面的keywords一样，是用户不查看源代码看不到的，而且也是对于一个网页的简要内容概况。不同的是，keywords是由几个词语的组成的，而description则是完整的一句话。description一般不超过150个字符，描述内容要和页面内容相关。</p><p>用法：<code>&lt;meta name=&quot;Description&quot; Content=&quot;你网页的简述&quot;&gt;</code></p><p>1）首页description写法，一般是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍。</p><p>2）栏目页description写法，一般是将栏目的标题、关键字、分类列表名称融合到里面，写成简单的介绍。</p><p>3）分类列表页description，这个就比较简单了，一般只需要把分类列表的标题、关键词融合在一起，写成简单的介绍。</p><p>4）文章页description写法，一般有2种写法，标准写法就和前面的一样，将文章标题、文章中的重要内容和关键词融合在一起，写成简单的介绍。这是最好最标准的写法。但是这样写比较麻烦，小编教你一种偷懒的方法，你可以在文章首段和标题中加入关键词，比如我这篇文章是讲title、keywords、description的，那么在文章首段和标题中就加入这些内容，然后直接将文章首段的内容复制到description中即可。</p><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>3个标签按重要性来分：<code>title &gt; description &gt; keywords</code></p><blockquote><p>非商用，侵删，转自: <a href="https://jingyan.baidu.com/article/ab69b2709d2c082ca7189fbe.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/ab69b2709d2c082ca7189fbe.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;title（网站标题）&quot;&gt;&lt;a href=&quot;#title（网站标题）&quot; class=&quot;headerlink&quot; title=&quot;title（网站标题）&quot;&gt;&lt;/a&gt;title（网站标题）&lt;/h3&gt;&lt;p&gt;title，就是浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到（搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。）title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。 &lt;/p&gt;
&lt;p&gt;用法：&lt;code&gt;&amp;lt;title&amp;gt;网站标题&amp;lt;/title&amp;gt;&lt;/code&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="SEO" scheme="https://heiyehk.github.io/blog/categories/SEO/"/>
    
    
      <category term="SEO" scheme="https://heiyehk.github.io/blog/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客初体验</title>
    <link href="https://heiyehk.github.io/blog/hexo%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://heiyehk.github.io/blog/hexo%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-04-29T06:15:36.000Z</published>
    <updated>2020-04-30T09:27:55.875Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>hexo是一款快速、简洁且高效的博客框架。<br>中文文档<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a>  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><a id="more"></a><p>网上有很多好看并且SEO优化的很好的主题，我选择了<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">Yilia</a>这款主题作为博客的新主题😁。</p><h3 id="网站的SEO优化"><a href="#网站的SEO优化" class="headerlink" title="网站的SEO优化"></a>网站的SEO优化</h3><h4 id="添加站点"><a href="#添加站点" class="headerlink" title="添加站点"></a>添加站点</h4><p>进入<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度站长平台</a>，然后进入个人中心，添加你的网站，把验证内容下载下来放入<code>source/assets</code>这个文件夹中。<br>进入<a href="https://search.google.com/search-console/welcome" target="_blank" rel="noopener">google search console</a>，选择<code>网址前缀</code>，输入你的域名，然后下载验证文件，把验证内容下载下来放入<code>source/assets</code>这个文件夹中。<br>当然也可以使用其他的验证方式进行验证。</p><h4 id="生成站点地图和rss"><a href="#生成站点地图和rss" class="headerlink" title="生成站点地图和rss"></a>生成站点地图和rss</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 谷歌sitemap</span></span><br><span class="line">npm install hexo-generator-sitemap</span><br><span class="line"><span class="comment"># 百度sitemap</span></span><br><span class="line">npm install hexo-generator-baidu-sitemap</span><br><span class="line"><span class="comment"># rss</span></span><br><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><p>然后在<code>站点根目录的_config.yml</code>配置如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">plugin:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-sitemap</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><h3 id="添加-robots-txt"><a href="#添加-robots-txt" class="headerlink" title="添加 robots.txt"></a>添加 robots.txt</h3><p>如果是放在<code>blog</code>目录下的话，sitemap可使用其他生成sitemap的工具进行生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;blog&#x2F;</span><br><span class="line">Allow: &#x2F;blog&#x2F;archives&#x2F;</span><br><span class="line"></span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line">Disallow: &#x2F;categories&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: https:&#x2F;&#x2F;heiyehk.github.io&#x2F;sitemap.xml</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;heiyehk.github.io&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure><h3 id="提交sitemap"><a href="#提交sitemap" class="headerlink" title="提交sitemap"></a>提交sitemap</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">1000</span> <span class="comment">## 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">alili.tech</span> <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">xxxxx</span> <span class="comment">## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment">## 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;hexo是一款快速、简洁且高效的博客框架。&lt;br&gt;中文文档&lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io/zh-cn/docs/&lt;/a&gt;  &lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://heiyehk.github.io/blog/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://heiyehk.github.io/blog/tags/hexo/"/>
    
  </entry>
  
</feed>
