<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeiYe</title>
  
  <subtitle>不忘初心，方得始终</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://heiyehk.github.io/blog/"/>
  <updated>2020-09-29T08:50:48.757Z</updated>
  <id>https://heiyehk.github.io/blog/</id>
  
  <author>
    <name>HeiYehk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小笔记</title>
    <link href="https://heiyehk.github.io/blog/%E5%B0%8F%E7%AC%94%E8%AE%B0/"/>
    <id>https://heiyehk.github.io/blog/%E5%B0%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-29T08:40:44.000Z</published>
    <updated>2020-09-29T08:50:48.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="获取视频时长"><a href="#获取视频时长" class="headerlink" title="获取视频时长"></a>获取视频时长</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getVideoDuration(file: File) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fileurl = URL.createObjectURL(file);</span><br><span class="line">    <span class="keyword">const</span> audioElement: HTMLAudioElement = <span class="keyword">new</span> Audio(fileurl);</span><br><span class="line">    <span class="keyword">let</span> eventListener: <span class="built_in">any</span>;</span><br><span class="line">    eventListener = audioElement.addEventListener(<span class="string">'loadedmetadata'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(audioElement.duration);</span><br><span class="line">      audioElement.removeEventListener(<span class="string">'loadedmetadata'</span>, eventListener);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h3><h4 id="解决多次点击报错问题"><a href="#解决多次点击报错问题" class="headerlink" title="解决多次点击报错问题"></a>解决多次点击报错问题</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalPush = Router.prototype.push;</span><br><span class="line">Router.prototype.push = <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">location: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">originalPush.call(<span class="params"><span class="keyword">this</span>, location</span>) <span class="keyword">as</span> <span class="built_in">any</span></span>).<span class="params">catch</span>(<span class="params">(<span class="params">err: <span class="built_in">any</span></span>) =&gt; err</span>);</span></span><br><span class="line"><span class="function">&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="重置默认路由"><a href="#重置默认路由" class="headerlink" title="重置默认路由"></a>重置默认路由</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 思路直接替换掉默认原有的路由</span></span><br><span class="line"><span class="keyword">const</span> resetRouter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  router.matcher = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    routes</span><br><span class="line">  &#125;).matcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象过滤空内容"><a href="#对象过滤空内容" class="headerlink" title="对象过滤空内容"></a>对象过滤空内容</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterEmpty = (</span><br><span class="line">  data: AxiosData,</span><br><span class="line">  validation?: <span class="built_in">any</span>[] | <span class="literal">undefined</span></span><br><span class="line">) =&gt; AxiosData;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; data Object对象，如&#123; a: null, b: 1, c: '' &#125;</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; validation 传入需要过滤的数组，如[null, undefined, '', 0]</span></span><br><span class="line"><span class="comment"> * @returns &#123;Object&#125; 返回一个新的Object对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> filterEmpty: FilterEmpty = (</span><br><span class="line">  data: AxiosData,</span><br><span class="line">  validation?: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">'object'</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> newObj: AxiosData = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key of <span class="built_in">Object</span>.keys(data)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validation) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data[key] !== <span class="string">''</span> &amp;&amp; data[key] !== <span class="literal">undefined</span> &amp;&amp; data[key] !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newObj[key] = data[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!validation.includes(data[key])) &#123;</span><br><span class="line">        newObj[key] = data[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="base64转Blob对象"><a href="#base64转Blob对象" class="headerlink" title="base64转Blob对象"></a>base64转Blob对象</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> convertBase64UrlToBlob = (</span><br><span class="line">  base64: <span class="built_in">string</span> | <span class="built_in">ArrayBuffer</span> | <span class="literal">null</span></span><br><span class="line">): <span class="function"><span class="params">Blob</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 切割base64</span></span><br><span class="line">  <span class="keyword">const</span> arr = (base64 <span class="keyword">as</span> <span class="built_in">string</span>).split(<span class="string">','</span>);</span><br><span class="line">  <span class="keyword">const</span> mime = ((arr[<span class="number">0</span>] <span class="keyword">as</span> <span class="built_in">string</span>).match(<span class="regexp">/:(.*?);/</span>) <span class="keyword">as</span> RegExpMatchArray)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> bstr = atob(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> n = bstr.length;</span><br><span class="line">  <span class="keyword">const</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([u8arr], &#123;</span><br><span class="line">    <span class="keyword">type</span>: mime</span><br><span class="line">  &#125;) <span class="keyword">as</span> Blob;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="判断是否pc"><a href="#判断是否pc" class="headerlink" title="判断是否pc"></a>判断是否pc</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isPc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> agents = [</span><br><span class="line">    <span class="string">'Android'</span>,</span><br><span class="line">    <span class="string">'iPhone'</span>,</span><br><span class="line">    <span class="string">'SymbianOS'</span>,</span><br><span class="line">    <span class="string">'Windows Phone'</span>,</span><br><span class="line">    <span class="string">'iPad'</span>,</span><br><span class="line">    <span class="string">'iPod'</span></span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">return</span> !!agents.filter(<span class="function"><span class="params">x</span> =&gt;</span> navigator.userAgent.includes(x)).length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;获取视频时长&quot;&gt;&lt;a href=&quot;#获取视频时长&quot; class=&quot;headerlink&quot; title=&quot;获取视频时长&quot;&gt;&lt;/a&gt;获取视频时长&lt;/h3&gt;&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getVideoDuration(file: File) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;resolve&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fileurl = URL.createObjectURL(file);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; audioElement: HTMLAudioElement = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Audio(fileurl);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; eventListener: &lt;span class=&quot;built_in&quot;&gt;any&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    eventListener = audioElement.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;loadedmetadata&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      resolve(audioElement.duration);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      audioElement.removeEventListener(&lt;span class=&quot;string&quot;&gt;&#39;loadedmetadata&#39;&lt;/span&gt;, eventListener);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
      <category term="变量提升" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    
      <category term="函数声明提升" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/tags/js/"/>
    
      <category term="变量提升" scheme="https://heiyehk.github.io/blog/tags/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    
      <category term="函数声明提升" scheme="https://heiyehk.github.io/blog/tags/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>深入理解变量声明提升和函数声明提升</title>
    <link href="https://heiyehk.github.io/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/"/>
    <id>https://heiyehk.github.io/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/</id>
    <published>2020-05-20T08:42:14.000Z</published>
    <updated>2020-09-29T08:40:54.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><h4 id="1、变量定义"><a href="#1、变量定义" class="headerlink" title="1、变量定义"></a>1、变量定义</h4><p>可以使用var定义变量，变量如果没有赋值，那变量的初始值为<code>undefined</code>。</p><h4 id="2、变量作用域"><a href="#2、变量作用域" class="headerlink" title="2、变量作用域"></a>2、变量作用域</h4><p>变量作用域指变量起作用的范围。变量分为全局变量和局部变量。全局变量在全局都拥有定义；而局部变量只能在函数内有效。<br>在函数体内，同名的局部变量或者参数的优先级会高于全局变量。也就是说，如果函数内存在和全局变量同名的局部变量或者参数，那么全局变量将会被局部变量覆盖。<br><strong>所有不使用var定义的变量都视为全局变量</strong></p><a id="more"></a><h4 id="3、函数作用域和声明提前"><a href="#3、函数作用域和声明提前" class="headerlink" title="3、函数作用域和声明提前"></a>3、函数作用域和声明提前</h4><p>JavaScript的函数作用是指在函数内声明的所有变量在函数体内始终是有定义的，也就是说<strong>变量在声明之前已经可用</strong>，所有这特性称为<code>声明提前（hoisting）</code>，即JavaScript函数里的所有声明（只是声明，但不涉及赋值）都被提前到函数体的顶部，而变量赋值操作留在原来的位置。如下面例子：<br>注释：<code>声明提前</code>是在JavaScript引擎的预编译时进行，是在代码开始运行之前。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(scope);</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于函数内声明提升，所以上面的代码实际上是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope;    <span class="comment">//变量声明提升到函数顶部</span></span><br><span class="line">  <span class="built_in">console</span>.log(scope);</span><br><span class="line">  scope = <span class="string">'local'</span>;    <span class="comment">//变量初始化依然保留在原来的位置</span></span><br><span class="line">  <span class="built_in">console</span>.log(scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样变形之后，答案就就非常明显了。由于scope在第一个console.log(scope)语句之前就已经定义了，但是并没有赋值，因此此时scope的指是<code>undefined</code>.第二个console.log(scope)语句之前，scope已经完成赋值为’local’，所以输出的结果是<code>local</code>。</p><h3 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h3><h4 id="1、函数的两种创建方式"><a href="#1、函数的两种创建方式" class="headerlink" title="1、函数的两种创建方式"></a>1、函数的两种创建方式</h4><h5 id="函数声明语法"><a href="#函数声明语法" class="headerlink" title="函数声明语法"></a>函数声明语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="string">'superman'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的程序，控制台能打印出<code>supemran</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="string">'superman'</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码，会报错<code>Uncaught ReferenceError: f is not defined(…)</code>,错误信息显示说f没有被定义。<br>为什么同样的代码，函数声明和函数表达式存在着差异呢？<br>这是因为，函数声明有一个非常重要的特征：<code>函数声明提升</code>，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部（是不是跟变量提升非常类似）。正是因为这个特征，所以可以把函数声明放在调用它的语句后面。如下面例子，最终的输出结果应该是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></figure><p>可能会有人觉得最后输出的结果是<code>1</code>。让我们来分析一下，这个例子涉及到了<code>变量声明提升</code>和<code>函数声明提升</code>。正如前面说到的函数声明提升，函数声明<code>function getName(){}</code>的声明会被提前到顶部。而函数表达式<code>var getName = function(){}</code>则表现出变量声明提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到底部，而变量的赋值依然保留在原来的位置。需要注意的是，函数优先，虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。因此上面的函数可以转换成下面的样子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//函数声明提升到顶部</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName;    <span class="comment">//变量声明提升</span></span><br><span class="line">getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//变量赋值依然保留在原来的位置</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();    <span class="comment">// 最终输出：2</span></span><br></pre></td></tr></table></figure><p>所以最终的输出结果是：<code>2</code>。在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出<code>2</code>。</p><h5 id="函数表达式语法"><a href="#函数表达式语法" class="headerlink" title="函数表达式语法"></a>函数表达式语法</h5><blockquote><p>版权声明：本文为CSDN博主「前端超人」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq673318522/java/article/details/50810650" target="_blank" rel="noopener">https://blog.csdn.net/qq673318522/java/article/details/50810650</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;变量声明提升&quot;&gt;&lt;a href=&quot;#变量声明提升&quot; class=&quot;headerlink&quot; title=&quot;变量声明提升&quot;&gt;&lt;/a&gt;变量声明提升&lt;/h3&gt;&lt;h4 id=&quot;1、变量定义&quot;&gt;&lt;a href=&quot;#1、变量定义&quot; class=&quot;headerlink&quot; title=&quot;1、变量定义&quot;&gt;&lt;/a&gt;1、变量定义&lt;/h4&gt;&lt;p&gt;可以使用var定义变量，变量如果没有赋值，那变量的初始值为&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;2、变量作用域&quot;&gt;&lt;a href=&quot;#2、变量作用域&quot; class=&quot;headerlink&quot; title=&quot;2、变量作用域&quot;&gt;&lt;/a&gt;2、变量作用域&lt;/h4&gt;&lt;p&gt;变量作用域指变量起作用的范围。变量分为全局变量和局部变量。全局变量在全局都拥有定义；而局部变量只能在函数内有效。&lt;br&gt;在函数体内，同名的局部变量或者参数的优先级会高于全局变量。也就是说，如果函数内存在和全局变量同名的局部变量或者参数，那么全局变量将会被局部变量覆盖。&lt;br&gt;&lt;strong&gt;所有不使用var定义的变量都视为全局变量&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
      <category term="变量提升" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    
      <category term="函数声明提升" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/tags/js/"/>
    
      <category term="变量提升" scheme="https://heiyehk.github.io/blog/tags/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    
      <category term="函数声明提升" scheme="https://heiyehk.github.io/blog/tags/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入理解js闭包</title>
    <link href="https://heiyehk.github.io/blog/javascript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E9%97%AD%E5%8C%85/"/>
    <id>https://heiyehk.github.io/blog/javascript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E9%97%AD%E5%8C%85/</id>
    <published>2020-05-20T08:25:16.000Z</published>
    <updated>2020-05-20T08:57:39.484Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p></blockquote><h3 id="一、变量的作用域"><a href="#一、变量的作用域" class="headerlink" title="一、变量的作用域"></a>一、变量的作用域</h3><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p><p>变量的作用域无非就是两种：全局变量和局部变量。</p><p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(n);</span><br><span class="line">&#125;</span><br><span class="line">f1(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p>另一方面，在函数外部自然无法读取函数内的局部变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(n); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  n=<span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">alert(n); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><h3 id="二、如何从外部读取局部变量？"><a href="#二、如何从外部读取局部变量？" class="headerlink" title="二、如何从外部读取局部变量？"></a>二、如何从外部读取局部变量？</h3><p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p><p>那就是在函数的内部，再定义一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  n=<span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），</p><p>子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  n=<span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><h3 id="三、闭包的概念"><a href="#三、闭包的概念" class="headerlink" title="三、闭包的概念"></a>三、闭包的概念</h3><p>上一节代码中的f2函数，就是闭包。</p><p>各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</p><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p><p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><h3 id="四、闭包的用途"><a href="#四、闭包的用途" class="headerlink" title="四、闭包的用途"></a>四、闭包的用途</h3><p>闭包可以用在许多地方。它的最大用处有两个</p><ol><li>读取函数内部的变量</li><li>让这些变量的值始终保持在内存中。</li></ol><p>怎么来理解这句话呢？请看下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">  nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line">nAdd();</span><br><span class="line">result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p><p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个</p><p>匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p><h3 id="五、使用闭包的注意点"><a href="#五、使用闭包的注意点" class="headerlink" title="五、使用闭包的注意点"></a>五、使用闭包的注意点</h3><ol><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li><li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便</li></ol><p>改变父函数内部变量的值。</p><h3 id="六、思考题"><a href="#六、思考题" class="headerlink" title="六、思考题"></a>六、思考题</h3><p>如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;  </span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name : <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//The Window</span></span><br></pre></td></tr></table></figure><h3 id="JavaScript闭包例子"><a href="#JavaScript闭包例子" class="headerlink" title="JavaScript闭包例子"></a>JavaScript闭包例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    alert(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">innerFun()</span><br></pre></td></tr></table></figure><p>上面的代码是<code>错误</code>的.innerFun()的作用域在outerFun()内部,所在outerFun()外部调用它是错误的.</p><p>改成如下,也就是闭包:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    alert(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFun; <span class="comment">//注意这里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=outerFun();</span><br><span class="line">obj(); <span class="comment">//结果为1</span></span><br><span class="line">obj(); <span class="comment">//结果为2</span></span><br><span class="line"><span class="keyword">var</span> obj2=outerFun();</span><br><span class="line">obj2(); <span class="comment">//结果为1</span></span><br><span class="line">obj2(); <span class="comment">//结果为2</span></span><br></pre></td></tr></table></figure><p>什么是闭包:</p><p>当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们.</p><h3 id="再来看一个例子"><a href="#再来看一个例子" class="headerlink" title="再来看一个例子"></a>再来看一个例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a =<span class="number">0</span>;</span><br><span class="line">  alert(a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">4</span>;</span><br><span class="line">outerFun();</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure><p>结果是 0,4 .  因为在函数内部使用了var关键字 维护a的作用域在outFun()内部.</p><p>再看下面的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//没有var</span></span><br><span class="line">  a =<span class="number">0</span>;</span><br><span class="line">  alert(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">4</span>;</span><br><span class="line">outerFun();</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure><p>结果为 <code>0,0</code> 真是奇怪,为什么呢?</p><p>作用域链是描述一种路径的术语,沿着该路径可以确定变量的值 .当执行a=0时,因为没有使用var关键字,因此赋值操作会沿着作用域链到var a=4;  并改变其值.</p><p>如果你对javascript闭包还不是很理解，那么请看下面转载的文章：(转载:<a href="http://www.felixwoo.com/archives/247" target="_blank" rel="noopener">http://www.felixwoo.com/archives/247</a>)</p><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。<br>相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：<code>JavaScript中所有的function都是一个闭包</code>。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123; alert(++i); &#125; </span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = a();</span><br><span class="line">c();</span><br></pre></td></tr></table></figure><p>这段代码有两个特点：</p><ol><li><p>函数b嵌套在函数a内部；</p></li><li><p>函数a返回函数b。</p></li></ol><p>引用关系如图：</p><p><img src="https://www.jb51.net/upload/201007/20100703001016918.jpg" alt="https://www.jb51.net/upload/201007/20100703001016918.jpg"></p><p>这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：</p><p><strong>当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。</strong></p><p>让我们说的更透彻一些。所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。</p><h3 id="闭包有什么作用？"><a href="#闭包有什么作用？" class="headerlink" title="闭包有什么作用？"></a>闭包有什么作用？</h3><p>简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程。</p><p>在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。</p><p>　　那 么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。(关于Javascript的垃圾回收机制将在后面详细介绍)</p><h3 id="闭包内的微观世界"><a href="#闭包内的微观世界" class="headerlink" title="闭包内的微观世界"></a>闭包内的微观世界</h3><p>　如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。</p><ul><li>当<code>定义</code>函数a的时候，js解释器会将函数a的<code>作用域链(scope chain)</code>设置为定义<code>a时a所在的“环境”</code>，如果a是一个全局函数，则scope chain中只有window对象。</li><li>当<code>执行</code>函数a的时候，a会进入相应的<code>执行环境(excution context)</code>。</li><li>在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。</li><li>然后执行环境会创建一个<code>活动对象(call object)</code>。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。</li><li>下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。</li><li>最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。</li></ul><p>到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。</p><p>当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，如下图所示：</p><p><img src="https://www.jb51.net/upload/201007/20100703001017585.jpg" alt="https://www.jb51.net/upload/201007/20100703001017585.jpg"></p><p>如图所示，当在函数b中访问一个变量的时候，搜索顺序是：</p><ul><li>先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。</li><li>如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。</li><li>如果整个作用域链上都无法找到，则返回undefined。<br>小结，本段中提到了两个重要的词语：函数的<code>定义与执行</code>。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> h = f(<span class="number">1</span>);</span><br><span class="line">alert(h());</span><br></pre></td></tr></table></figure><p>这段代码中变量h指向了f中的那个匿名函数(由g返回)。</p><ul><li>假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。<br>假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。</li><li>如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。</li></ul><p>运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。</p><h3 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h3><p>保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。</p><ul><li>在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。</li><li>通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问）</li><li>私有属性和方法在Constructor外是无法被访问的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params">...</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>; </span><br><span class="line">  <span class="keyword">var</span> membername = value; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">membername</span>(<span class="params">...</span>) </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Javascript的垃圾回收机制"><a href="#Javascript的垃圾回收机制" class="headerlink" title="Javascript的垃圾回收机制"></a>Javascript的垃圾回收机制</h3><p>在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。</p><blockquote><p>非商用，侵删，转自: <a href="https://www.jb51.net/article/24101.htm" target="_blank" rel="noopener">https://www.jb51.net/article/24101.htm</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、变量的作用域&quot;&gt;&lt;a href=&quot;#一、变量的作用域&quot; class=&quot;headerlink&quot; title=&quot;一、变量的作用域&quot;&gt;&lt;/a&gt;一、变量的作用域&lt;/h3&gt;&lt;p&gt;要理解闭包，首先必须理解Javascript特殊的变量作用域。&lt;/p&gt;
&lt;p&gt;变量的作用域无非就是两种：全局变量和局部变量。&lt;/p&gt;
&lt;p&gt;Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
      <category term="闭包" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/%E9%97%AD%E5%8C%85/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/tags/js/"/>
    
      <category term="闭包" scheme="https://heiyehk.github.io/blog/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链的理解</title>
    <link href="https://heiyehk.github.io/blog/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://heiyehk.github.io/blog/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-05-20T08:14:52.000Z</published>
    <updated>2020-05-20T08:56:29.356Z</updated>
    
    <content type="html"><![CDATA[<p>【本文章系转载】</p><p>最开始想要直观的理解请直接参考阮一峰老师博客关于继承的讲解：<a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html</a></p><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>javascript语言是一种面向对象的语言，它没有”子类”和”父类”的概念，里面所有的数据类型都是对象，如何将这些对象联系起来呢？</p><p>Brendan Eich在考虑设计继承机制的时候，参考了C++和JAVA使用new命令，通过调用类的构造函数生成实例的方式，将new命令引入javascript。</p><p>C++的写法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName *object = <span class="keyword">new</span> ClassName(param);</span><br></pre></td></tr></table></figure><a id="more"></a><p>Java的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>但是，javascript里面没有“类”这个概念，那么，Brendan Eich决定直接在new后面跟一个构造函数，来生成实例。</p><p>构造函数是什么？构造函数与其他函数唯一的区别在于调用方式不同。任何函数只要通过new来调用就可以作为构造函数，它是用来创建特定类型的对象。</p><p>下面定义一个构造函数Female：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Female</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">'female'</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过new命令来生成一个person实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Female(<span class="string">"Summer"</span>)</span><br></pre></td></tr></table></figure><p>这里，构造函数Female就是实例对象person1的原型！！！Female里的this关键字就指的是person1这个对象！</p><p>new出来的person1对象此时已经和Female再无联系了！也就是说每一个new出来的实例都有自己的属性和方法的副本，是独立的的！修改其中一个不会影响另一个！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Female(<span class="string">"Summer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Female(<span class="string">"Lily"</span>);</span><br><span class="line"></span><br><span class="line">person2.sex = <span class="string">'male'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sex)      <span class="comment">// female</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.sex)      <span class="comment">// male</span></span><br></pre></td></tr></table></figure><p>但是，我们希望构造函数中的sex属性是一个共有属性，那么此时用这样的方法，每个实例中都有一个相同的sex属性，会造成资源极大的浪费！</p><p>那么原型对象就即将登场了！Brendan Eich决定给每一个构造函数都设置一个<strong>prototype属性</strong>，这个属性就指向原型对象。其实原型对象就只是个普通对象，里面存放着所有实例对象需要共享的属性和方法！所以，我们把需要共享的放到原型对象里，把那些不需要共享的属性和方法存在在构造函数里！</p><p>那么上面的代码可改写如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">'female'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Summer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Lily"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sex)      <span class="comment">// female</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.sex)      <span class="comment">// female</span></span><br><span class="line"></span><br><span class="line">Person.prototype.sex = <span class="string">'male'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sex)      <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.sex)      <span class="comment">// male</span></span><br></pre></td></tr></table></figure><p>可以看出，修改prototype属性会影响它的所有实例的sex的值！！</p><p>实例一旦创建出来就会自动引用prototype对象的属性和方法！所以实例对象的属性和方法一般分为两种：一种是自身的，一种是引用自prototype的。</p><p>具体实现是这样的：</p><p>每当代码读取某个对象的某个属性的时候，都会执行一次搜索。首先从对象实例本身开始，如果在实例中找到了该属性，则返回该属性的值，如果没有找到，则顺着<strong>原型链指针</strong>向上，到原型对象中去找，如果如果找到就返回该属性值。</p><p>这里要提一点，如果为对象实例添加了一个属性与原型中同名，则该属性会屏蔽掉原型中的同名属性，不会去修改它！使用delete可以删除实例中的属性提到delete那要插一句~<strong>delete只能删除对象下的属性，不能删除变量和参数！</strong></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>事实上，js里完全依靠”原型链”(prototype chain)模式来实现继承。</p><p>上面说完原型对象。下面要扒一扒proto、prototype、constructor。</p><ul><li>proto：事实上就是原型链指针！！</li><li>prototype：上面说到这个是指向原型对象的</li><li>constructor：每一个原型对象都包含一个指向构造函数的指针，就是constructor</li></ul><h3 id="继承实现方式："><a href="#继承实现方式：" class="headerlink" title="继承实现方式："></a>继承实现方式：</h3><p>为了实现继承，proto会指向上一层的原型对象，而上一层的结构依然类似，那么就利用proto一直指向Object的原型对象上！Object.prototype.<strong>proto</strong> = null;表示到达最顶端。如此形成了原型链继承。</p><p>下面有个图解非常经典，我自己也手画了一遍去理解，真的非常有效~</p><p><img src="https://upload-images.jianshu.io/upload_images/2418690-5d2b5b99c77e9fc7..png" alt="https://upload-images.jianshu.io/upload_images/2418690-5d2b5b99c77e9fc7..png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大致总结一下就是：</p><ol><li>Object是作为众多new出来的实例的基类 function Object(){ [ native code ] }</li><li>Function是作为众多function出来的函数的基类 function Function(){ [ native code ] }</li><li>构造函数的proto(包括Function.prototype和Object.prototype)都指向Function.prototype</li><li>原型对象的proto都指向Object.prototype</li><li>Object.prototype.proto指向null</li></ol><blockquote><p>作者：兔子不打地鼠打代码<br>链接：<a href="https://www.jianshu.com/p/f30fa27999e3" target="_blank" rel="noopener">https://www.jianshu.com/p/f30fa27999e3</a><br>来源：简书</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【本文章系转载】&lt;/p&gt;
&lt;p&gt;最开始想要直观的理解请直接参考阮一峰老师博客关于继承的讲解：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;原型对象&quot;&gt;&lt;a href=&quot;#原型对象&quot; class=&quot;headerlink&quot; title=&quot;原型对象&quot;&gt;&lt;/a&gt;原型对象&lt;/h3&gt;&lt;p&gt;javascript语言是一种面向对象的语言，它没有”子类”和”父类”的概念，里面所有的数据类型都是对象，如何将这些对象联系起来呢？&lt;/p&gt;
&lt;p&gt;Brendan Eich在考虑设计继承机制的时候，参考了C++和JAVA使用new命令，通过调用类的构造函数生成实例的方式，将new命令引入javascript。&lt;/p&gt;
&lt;p&gt;C++的写法是：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ClassName *object = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ClassName(param);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
      <category term="原型" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/tags/js/"/>
    
      <category term="原型" scheme="https://heiyehk.github.io/blog/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://heiyehk.github.io/blog/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>认识V8引擎</title>
    <link href="https://heiyehk.github.io/blog/%E8%AE%A4%E8%AF%86V8%E5%BC%95%E6%93%8E/"/>
    <id>https://heiyehk.github.io/blog/%E8%AE%A4%E8%AF%86V8%E5%BC%95%E6%93%8E/</id>
    <published>2020-05-20T07:36:41.000Z</published>
    <updated>2020-05-20T08:56:03.084Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic2.zhimg.com/v2-4dce785ff4595de55623611ab0055d33_1200x500.jpg" alt="https://pic2.zhimg.com/v2-4dce785ff4595de55623611ab0055d33_1200x500.jpg"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JavaScript绝对是最火的编程语言之一，一直具有很大的用户群，随着在服务端的使用（NodeJs），更是爆发了极强的生命力。编程语言分为编译型语言和解释型语言两类，编译型语言在执行之前要先进行完全编译，而解释型语言一边编译一边执行，很明显解释型语言的执行速度是慢于编译型语言的，而JavaScript就是一种解释型脚本语言，支持动态类型、弱类型、基于原型的语言，内置支持类型。鉴于JavaScript都是在前端执行，而且需要及时响应用户，这就要求JavaScript可以快速的解析及执行。</p><p>随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，这就更需要快速的解析和执行JavaScript脚本。V8引擎就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript。</p><p>V8是如何使得JavaScript性能有大幅提升的呢？通过对一些书籍和文章的学习，梳理了V8的相关内容，本文将带你认识 V8。</p><a id="more"></a><h3 id="1-渲染引擎及网页渲染"><a href="#1-渲染引擎及网页渲染" class="headerlink" title="1.渲染引擎及网页渲染"></a>1.渲染引擎及网页渲染</h3><p>浏览器自从上世纪80年代后期90年代初期诞生以来，已经得到了长足的发展，其功能也越来越丰富，包括网络、资源管理、网页浏览、多页面管理、插件和扩展、书签管理、历史记录管理、设置管理、下载管理、账户和同步、安全机制、隐私管理、外观主题、开发者工具等。在这些功能中，为用户提供网页浏览服务无疑是最重要的功能，下面将对相关内容进行介绍。</p><h4 id="1-1-渲染引擎"><a href="#1-1-渲染引擎" class="headerlink" title="1.1.渲染引擎"></a>1.1.渲染引擎</h4><p>渲染引擎：能够将HTML/CSS/JavaScript文本及相应的资源文件转换成图像结果。渲染引擎的主要作用是将资源文件转化为用户可见的结果。在浏览器的发展过程中，不同的厂商开发了不同的渲染引擎，如Tridend(IE)、Gecko(FF)、WebKit(Safari,Chrome,Andriod浏览器)等。WebKit是由苹果2005年发起的一个开源项目，引起了众多公司的重视，几年间被很多公司所采用，在移动端更占据了垄断地位。更有甚者，开发出了基于WebKit的支持HTML5的web操作系统(如：Chrome OS、Web OS)。</p><p>下面是WebKit的大致结构：<br><img src="https://pic1.zhimg.com/80/v2-959135939fe2cbc2d9a437ef81dff328_720w.png" alt="https://pic1.zhimg.com/80/v2-959135939fe2cbc2d9a437ef81dff328_720w.png"></p><p>上图中实线框内模块是所有移植的共有部分，虚线框内不同的厂商可以自己实现。下面进行介绍：</p><ul><li>操作系统：是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。WebKit也是在操作系统上工作的。</li><li>第三方库，为了WebKit提供支持，如图形库、网络库、视频库等。</li><li>WebCore 是各个浏览器使用的共享部分，包括HTML解析器、CSS解析器、DOM和SVG等。JavaScriptCore是WebKit的默认引擎，在谷歌系列产品中被替换为V8引擎。WebKit Ports是WebKit中的非共享部分，由于平台差异、第三方库和需求的不同等原因，不同的移植导致了WebKit不同版本行为不一致，它是不同浏览器性能和功能差异的关键部分。</li><li>WebKit嵌入式编程接口，供浏览器调用，与移植密切相关，不同的移植有不同的接口规范。</li><li>测试用例，包括布局测试用例和性能测试用例，用来验证渲染结果的正确性。</li></ul><h4 id="1-2-网页渲染流程"><a href="#1-2-网页渲染流程" class="headerlink" title="1.2.网页渲染流程"></a>1.2.网页渲染流程</h4><p>上面介绍了渲染引擎的各个模块，那么一张网页，要经历怎样的过程，才能抵达用户面前？</p><p><img src="https://pic4.zhimg.com/80/v2-ad0a86d3faf223164a9bd22658feadc3_720w.png" alt="https://pic4.zhimg.com/80/v2-ad0a86d3faf223164a9bd22658feadc3_720w.png"></p><p>首先是网页内容，输入到HTML解析器，HTML解析器解析，然后构建DOM树，在这期间如果遇到JavaScript代码则交给JavaScript引擎处理；如果来自CSS解析器的样式信息，构建一个内部绘图模型。该模型由布局模块计算模型内部各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。在网页渲染的过程中，大致可分为下面3个阶段。</p><h5 id="1-2-1-从输入URL到生成DOM树"><a href="#1-2-1-从输入URL到生成DOM树" class="headerlink" title="1.2.1.从输入URL到生成DOM树"></a>1.2.1.从输入URL到生成DOM树</h5><ol><li>地址栏输入URL，WebKit调用资源加载器加载相应资源；</li><li>加载器依赖网络模块建立连接，发送请求并接收答复；</li><li>WebKit接收各种网页或者资源数据，其中某些资源可能同步或异步获取；</li><li>网页交给HTML解析器转变为词语；</li><li>解释器根据词语构建节点，形成DOM树；</li><li>如果节点是JavaScript代码，调用JavaScript引擎解释并执行；</li><li>JavaScript代码可能会修改DOM树结构；</li><li>如果节点依赖其他资源，如图片\css、视频等，调用资源加载器加载它们，但这些是异步加载的，不会阻碍当前DOM树继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树创建，直到JavaScript加载并被JavaScript引擎执行后才继续DOM树的创建。</li></ol><h5 id="1-2-2-从DOM树到构建WebKit绘图上下文"><a href="#1-2-2-从DOM树到构建WebKit绘图上下文" class="headerlink" title="1.2.2.从DOM树到构建WebKit绘图上下文"></a>1.2.2.从DOM树到构建WebKit绘图上下文</h5><ol><li>CSS文件被CSS解释器解释成内部表示；</li><li>CSS解释器完成工作后，在DOM树上附加样式信息，生成RenderObject树；</li><li>RenderObject节点在创建的同时，WebKit会根据网页层次结构构建RenderLayer树，同时构建一个虚拟绘图上下文。</li></ol><h5 id="1-2-3-绘图上下文到最终图像呈现"><a href="#1-2-3-绘图上下文到最终图像呈现" class="headerlink" title="1.2.3.绘图上下文到最终图像呈现"></a>1.2.3.绘图上下文到最终图像呈现</h5><ol><li>绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类；</li><li>绘图实现类也可能有简单的实现，也可能有复杂的实现，软件渲染、硬件渲染、合成渲染等；</li><li>绘图实现类将2D图形库或者3D图形库绘制结果保存，交给浏览器界面进行展示。</li></ol><p>上述是一个完整的渲染过程，现代网页很多都是动态的，随着网页与用户的交互，浏览器需要不断的重复渲染过程。</p><h4 id="1-3-JavaScript引擎"><a href="#1-3-JavaScript引擎" class="headerlink" title="1.3.JavaScript引擎"></a>1.3.JavaScript引擎</h4><p><img src="https://pic1.zhimg.com/80/v2-0f5471e21a25e237dcfae2d34a306788_720w.png" alt="https://pic1.zhimg.com/80/v2-0f5471e21a25e237dcfae2d34a306788_720w.png"></p><p>JavaScript本质上是一种解释型语言，与编译型语言不同的是它需要一遍执行一边解析，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度(如上图所示)。JavaScript代码是在浏览器端解析和执行的，如果需要时间太长，会影响用户体验。那么提高JavaScript的解析速度就是当务之急。JavaScript引擎和渲染引擎的关系如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-43b71b75cd4f28db05ab967e3aad5a97_720w.png" alt="https://pic4.zhimg.com/80/v2-43b71b75cd4f28db05ab967e3aad5a97_720w.png"></p><p>JavaScript语言是解释型语言，为了提高性能，引入了Java虚拟机和C++编译器中的众多技术。现在JavaScript引擎的执行过程大致是：</p><p>源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码)。一段代码的抽象语法树示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象语法树如下：<br><img src="https://pic4.zhimg.com/80/v2-4ee7dc5c0787930c03ff203c41a1482b_720w.png" alt="https://pic4.zhimg.com/80/v2-4ee7dc5c0787930c03ff203c41a1482b_720w.png"></p><p>V8更加直接的将抽象语法树通过JIT技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。在V8生成本地代码后，也会通过Profiler采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化，但极大减少了转换时间。</p><p>但是在2017年4月底，v8 的 5.9 版本发布了，新增了一个 Ignition 字节码解释器，将默认启动，从此之后将与JSCore有大致相同的流程。做出这一改变的原因为：（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间；提高代码的启动速度；对 v8 的代码进行重构，降低 v8 的代码复杂度(<a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/topic/59084a9cbbaf2f3f569be482">V8 Ignition：JS 引擎与字节码的不解之缘 - CNode技术社区</a>)。</p><p>JavaScript的性能和C相比还有不小的距离，可预见的未来估计也只能接近它，而不是与它相比，这从语言类型上已经决定。下面将对V8引擎进行更为细致的介绍。</p><h3 id="2-V8引擎"><a href="#2-V8引擎" class="headerlink" title="2.V8引擎"></a>2.V8引擎</h3><p>V8引擎是一个JavaScript引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。V8使用C++开发，，在运行JavaScript之前，相比其它的JavaScript的引擎转换成字节码或解释执行，V8将其编译成原生机器码（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。V8支持众多操作系统，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的可移植和跨平台特性。<br>V8项目代码结构如下：</p><p><img src="https://pic4.zhimg.com/80/v2-cb5e37b2c362ad0335d6331ef3be6daf_720w.png" alt="https://pic4.zhimg.com/80/v2-cb5e37b2c362ad0335d6331ef3be6daf_720w.png"></p><h4 id="2-1-数据表示"><a href="#2-1-数据表示" class="headerlink" title="2.1.数据表示"></a>2.1.数据表示</h4><p>JavaScript是一种动态类型语言，在编译时并不能准确知道变量的类型，只可以在运行时确定，这就不像c++或者java等静态类型语言，在编译时候就可以确切知道变量的类型。然而，在运行时计算和决定类型，会严重影响语言性能，这也就是JavaScript运行效率比C++或者JAVA低很多的原因之一。</p><p>在C++中，源代码需要经过编译才能执行，在生成本地代码的过程中，变量的地址和类型已经确定，运行本地代码时利用数组和位移就可以存取变量和方法的地址，不需要再进行额外的查找，几个机器指令即可完成，节省了确定类型和地址的时间。由于JavaScript是无类型语言，那就不能像c++那样在执行时已经知道变量的类型和地址，需要临时确定。JavaScript 和C++有以下几个区别：</p><ul><li>编译确定位置，C++编译阶段确定位置偏移信息，在执行时直接存取，JavaScript在执行阶段确定，而且执行期间可以修改对象属性；</li><li>偏移信息共享，C++有类型定义，执行时不能动态改变，可共享偏移信息，JavaScript每个对象都是自描述，属性和位置偏移信息都包含在自身的结构中；</li><li>偏移信息查找，C++查找偏移地址很简单，在编译代码阶段，对使用的某类型成员变量直接设置偏移位置，JavaScript中使用一个对象，需要通过属性名匹配才能找到相应的值，需要更多的操作。<br>在代码执行过程中，变量的存取是非常普遍和频繁的，通过偏移量来存取，使用少数两个汇编指令就能完成，如果通过属性名匹配则需要更多的汇编指令，也需要更多的内存空间。示例如下：</li></ul><p><img src="https://pic3.zhimg.com/80/v2-794bcbcc25818b827d77ff712271ce56_720w.jpg" alt="https://pic3.zhimg.com/80/v2-794bcbcc25818b827d77ff712271ce56_720w.jpg"></p><p>在JavaScript中，除boolean，number，string，null，undefined这个五个简单变量外，其他的数据都是对象，V8使用一种特殊的方式来表示它们，进而优化JavaScript的内部表示问题。</p><p>在V8中，数据的内部表示由数据的实际内容和数据的句柄构成。数据的实际内容是变长的，类型也是不同的；句柄固定大小，包含指向数据的指针。这种设计可以方便V8进行垃圾回收和移动数据内容，如果直接使用指针的话就会出问题或者需要更大的开销，使用句柄的话，只需修改句柄中的指针即可，使用者使用的还是句柄，指针改动是对使用者透明的。</p><p>除少数数据(如整型数据)由handle本身存储外，其他内容限于句柄大小和变长等原因，都存储在堆中。整数直接从value中取值，然后使用一个指针指向它，可以减少内存的占用并提高访问速度。一个句柄对象的大小是4字节(32位设备)或者8字节(64位设备)，而在JavaScriptCore中，使用的8个字节表示句柄。在堆中存放的对象都是4字节对齐的，所以它们指针的后两位是不需要的，V8用这两位表示数据的类型，00为整数，01为其他。</p><p>JavaScript对象在V8中的实现包含三个部分：隐藏类指针，这是v8为JavaScript对象创建的隐藏类；属性值表指针，指向该对象包含的属性值；元素表指针，指向该对象包含的属性。</p><h4 id="2-2-工作过程"><a href="#2-2-工作过程" class="headerlink" title="2.2.工作过程"></a>2.2.工作过程</h4><p>前面有过介绍，V8引擎在执行JavaScript的过程中，主要有两个阶段：编译和运行，与C++的执行前完全编译不同的是，JavaScript需要在用户使用时完成编译和执行。在V8中，JavaScript相关代码并非一下完成编译的，而是在某些代码需要执行时，才会进行编译，这就提高了响应时间，减少了时间开销。在V8引擎中，源代码先被解析器转变为抽象语法树(AST)，然后使用JIT编译器的全代码生成器从AST直接生成本地可执行代码。这个过程不同于JAVA先生成字节码或中间表示，减少了AST到字节码的转换时间，提高了代码的执行速度。但由于缺少了转换为字节码这一中间过程，也就减少了优化代码的机会。</p><p>V8引擎编译本地代码时使用的主要类如下所示：</p><ul><li>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Compiler：编译器类，辅组Script类来编译生成代码，调用解释器(Parser)来生成AST和全代码生成器，将AST转变为本地代码；</li><li>AstNode：抽象语法树节点类，是其他所有节点的基类，包含非常多的子类，后面会针对不同的子类生成不同的本地代码；</li><li>AstVisitor：抽象语法树的访问者类，主要用来遍历异构的抽象语法树；</li><li>FullCodeGenerator：AstVisitor类的子类，通过遍历AST来为JavaScript生成本地可执行代码。</li></ul><p><img src="https://pic1.zhimg.com/80/v2-274bcd0e43b8b718ce58de8ae51e1b70_720w.png" alt="https://pic1.zhimg.com/80/v2-274bcd0e43b8b718ce58de8ae51e1b70_720w.png"></p><p>JavaScript代码编译的过程大致为：Script类调用Compiler类的Compile函数为其生成本地代码。Compile函数先使用Parser类生成AST，再使用FullCodeGenerator类来生成本地代码。本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。由于FullCodeGenerator通过遍历AST来为每个节点生成相应的汇编代码，缺失了全局视图，节点之间的优化也就无从谈起。</p><p>在执行编译之前，V8会构建众多全局对象并加载一些内置的库（如math库），来构建一个运行环境。而且在JavaScript源代码中，并非所有的函数都被编译生成本地代码，而是延迟编译，在调用时才会编译。</p><p>由于V8缺少了生成中间代码这一环节，缺少了必要的优化，为了提升性能，V8会在生成本地代码后，使用数据分析器(profiler)采集一些信息，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。同时，当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。下面介绍一下运行阶段，该阶段使用的主要类如下所示：</p><ul><li>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Execution：运行代码的辅组类，包含一些重要函数，如Call函数，它辅组进入和执行Script代码；</li><li>JSFunction：需要执行的JavaScript函数表示类；</li><li>Runtime：运行这些本地代码的辅组类，主要提供运行时所需的辅组函数，如：属性访问、类型转换、编译、算术、位操作、比较、正则表达式等；</li><li>Heap：运行本地代码需要使用的内存堆类；</li><li>MarkCompactCollector：垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程；</li><li>SweeperThread：负责垃圾回收的线程。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-d9eaec9f9912dd0e26c636675fe10fe3_720w.png" alt="https://pic4.zhimg.com/80/v2-d9eaec9f9912dd0e26c636675fe10fe3_720w.png"></p><p>先根据需要编译和生成这些本地代码，也就是使用编译阶段那些类和操作。在V8中，函数是一个基本单位，当某个JavaScript函数被调用时，V8会查找该函数是否已经生成本地代码，如果已经生成，则直接调用该函数。否则，V8引擎会生成属于该函数的本地代码。这就节约了时间，减少了处理那些使用不到的代码的时间。其次，执行编译后的代码为JavaScript构建JS对象，这需要Runtime类来辅组创建对象，并需要从Heap类分配内存。再次，借助Runtime类中的辅组函数来完成一些功能，如属性访问等。最后，将不用的空间进行标记清除和垃圾回收。</p><h4 id="2-3-优化回滚"><a href="#2-3-优化回滚" class="headerlink" title="2.3.优化回滚"></a>2.3.优化回滚</h4><p>因为V8是基于AST直接生成本地代码，没有经过中间表示层的优化，所以本地代码尚未经过很好的优化。于是，在2010年，V8引入了新的编译器-Crankshaft，它主要针对热点函数进行优化，基于JavaScript源代码开始分析而非本地代码，同时构建Hydroger图并基于此来进行优化分析。</p><p>Crankshaft编译器为了性能考虑，通常会做出比较乐观和大胆的预测—代码稳定且变量类型不变，所以可以生成高效的本地代码。但是，鉴于JavaScript的一个弱类型的语言，变量类型也可能在执行的过程中进行改变，鉴于这种情况，V8会将该编译器做的想当然的优化进行回滚，称为优化回滚。</p><p>示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">if</span> (counter &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'jeri'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> unknown = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(unknown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数被调用多次之后，V8引擎可能会触发Crankshaft编译器对其进行优化，而优化代码认为示例代码的类型信息都已经被确定。但，由于尚未真正执行到new Date()这个地方，并未获取unknown这个变量的类型，V8只得将该部分代码进行回滚。优化回滚是一个很耗时的操作，在写代码过程中，尽量不要触发优化该操作。</p><p>在最近发布的 V8 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译。这个版本中消除 Cranshaft 这个旧的编译器，并让新的 Turbofan 直接从字节码来优化代码，并当需要进行反优化的时候直接反优化到字节码，而不需要再考虑 JS 源代码。</p><h4 id="2-4-隐藏类与内嵌缓存"><a href="#2-4-隐藏类与内嵌缓存" class="headerlink" title="2.4.隐藏类与内嵌缓存"></a>2.4.隐藏类与内嵌缓存</h4><h5 id="2-4-1-隐藏类"><a href="#2-4-1-隐藏类" class="headerlink" title="2.4.1.隐藏类"></a>2.4.1.隐藏类</h5><p>在执行C++代码时，仅凭几个指令即可根据偏移信息获取变量信息，而JavaScript里需要通过字符串匹配来查找属性值的，这就需要更多的操作才能访问到变量信息，而代码量变量存取是十分频繁的，这也就制约了JavaScript的性能。V8借用了类和偏移位置的思想，将本来通过属性名匹配来访问属性值的方法进行了改进，使用类似C++编译器的偏移位置机制来实现，这就是隐藏类。</p><p>隐藏类将对象划分成不同的组，对于组内对象拥有相同的属性名和属性值的情况，将这些组的属性名和对应的偏移位置保存在一个隐藏类中，组内所有对象共享该信息。同时，也可以识别属性不同的对象。示例如下：</p><p><img src="https://pic2.zhimg.com/80/v2-bf67f5eb2667ddd86bfde785612aca35_720w.png" alt="https://pic2.zhimg.com/80/v2-bf67f5eb2667ddd86bfde785612aca35_720w.png"></p><p>使用Point构造了两个对象p和q，这两个对象具有相同的属性名，V8将它们归为同一个组，也就是隐藏类，这些属性在隐藏类中有相同的偏移值，p和q共享这一信息，进行属性访问时，只需根据隐藏类的偏移值即可。由于JavaScript是动态类型语言，在执行时可以更改变量的类型，如果上述代码执行之后，执行q.z=2，那么p和q将不再被认为是一个组，q将是一个新的隐藏类。</p><h5 id="2-4-2-内嵌缓存"><a href="#2-4-2-内嵌缓存" class="headerlink" title="2.4.2.内嵌缓存"></a>2.4.2.内嵌缓存</h5><p>正常访问对象属性的过程是：首先获取隐藏类的地址，然后根据属性名查找偏移值，然后计算该属性的地址。虽然相比以往在整个执行环境中查找减小了很大的工作量，但依然比较耗时。能不能将之前查询的结果缓存起来，供再次访问呢？当然是可行的，这就是内嵌缓存。</p><p>内嵌缓存的大致思路就是将初次查找的隐藏类和偏移值保存起来，当下次查找的时候，先比较当前对象是否是之前的隐藏类，如果是的话，直接使用之前的缓存结果，减少再次查找表的时间。当然，如果一个对象有多个属性，那么缓存失误的概率就会提高，因为某个属性的类型变化之后，对象的隐藏类也会变化，就与之前的缓存不一致，需要重新使用以前的方式查找哈希表。</p><h4 id="2-5-内存管理"><a href="#2-5-内存管理" class="headerlink" title="2.5.内存管理"></a>2.5.内存管理</h4><p>Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），其深层原因是 V8 垃圾回收机制的限制所致（如果可使用内存太大，V8在进行垃圾回收时需耗费更多的资源和时间，严重影响JS的执行效率）。下面对内存管理进行介绍。</p><p>内存的管理组要由分配和回收两个部分构成。V8的内存划分如下：</p><ul><li>Zone：管理小块内存。其先自己申请一块内存，然后管理和分配一些小内存，当一块小内存被分配之后，不能被Zone回收，只能一次性回收Zone分配的所有小内存。当一个过程需要很多内存，Zone将需要分配大量的内存，却又不能及时回收，会导致内存不足情况。</li><li>堆：管理JavaScript使用的数据、生成的代码、哈希表等。为方便实现垃圾回收，堆被分为三个部分：</li></ul><p>年轻分代：为新创建的对象分配内存空间，经常需要进行垃圾回收。为方便年轻分代中的内容回收，可再将年轻分代分为两半，一半用来分配，另一半在回收时负责将之前还需要保留的对象复制过来。<br>年老分代：根据需要将年老的对象、指针、代码等数据保存起来，较少地进行垃圾回收。<br>大对象：为那些需要使用较多内存对象分配内存，当然同样可能包含数据和代码等分配的内存，一个页面只分配一个对象。</p><p><img src="https://pic4.zhimg.com/80/v2-76f0fb426e86e9b54fecb6bef2582e8b_720w.png" alt="https://pic4.zhimg.com/80/v2-76f0fb426e86e9b54fecb6bef2582e8b_720w.png"></p><h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><p>V8 使用了分代和大数据的内存分配，在回收内存时使用精简整理的算法标记未引用的对象，然后消除没有标记的对象，最后整理和压缩那些还未保存的对象，即可完成垃圾回收。</p><p>在V8中，使用较多的是年轻分代和年老分代。年轻分代中的对象垃圾回收主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法：通过复制的方式实现的垃圾回收算法。它将堆内存分为两个 semispace，一个处于使用中（From空间），另一个处于闲置状态（To空间）。当分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。年轻分代中的对象有机会晋升为年老分代，条件主要有两个：一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。</p><p>对于年老分代中的对象，由于存活对象占较大比重，再采用上面的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，V8在年老分代中主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合的方式进行垃圾回收。</p><h4 id="2-6-快照"><a href="#2-6-快照" class="headerlink" title="2.6.快照"></a>2.6.快照</h4><p>在V8引擎启动时，需要构建JavaScript运行环境，需要加载很多内置对象，同时也需要建立内置的函数，如Array，String，Math等。为了使V8更加整洁，加载对象和建立函数等任务都是使用JavaScript文件来实现的，V8引擎负责提供机制来支持，就是在编译和执行JavaScript前先加载这些文件。</p><p>V8引擎需要编译和执行这些内置的JavaScript代码，同时使用堆等来保存执行过程中创建的对象、代码等，这些都需要时间。为此，V8引入了快照机制。将这些内置的对象和函数加载之后的内存保存并序列化。序列化之后的结果很容易反序列化，经过快照机制的启动时间可以缩减几毫秒。快照机制也可以将一些开发者认为需要的JavaScript文件序列化，以减少处理时间。不过快照机制的加载的代码不能被CrankShaft这样的编译器优化，可能会存在性能问题。</p><h3 id="3-V8-VS-JavaScriptCore"><a href="#3-V8-VS-JavaScriptCore" class="headerlink" title="3.V8 VS JavaScriptCore"></a>3.V8 VS JavaScriptCore</h3><p>JavaScriptCore引擎是WebKit中默认的JavaScript引擎，也是苹果开源的一个项目，应用较为广泛。最初，性能不是很好，从2008年开始了一系列的优化，重新实现了编译器和字节码解释器，使得引擎的性能有较大的提升。随后内嵌缓存、基于正则表达式的JIT、简单的JIT及字节码解释器等技术引入进来，JavaScriptCore引擎也在不断的迭代和发展。</p><p>V8引擎自诞生之日起就以性能优化作为目标，引入了众多新技术，极大了带动了整个业界JavaScript引擎性能的快速发展。总的来说，V8引擎较为激进，青睐可以提高性能的新技术，而JavaScriptCore引擎较为稳健，渐进式的改变着自己的性能。总的来说JavaScript引擎工作流程（包含v8和JavaScriptCore）如下所示：</p><p><img src="https://pic1.zhimg.com/80/v2-993bbf0a46f6feaef5f7b5005aa1aa34_720w.png" alt="https://pic1.zhimg.com/80/v2-993bbf0a46f6feaef5f7b5005aa1aa34_720w.png"></p><p>JavaScriptCore 的大致流程为：源代码-→抽象语法树-→字节码-→JIT-→本地代码。JavaScriptCore与V8有一些不同之处，其中最大的不同就是新增了字节码的中间表示，并加入了多层JIT编译器（如：简单JIT编译器、DFG JIT编译器、LLVM等）优化性能，不停的对本地代码进行优化。(<strong>在 V8 的 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译，此后 V8 将与 JavaScriptCore 有大致相同的流程，Node 8.0中 V8 版本为 5.8</strong>)</p><p>还有就是在数据表示方面，V8在不同的机器上使用与机器位数相匹配的数据表示，而在JavaScriptCore中句柄都是使用64位表示，其可以表示更大范围的数字，所以即使在32位机器上，浮点类型同样可以保存在句柄中，不再需要访问堆中的数据，当也会占用更多的空间。</p><h3 id="4-功能扩展"><a href="#4-功能扩展" class="headerlink" title="4.功能扩展"></a>4.功能扩展</h3><p>JavaScript引擎的主要功能是解析和执行JavaScript代码，往往不能满足使用者多样化的需要，那么就可以增加扩展以提升它的能力。V8引擎有两种扩展机制：绑定和扩展。</p><h4 id="4-1-绑定机制"><a href="#4-1-绑定机制" class="headerlink" title="4.1.绑定机制"></a>4.1.绑定机制</h4><p>使用IDL文件或接口文件生成绑定文件，将这些文件同V8引擎一起编译。WebKit中使用IDL来定义JavaScript，但又与IDL有所不同，有一些改变。定义一个新的接口的步骤大致如下：</p><ol><li><p>定义新的接口文件，可以在JavaScript代码进行调用，如mymodule.MyObj.myAttr；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module mymodule &#123;</span><br><span class="line">  interface [</span><br><span class="line">    InterfaceName &#x3D; MyObject</span><br><span class="line">  ] MyObj &#123; </span><br><span class="line">    readonly attribute long myAttr;</span><br><span class="line">    DOMString myMethod (DOMString myArg);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按照引擎定义的标准接口为基础实现接口类，生成JavaScript引擎所需的绑定文件。WebKit提供了工具帮助生成所需的绑定类，根据引擎不同和引擎开发语言的不同而有所差异。V8引擎会为上述示例代码生成 v8MyObj.h (MyObj类具体的实现代码)和 V8MyObj.cpp (桥接代码，辅组注册桥接的函数到V8引擎)两个绑定文件。</p></li></ol><p>JavaScript引擎绑定机制需要将扩展代码和JavaScript引擎一块编译和打包，不能根据需要在引擎启动后再动态注入这些本地代码。在实际WEB开发中，开发者都是基于现有浏览器的，根本不可能介入到JavaScript引擎的编译中，绑定机制有很大的局限性，但其非常高效，适用于对性能要求较高的场景。</p><h4 id="4-2-Extension机制"><a href="#4-2-Extension机制" class="headerlink" title="4.2. Extension机制"></a>4.2. Extension机制</h4><p>通过V8的基类Extension进行能力扩展，无需和V8引擎一起编译，可以动态为引擎增加功能特性，具有很大的灵活性。</p><p>Extension机制的大致思路就是，V8提供一个基类Extension和一个全局注册函数，要想扩展JavaScript能力，需要经过以下步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MYExtension : public v8::Extension &#123;</span><br><span class="line">  public:</span><br><span class="line">    MYExtension() : v8::Extension(&quot;v8&#x2F;My&quot;, &quot;native function my();&quot;) &#123;&#125;</span><br><span class="line">    virtual v8::Handle&lt;v8::FunctionTemplate&gt; GetNativeFunction (</span><br><span class="line">    v8::Handle&lt;v8::String&gt; name) &#123;</span><br><span class="line">      &#x2F;&#x2F; 可以根据name来返回不同的函数</span><br><span class="line">      return v8::FunctionTemplate::New(MYExtention::MY);</span><br><span class="line">    &#125;</span><br><span class="line">    static v8::Handle&lt;v8::Value&gt; MY(const v8::Arguments&amp; args) &#123;</span><br><span class="line">      &#x2F;&#x2F; Do sth here</span><br><span class="line">      return v8::Undefined();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MYExtension extension;</span><br><span class="line">RegisterExtension(&amp;extension);</span><br></pre></td></tr></table></figure><ol><li>基于Extension基类构建一个它的子类，并实现它的虚函数—GetNativeFunction，根据参数name来决定返回实函数；</li><li>创建一个该子类的对象，并通过注册函数将该对象注册到V8引擎，当JavaScript调用’my’函数时就可被调用到。</li></ol><p>Extension机制是调用V8的接口注入新函数，动态扩展非常方便，但没有绑定机制高效，适用于对性能要求不高的场景。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在过去几年，JavaScript在很多领域得到了广泛的应用，然而限于JavaScript语言本身的不足，执行效率不高。Google也推出了一些JavaScript网络应用，如Gmail、Google Maps及Google Docs office等。这些应用的性能不仅受到服务器、网络、渲染引擎以及其他诸多因素的影响，同时也受到JavaScript本身执行速度的影响。然而既有的JavaScript引擎无法满足新的需求，而性能不佳一直是网络应用开发者最关心的。Google就开始了V8引擎的研究，将一系列新技术引入JavaScript引擎中，大大提高了JavaScript的执行效率。相信随着V8引擎的不断发展，JavaScript也会有更广泛的应用场景，前端工程师也会有更好的未来！<br>那么结合上面对于V8引擎的介绍，我们在编程中应注意：</p><ul><li>类型。对于函数，JavaScript是一种动态类型语言，JavaScriptCore和V8都使用隐藏类和内嵌缓存来提高性能，为了保证缓存命中率，一个函数应该使用较少的数据类型；对于数组，应尽量存放相同类型的数据，这样就可以通过偏移位置来访问。</li><li>数据表示。简单类型数据（如整型）直接保存在句柄中，可以减少寻址时间和内存占用，如果可以使用整数表示的，尽量不要用浮点类型。</li><li>内存。虽然JavaScript语言会自己进行垃圾回收，但我们也应尽量做到及时回收不用的内存，对不再使用的对象设置为null或使用delete方法来删除(使用delete方法删除会触发隐藏类新建，需要更多的额外操作)。</li><li>优化回滚。在执行多次之后，不要出现修改对象类型的语句，尽量不要触发优化回滚，否则会大幅度降低代码的性能。</li><li>新机制。使用JavaScript引擎或者渲染引擎提供的新机制和新接口提高性能。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《WebKit技术内幕》</li><li>《JavaScript高级程序设计》</li><li>《深入浅出Node.js》</li></ul><p><a href="https://cnodejs.org/topic/59084a9cbbaf2f3f569be482" target="_blank" rel="noopener">V8 Ignition：JS 引擎与字节码的不解之缘 - CNode技术社区</a></p><blockquote><p>作者：默语<br>链接：<a href="https://zhuanlan.zhihu.com/p/27628685" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27628685</a><br>来源：知乎</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4dce785ff4595de55623611ab0055d33_1200x500.jpg&quot; alt=&quot;https://pic2.zhimg.com/v2-4dce785ff4595de55623611ab0055d33_1200x500.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;JavaScript绝对是最火的编程语言之一，一直具有很大的用户群，随着在服务端的使用（NodeJs），更是爆发了极强的生命力。编程语言分为编译型语言和解释型语言两类，编译型语言在执行之前要先进行完全编译，而解释型语言一边编译一边执行，很明显解释型语言的执行速度是慢于编译型语言的，而JavaScript就是一种解释型脚本语言，支持动态类型、弱类型、基于原型的语言，内置支持类型。鉴于JavaScript都是在前端执行，而且需要及时响应用户，这就要求JavaScript可以快速的解析及执行。&lt;/p&gt;
&lt;p&gt;随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，这就更需要快速的解析和执行JavaScript脚本。V8引擎就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript。&lt;/p&gt;
&lt;p&gt;V8是如何使得JavaScript性能有大幅提升的呢？通过对一些书籍和文章的学习，梳理了V8的相关内容，本文将带你认识 V8。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="V8" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/V8/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="V8" scheme="https://heiyehk.github.io/blog/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>CDN原理</title>
    <link href="https://heiyehk.github.io/blog/CDN%E5%8E%9F%E7%90%86/"/>
    <id>https://heiyehk.github.io/blog/CDN%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-20T07:30:35.000Z</published>
    <updated>2020-05-20T08:56:54.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传统网站访问方式"><a href="#传统网站访问方式" class="headerlink" title="传统网站访问方式"></a>传统网站访问方式</h3><p>由于互联网的飞速发展，越来越多的人开始使用并依赖网络，那在膨胀的用户群的现行的网络负载能力就形成了矛盾，人们开始希望网络更加的快速，而不是在无休止的等待中上网。这样CDN就得到了飞速的发展，那么问题就来了，CDN是如何来解决这个问题的呢?</p><p>传统的网站访问过程为:</p><ul><li>用户在浏览器中输入要访问的域名;</li><li>浏览器向域名解析服务器发出解析请求，获得此域名对应的IP 地址;</li><li>浏览器利用所得到的IP 地址，向该IP对应的服务器发出访问请求;</li><li>服务器对此响应，将数据回传至用户浏览器端显示出来。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-ca8f789d66f23fe6043356e255d07d25_720w.jpg" alt="https://pic2.zhimg.com/80/v2-ca8f789d66f23fe6043356e255d07d25_720w.jpg"></p><a id="more"></a><h3 id="CDN访问方式"><a href="#CDN访问方式" class="headerlink" title="CDN访问方式"></a>CDN访问方式</h3><p>与传统访问方式不同，CDN 网络则是在用户和服务器之间增加 Cache 层，将用户的访问请求引导到Cache 节点而不是服务器源站点，要实现这一目的，主要是通过接管DNS 实现。</p><p>使用CDN 缓存后的网站访问过程演变为：<br><img src="https://pic1.zhimg.com/80/v2-7b2506ccba72ac30c54e4cf74741beec_720w.jpg" alt="https://pic1.zhimg.com/80/v2-7b2506ccba72ac30c54e4cf74741beec_720w.jpg"></p><ol><li>用户在浏览器中输入要访问的域名;</li><li>浏览器向域名解析服务器发出解析请求，由于CDN 对域名解析过程进行了调整，所以用户端一般得到的是该域名对应的 CNAME 记录，此时浏览器需要再次对获得的 CNAME 域名进行解析才能得到缓存服务器实际的IP 地址。 注：在此过程中，全局负载均衡DNS 解析服务器会根据用户端的源IP 地址，如地理位置(北京还是上海)、接入网类型(电信还是网通)将用户的访问请求定位到离用户路由最短、位置最近、负载最轻的Cache 节点(缓存服务器)上，实现就近定位。定位优先原则可按位置、可按路由、也可按负载等。</li><li>再次解析后浏览器得到该域名CDN 缓存服务器的实际IP 地址，向缓存服务器发出访问请求;</li><li>缓存服务器根据浏览器提供的域名，通过Cache 内部专用DNS 解析得到此域名源服务器的真实IP 地址，再由缓存服务器向此真实IP 地址提交访问请求;</li><li>缓存服务器从真实IP 地址得到内容后，一方面在本地进行保存，以备以后使用，同时把得到的数据发送到客户端浏览器，完成访问的响应过程;</li><li>用户端得到由缓存服务器传回的数据后显示出来，至此完成整个域名访问过程。  </li></ol><p>通过以上分析可以看到，不论是否使用CDN 网络，普通用户客户端设置不需做任何改变，直接使用被加速网站原有域名访问即可。对于要加速的网站，只需修改整个访问过程中的域名解析部分，便能实现透明的网络加速服务。</p><p>CDN 速度快、传输安全、扩展性强，尤其在应对大容量迸发时游刃有余，主要应用于跨地域的门户及行业网站，如游戏、娱乐、IT、新闻传媒、VOD、远程教育、音视频、下载、IPTV、金融证券等。</p><p>CDN 网络，网站用户无需投资价值不菲的服务器、网络带宽及相应的人力成本，便能实现将网站内容发布到离终端用户距离最近、路由最短的网际边缘Cache 节点，创造完美、快捷的网站使用体验。</p><blockquote><p>链接: <a href="https://zhuanlan.zhihu.com/p/44966787" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44966787</a><br>来源: 知乎</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;传统网站访问方式&quot;&gt;&lt;a href=&quot;#传统网站访问方式&quot; class=&quot;headerlink&quot; title=&quot;传统网站访问方式&quot;&gt;&lt;/a&gt;传统网站访问方式&lt;/h3&gt;&lt;p&gt;由于互联网的飞速发展，越来越多的人开始使用并依赖网络，那在膨胀的用户群的现行的网络负载能力就形成了矛盾，人们开始希望网络更加的快速，而不是在无休止的等待中上网。这样CDN就得到了飞速的发展，那么问题就来了，CDN是如何来解决这个问题的呢?&lt;/p&gt;
&lt;p&gt;传统的网站访问过程为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户在浏览器中输入要访问的域名;&lt;/li&gt;
&lt;li&gt;浏览器向域名解析服务器发出解析请求，获得此域名对应的IP 地址;&lt;/li&gt;
&lt;li&gt;浏览器利用所得到的IP 地址，向该IP对应的服务器发出访问请求;&lt;/li&gt;
&lt;li&gt;服务器对此响应，将数据回传至用户浏览器端显示出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-ca8f789d66f23fe6043356e255d07d25_720w.jpg&quot; alt=&quot;https://pic2.zhimg.com/80/v2-ca8f789d66f23fe6043356e255d07d25_720w.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="CDN" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/CDN/"/>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="CDN" scheme="https://heiyehk.github.io/blog/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>面试灵魂十大问，你们都会回答了吗？</title>
    <link href="https://heiyehk.github.io/blog/%E9%9D%A2%E8%AF%95%E7%81%B5%E9%AD%82%E5%8D%81%E5%A4%A7%E9%97%AE%EF%BC%8C%E4%BD%A0%E4%BB%AC%E9%83%BD%E4%BC%9A%E5%9B%9E%E7%AD%94%E4%BA%86%E5%90%97%EF%BC%9F/"/>
    <id>https://heiyehk.github.io/blog/%E9%9D%A2%E8%AF%95%E7%81%B5%E9%AD%82%E5%8D%81%E5%A4%A7%E9%97%AE%EF%BC%8C%E4%BD%A0%E4%BB%AC%E9%83%BD%E4%BC%9A%E5%9B%9E%E7%AD%94%E4%BA%86%E5%90%97%EF%BC%9F/</id>
    <published>2020-04-30T09:03:48.000Z</published>
    <updated>2020-04-30T09:27:49.165Z</updated>
    
    <content type="html"><![CDATA[<ul><li>你最大的优点和缺点</li><li>你是否接受加班？</li><li>你对薪资有什么要求吗？</li><li>在五年的时间内，你的职业规划？</li><li>我们为什么要聘用你？</li><li>你对于我们公司了解多少？</li><li>你为什么愿意到我们公司？</li><li>与上级意见不一致，如何处理？</li><li>你缺乏工作经验，如何能胜任这份工作？</li><li>工作中与同事发生争执，你会怎么处理？</li></ul><a id="more"></a><h3 id="下面来带大家看看，如何轻松拆解十大问"><a href="#下面来带大家看看，如何轻松拆解十大问" class="headerlink" title="下面来带大家看看，如何轻松拆解十大问"></a>下面来带大家看看，如何轻松拆解十大问</h3><h4 id="1-你最大的优点和缺点"><a href="#1-你最大的优点和缺点" class="headerlink" title="1.你最大的优点和缺点"></a>1.你最大的优点和缺点</h4><p><strong>谈优点</strong></p><p>不要笼统地说自己的优点，例如助人为乐，善解人意这些，没有意义。需要根据应聘岗位所需的特性有针对性地谈自己的有点。例如应聘产品经理，优点为逻辑能力强、善于与人沟通；应聘运营，优点为善于站在他人的角度为人着想，善于与人打交道等等。</p><p><strong>谈缺点需要注意2点</strong></p><p>1）避免谈职业致命缺点，比如：应聘产品经理，你说自己的缺点是思维混乱、没有时间观念，性格内向，那基本上就GG了<br>2）避免避重就轻，谈不算缺点的缺点，比如：工作进度快，容易让其他同事赶不上进度这些<br>可以谈已经找到方法并正在改正的缺点，并说清楚自己的改正计划，或者谈一个利用你的优点改正的缺点，顺便带出自己的一个优点等。例如：喜欢追求完美，导致任务延期，已经通过学习时间管理，有意识地改变工作方式，争取如期完成自己的工作</p><h4 id="2-你是否接受加班？"><a href="#2-你是否接受加班？" class="headerlink" title="2.你是否接受加班？"></a>2.你是否接受加班？</h4><p>面试官这样问，一般有2个意图。一就是公司经常加班，需要你明确表达个人意愿；二就是公司只是想了解你对这个问题的个人看法，以及你的工作态度。</p><p><strong>对于这种问题，作死的回答是：</strong></p><ul><li>我无条件接受加班</li><li>我会在工作时间完成自己的工作</li><li>我不喜欢加班，不能接受加班</li></ul><p>前两个回答太绝对，可信度不高，面试官也不会相信这个答案，最后的回答，大家都懂，没有面试官喜欢听到这样的答案。</p><p>建议大家回答的时候遵循以下原则：</p><ul><li><p>从言语中体现自己的抗压能力、责任心、以及工作效率</p></li><li><p>强调工作需要，表现出积极心态，对于加班，具体情况具体对待。</p></li></ul><p>大家可以这样机智回答：我很愿意接受挑战，但我会提高工作时间的效率，争取在规定的时间内完成工作。但如果工作任务紧急，我愿意和同事们一起加班完成工作，这也是我个人职责。</p><h4 id="3-你对薪资有什么要求吗？"><a href="#3-你对薪资有什么要求吗？" class="headerlink" title="3.你对薪资有什么要求吗？"></a>3.你对薪资有什么要求吗？</h4><p>这个问题往往是求职者认为很难回答的一个问题，说高了怕丢了offer，说低了，自己不愿意。有的同学干脆会说自己不太追求薪资，对薪资没要求。这样的回答，不仅让面试官觉得你对行业薪资没有最基本的认知，甚至认为你对自己没有信心，不敢谈薪资。</p><p>大家可以在面试前多去了解自己应聘的行业、企业、岗位的大概薪资范围，再自我评估一下自己各方面的条件，定一个自己满意的薪资区间。最后再现场评估自己面试的表现，面试官的态度，觉得有把握，可以在预设好薪资区间内多要点，反之可以保守一些。</p><h4 id="4-在五年的时间内，你的职业规划？"><a href="#4-在五年的时间内，你的职业规划？" class="headerlink" title="4.在五年的时间内，你的职业规划？"></a>4.在五年的时间内，你的职业规划？</h4><p>一个对未来有规划的人，会认真踏实地工作，并有意识地提升自己，这是面试官需要确认的。这个问题需要你对该岗位的职业发展路径有一定的了解，知道晋升路径、花费的时间以及相应的能力需求。可以做以时间线做一个规划，例如1-3年，如何培养自己的什么技能、晋升为什么岗位。</p><h4 id="5-我们为什么要聘用你？"><a href="#5-我们为什么要聘用你？" class="headerlink" title="5.我们为什么要聘用你？"></a>5.我们为什么要聘用你？</h4><p>这句话的潜台词是“你凭什么胜任这个岗位”，这时候你就要向面试官展现出你的能力了。</p><p>一般可以围绕以下三回答这个问题：</p><ul><li><p>强调自己的能力与职位匹配，用数据、实例来证明自己可以胜任这个职位。</p></li><li><p>描述你加入公司后能为公司带来什么，要达成什么的目标，为公司业绩带来多少增长等。</p></li><li><p>展现自己的与职位相关的自身优势。</p></li></ul><h4 id="6-你对于我们公司了解多少？"><a href="#6-你对于我们公司了解多少？" class="headerlink" title="6.你对于我们公司了解多少？"></a>6.你对于我们公司了解多少？</h4><p>这个问题就很难有当场取巧的回答方式了，建议大家应聘前要提前做好功课，到百度或者公司官网上了解一下该公司大概情况，例如：主营业务、近几年的重点业务、发展方向，近期的重大战略调整等等。</p><h4 id="7-你为什么愿意到我们公司？"><a href="#7-你为什么愿意到我们公司？" class="headerlink" title="7.你为什么愿意到我们公司？"></a>7.你为什么愿意到我们公司？</h4><p>面试官想通过你的回答了解2点。第一点是你的求职动机。第二点是你对企业是否有一定的了解。</p><p>那要怎么进行回答呢，建议从行业、企业、岗位三个角度去回答</p><ul><li><p><strong>行业层面</strong>：通过宏观分析行业情况，表达你对行业发展前景的看好以及个人喜欢这个行业</p></li><li><p><strong>企业层面</strong>：提前熟悉公司的基本情况，表达出你对公司哪一方面的认同和赞赏（氛围/工作环境/发展前景等等）。</p></li><li><p><strong>岗位层面</strong>：充分了解应聘岗位的实际情况、职能范围与能力要求，表达自己对岗位的喜欢，并通过展现自己的自身优势，说服面试官你适合这个岗位。</p></li></ul><h4 id="8-与上级意见不一致，如何处理？"><a href="#8-与上级意见不一致，如何处理？" class="headerlink" title="8.与上级意见不一致，如何处理？"></a>8.与上级意见不一致，如何处理？</h4><p>面试官希望通过这个问题，了解你为人处世，沟通交流的能力。</p><p>回答可以围绕这几个点进行展开：具体情况具体分析、沟通、换位思考、尊重</p><p>可以这样回答：首先我会尊重上级的意见，对于非原则性问题，我会选择去服从上级的安排。但对于涉及公司利益或者其他重大性的问题，我会选择换位思考，了解上级的想法后去和上级进行积极的沟通，告诉他我的想法，给予上级一些建议。</p><h4 id="9-你缺乏工作经验，如何能胜任这份工作？"><a href="#9-你缺乏工作经验，如何能胜任这份工作？" class="headerlink" title="9.你缺乏工作经验，如何能胜任这份工作？"></a>9.你缺乏工作经验，如何能胜任这份工作？</h4><p>遇到这个问题，大家不需要惊慌，因为大家都是应届生，没有工作经验是很正常的。只需要回答的时候能给出一个令人信服的答案即可。首先要谦虚地承认自己地经验不足，然后可以谈一下自己对岗位地理解，并表示出自己正在不断地学习，并举出实例。如果有相关地实习、项目经历，也可用来进行分析，充分展示自己。最后可以表明一下自己的决心。</p><h4 id="10-工作中与同事发生争执，你会怎么处理？"><a href="#10-工作中与同事发生争执，你会怎么处理？" class="headerlink" title="10.工作中与同事发生争执，你会怎么处理？"></a>10.工作中与同事发生争执，你会怎么处理？</h4><p>工作中遇到争执、意见不统一是经常事情，面试官想通过这个问题，了解你的处事能力，能不能很好地处理同事问题。</p><p><strong>回答问题事抓住3点即可：</strong></p><ol><li>积极与同事进行沟通，并会在沟通前做好准备，对工作进行梳理，看看哪里有问题，提高沟通时的效率</li><li>沟通的时候多去倾听同事的意见，并作深入的思考，不会固执己见，不会一味盲目地坚持自己的管的</li><li>会通过一些数据、事实去印证自己观点，说服同事</li></ol><blockquote><p>作者：憨憨李<br>链接：<a href="https://www.nowcoder.com/discuss/414288" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/414288</a><br>来源：牛客网</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;你最大的优点和缺点&lt;/li&gt;
&lt;li&gt;你是否接受加班？&lt;/li&gt;
&lt;li&gt;你对薪资有什么要求吗？&lt;/li&gt;
&lt;li&gt;在五年的时间内，你的职业规划？&lt;/li&gt;
&lt;li&gt;我们为什么要聘用你？&lt;/li&gt;
&lt;li&gt;你对于我们公司了解多少？&lt;/li&gt;
&lt;li&gt;你为什么愿意到我们公司？&lt;/li&gt;
&lt;li&gt;与上级意见不一致，如何处理？&lt;/li&gt;
&lt;li&gt;你缺乏工作经验，如何能胜任这份工作？&lt;/li&gt;
&lt;li&gt;工作中与同事发生争执，你会怎么处理？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://heiyehk.github.io/blog/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://heiyehk.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中常见设计模式整理</title>
    <link href="https://heiyehk.github.io/blog/JavaScript-%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/"/>
    <id>https://heiyehk.github.io/blog/JavaScript-%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/</id>
    <published>2020-04-30T08:42:27.000Z</published>
    <updated>2020-05-20T08:57:25.957Z</updated>
    
    <content type="html"><![CDATA[<p>开发中，我们或多或少地接触了设计模式，但是很多时候不知道自己使用了哪种设计模式或者说该使用何种设计模式。本文意在梳理常见设计模式的特点，从而对它们有比较清晰的认知。</p><h3 id="JavaScript-中常见设计模式"><a href="#JavaScript-中常见设计模式" class="headerlink" title="JavaScript 中常见设计模式"></a>JavaScript 中常见设计模式</h3><a id="more"></a><ul><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">单例模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">策略模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">代理模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">迭代器模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">发布-订阅模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">命令模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">组合模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">模板方法模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">享元模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">职责链模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">中介者模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">装饰者模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">状态模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">适配者模式</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">观察者模式</a></li></ul><h3 id="各设计模式关键词"><a href="#各设计模式关键词" class="headerlink" title="各设计模式关键词"></a>各设计模式关键词</h3><p>看完了上述设计模式后，把它们的关键词特点罗列出来，以后提到某种设计模式，进而联想相应的关键词和例子，从而心中有数。</p><table><thead><tr><th>设计模式</th><th>特点</th><th>案例</th></tr></thead><tbody><tr><td>单例模式</td><td>一个类只能构造出唯一实例</td><td>创建菜单对象</td></tr><tr><td>策略模式</td><td>根据不同参数可以命中不同的策略</td><td>动画库里的算法函数</td></tr><tr><td>代理模式</td><td>代理对象和本体对象具有一致的接口</td><td>图片预加载</td></tr><tr><td>迭代器模式</td><td>能获取聚合对象的顺序和元素</td><td>each([1, 2, 3], cb)</td></tr><tr><td>发布-订阅模式</td><td>PubSub</td><td>瀑布流库</td></tr><tr><td>命令模式</td><td>不同对象间约定好相应的接口</td><td>按钮和命令的分离</td></tr><tr><td>组合模式</td><td>组合模式在对象间形成一致对待的树形结构</td><td>扫描文件夹</td></tr><tr><td>模板方法模式</td><td>父类中定好执行顺序</td><td>咖啡和茶</td></tr><tr><td>享元模式</td><td>减少创建实例的个数</td><td>男女模具试装</td></tr><tr><td>职责链模式</td><td>通过请求第一个条件，会持续执行后续的条件，直到返回结果为止</td><td>if else 优化</td></tr><tr><td>中介者模式</td><td>对象和对象之间借助第三方中介者进行通信</td><td>测试结束告知结果</td></tr><tr><td>装饰者模式</td><td>动态地给函数赋能</td><td>天冷了穿衣服，热了脱衣服</td></tr><tr><td>状态模式</td><td>每个状态建立一个类，状态改变会产生不同行为</td><td>电灯换挡</td></tr><tr><td>适配者模式</td><td>一种数据结构改成另一种数据结构</td><td>枚举值接口变更</td></tr><tr><td>观察者模式</td><td>当观察对象发生变化时自动调用相关函数</td><td>vue 双向绑定</td></tr></tbody></table><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote><p>《JavaScript设计模式与开发实践》</p></blockquote><blockquote><p>作者：牧云云<br>链接：<a href="https://juejin.im/post/5afe6430518825428630bc4d" target="_blank" rel="noopener">https://juejin.im/post/5afe6430518825428630bc4d</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中，我们或多或少地接触了设计模式，但是很多时候不知道自己使用了哪种设计模式或者说该使用何种设计模式。本文意在梳理常见设计模式的特点，从而对它们有比较清晰的认知。&lt;/p&gt;
&lt;h3 id=&quot;JavaScript-中常见设计模式&quot;&gt;&lt;a href=&quot;#JavaScript-中常见设计模式&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中常见设计模式&quot;&gt;&lt;/a&gt;JavaScript 中常见设计模式&lt;/h3&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
      <category term="设计模式" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/tags/js/"/>
    
      <category term="设计模式" scheme="https://heiyehk.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端面试：谈谈 JS 垃圾回收机制</title>
    <link href="https://heiyehk.github.io/blog/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%EF%BC%9A%E8%B0%88%E8%B0%88-JS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://heiyehk.github.io/blog/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%EF%BC%9A%E8%B0%88%E8%B0%88-JS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-30T08:25:16.000Z</published>
    <updated>2020-05-20T08:55:54.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。</p><p>当不再需要某样东西时会发生什么? JavaScript 引擎是如何发现并清理它?</p><h3 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h3><p>JavaScript 中内存管理的主要概念是可达性。</p><a id="more"></a><p>简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。</p><ol><li>有一组基本的固有可达值，由于显而易见的原因无法删除。例如:<ul><li>本地函数的局部变量和参数</li><li>当前嵌套调用链上的其他函数的变量和参数</li><li>全局变量</li><li>还有一些其他的，内部的</li></ul></li></ol><p><strong>这些值称为根。</strong></p><ol start="2"><li>如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。</li></ol><p>例如，如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为可达性， 它引用的那些也是可以访问的，详细的例子如下。</p><p>JavaScript 引擎中有一个后台进程称为<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="noopener">垃圾回收器</a>，它监视所有对象，并删除那些不可访问的对象。</p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>下面是最简单的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user 具有对象的引用</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://image-static.segmentfault.com/289/469/2894691528-5c92e57b9339d_articlex" alt="例子"></p><p>这里箭头表示一个对象引用。全局变量“user”引用对象 {name:“John”} (为了简洁起见，我们将其命名为John)。John 的 “name” 属性存储一个基本类型，因此它被绘制在对象中。</p><p>如果 user 的值被覆盖，则引用丢失:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://image-static.segmentfault.com/138/680/1386806337-5c93267a5206f_articlex" alt="例子"></p><p>现在 John 变成不可达的状态，没有办法访问它，没有对它的引用。垃圾回收器将丢弃 John 数据并释放内存。</p><h3 id="两个引用"><a href="#两个引用" class="headerlink" title="两个引用"></a>两个引用</h3><p>现在让我们假设我们将引用从 user 复制到 admin:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user具有对象的引用</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = user;</span><br></pre></td></tr></table></figure><p><img src="https://image-static.segmentfault.com/133/655/133655656-5c9327b57caa3_articlex" alt="例子"></p><p>现在如果我们做同样的事情:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>该对象仍然可以通过 admin 全局变量访问，所以它在内存中。如果我们也覆盖admin，那么它可以被释放。</p><h3 id="相互关联的对象"><a href="#相互关联的对象" class="headerlink" title="相互关联的对象"></a>相互关联的对象</h3><p>现在来看一个更复杂的例子， family 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">marry</span> (<span class="params">man, woman</span>) </span>&#123;</span><br><span class="line">  woman.husban = man;</span><br><span class="line">  man.wife = woman;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    father: man,</span><br><span class="line">    mother: woman</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> family = marry(&#123;</span><br><span class="line">  name: <span class="string">"John"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: <span class="string">"Ann"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>函数 <code>marry</code> 通过给两个对象彼此提供引用来“联姻”它们，并返回一个包含两个对象的新对象。</p><p>产生的内存结构:</p><p><img src="https://image-static.segmentfault.com/447/270/447270667-5c9329b9e28bb_articlex" alt="结构"></p><p>到目前为止，所有对象都是可访问的。</p><p>现在让我们删除两个引用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> family.father;</span><br><span class="line"><span class="keyword">delete</span> family.mother.husband;</span><br></pre></td></tr></table></figure><p><img src="https://image-static.segmentfault.com/359/593/3595939355-5c932ad1e5d2d_articlex" alt="流程"></p><p>仅仅删除这两个引用中的一个是不够的，因为所有对象仍然是可访问的。</p><p>但是如果我们把这两个都删除，那么我们可以看到 John 不再有传入的引用:</p><p><img src="https://image-static.segmentfault.com/162/805/1628058185-5c932b9750b6d_articlex" alt="流程"></p><p>输出引用无关紧要。只有传入的对象才能使对象可访问，因此，John 现在是不可访问的，并将从内存中删除所有不可访问的数据。</p><p>垃圾回收之后：</p><p><img src="https://image-static.segmentfault.com/129/587/1295875551-5c932c350dd1e_articlex" alt="流程"></p><h3 id="无法访问的数据块"><a href="#无法访问的数据块" class="headerlink" title="无法访问的数据块"></a>无法访问的数据块</h3><p>有可能整个相互连接的对象变得不可访问并从内存中删除。</p><p>源对象与上面的相同。然后:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">family = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>内存中的图片变成:</p><p><img src="https://image-static.segmentfault.com/420/035/420035998-5c932d8f3b867_articlex" alt="流程"></p><p>这个例子说明了可达性的概念是多么重要。</p><p>很明显，John和Ann仍然链接在一起，都有传入的引用。但这还不够。</p><p>“family”对象已经从根上断开了链接，不再有对它的引用，因此下面的整个块变得不可到达，并将被删除。</p><h3 id="内部算法"><a href="#内部算法" class="headerlink" title="内部算法"></a>内部算法</h3><p>基本的垃圾回收算法称为<strong>*“标记-清除”</strong>，定期执行以下“垃圾回收”步骤:</p><ul><li>垃圾回收器获取根并<strong>“标记”</strong>(记住)它们。</li><li>然后它访问并“标记”所有来自它们的引用。</li><li>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</li><li>以此类推，直到有未访问的引用(可以从根访问)为止。</li><li>除标记的对象外，所有对象都被删除。</li></ul><p>例如，对象结构如下:</p><p><img src="https://image-static.segmentfault.com/170/734/1707342869-5c9358c332559_articlex" alt="结构"></p><p>我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看<strong>“标记并清除”</strong>垃圾回收器如何处理它。</p><h4 id="第一步标记根"><a href="#第一步标记根" class="headerlink" title="第一步标记根"></a>第一步标记根</h4><p><img src="https://image-static.segmentfault.com/269/043/269043904-5c9359379ef4a_articlex" alt="标记"></p><h4 id="然后标记他们的引用"><a href="#然后标记他们的引用" class="headerlink" title="然后标记他们的引用"></a>然后标记他们的引用</h4><p><img src="https://image-static.segmentfault.com/423/514/4235146972-5c9359632ee4e_articlex" alt="引用"></p><h4 id="以及子孙代的引用"><a href="#以及子孙代的引用" class="headerlink" title="以及子孙代的引用:"></a>以及子孙代的引用:</h4><p><img src="https://image-static.segmentfault.com/198/890/1988905638-5c9359b1138ea_articlex" alt="引用"></p><h4 id="现在进程中不能访问的对象被认为是不可访问的，将被删除"><a href="#现在进程中不能访问的对象被认为是不可访问的，将被删除" class="headerlink" title="现在进程中不能访问的对象被认为是不可访问的，将被删除:"></a>现在进程中不能访问的对象被认为是不可访问的，将被删除:</h4><p><img src="https://image-static.segmentfault.com/434/932/434932871-5c9359fc2ac1b_articlex" alt="引用"></p><p>这就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。</p><p>一些优化:</p><ul><li><code>分代回收</code>——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。</li><li><code>增量回收</code>——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。</li><li><code>空闲时间收集</code>——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。</li></ul><h3 id="面试怎么回答"><a href="#面试怎么回答" class="headerlink" title="面试怎么回答"></a>面试怎么回答</h3><h4 id="1）问什么是垃圾"><a href="#1）问什么是垃圾" class="headerlink" title="1）问什么是垃圾"></a>1）问什么是垃圾</h4><p>一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。</p><h4 id="2）如何检垃圾"><a href="#2）如何检垃圾" class="headerlink" title="2）如何检垃圾"></a>2）如何检垃圾</h4><p>一种算法是标记 <code>标记-清除</code> 算法，还想说出不同的算法可以参考<a href="https://www.jianshu.com/p/a8a04fd00c3c" target="_blank" rel="noopener">这里</a>。</p><p>更深入一些的讲解 <a href="http://newhtml.net/v8-garbage-collection/" target="_blank" rel="noopener">http://newhtml.net/v8-garbage…</a></p><p>还有一种牛逼的答法就是说看我的博客，当然是要自己总结的博客。</p><p>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href="https://www.fundebug.com/?utm_source=xiaozhi" target="_blank" rel="noopener">Fundebug</a>。</p><blockquote><p>作者：前端小智<br>链接：<a href="https://segmentfault.com/a/1190000018605776" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018605776</a><br>来源：思否</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;垃圾回收&quot;&gt;&lt;a href=&quot;#垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收&quot;&gt;&lt;/a&gt;垃圾回收&lt;/h3&gt;&lt;p&gt;JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。&lt;/p&gt;
&lt;p&gt;当不再需要某样东西时会发生什么? JavaScript 引擎是如何发现并清理它?&lt;/p&gt;
&lt;h3 id=&quot;可达性&quot;&gt;&lt;a href=&quot;#可达性&quot; class=&quot;headerlink&quot; title=&quot;可达性&quot;&gt;&lt;/a&gt;可达性&lt;/h3&gt;&lt;p&gt;JavaScript 中内存管理的主要概念是可达性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
      <category term="垃圾回收" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="js底层" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/js/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/js%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://heiyehk.github.io/blog/tags/js/"/>
    
      <category term="垃圾回收" scheme="https://heiyehk.github.io/blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="js底层" scheme="https://heiyehk.github.io/blog/tags/js%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="https://heiyehk.github.io/blog/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://heiyehk.github.io/blog/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2020-04-30T07:25:00.000Z</published>
    <updated>2020-05-20T08:06:22.484Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在md中你需要某个字符或标签不被编译的话在前面加上<code>\</code>斜杠<br>MarkDown在线编辑器<br><a href="http://mahua.jser.me/" target="_blank" rel="noopener">MaHua 在线markdown编辑器</a><br><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">Cmd Markdown 编辑阅读器 - 作业部落出品</a>  </p></blockquote><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># h1</span></span><br><span class="line"><span class="section">## h2</span></span><br><span class="line"><span class="section">### h3</span></span><br><span class="line">....</span><br><span class="line"><span class="section">###### h6</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**加粗**</span></span><br></pre></td></tr></table></figure><p>示例: <strong>加粗后</strong></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br></pre></td></tr></table></figure><p>示例: <em>斜体</em></p><h3 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">***斜体加粗**</span>*</span><br></pre></td></tr></table></figure><p>示例: <strong><em>斜体加粗</em></strong></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>示例: <del>删除线</del></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用</span></span><br><span class="line">&gt;&gt; 可以嵌套</span><br></pre></td></tr></table></figure><blockquote><p>示例: 引用</p><blockquote><p>可以嵌套</p></blockquote></blockquote><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以下字符都需要3个以上</span><br><span class="line">---</span><br><span class="line"><span class="emphasis">***</span></span><br></pre></td></tr></table></figure><p>示例: </p><hr><hr><h3 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">summary</span>&gt;</span></span>折叠文本<span class="xml"><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span></span><br><span class="line">  此处可书写文本  </span><br><span class="line">  </span><br><span class="line">  嗯，是可以书写文本的</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">summary</span>&gt;</span></span>折叠代码块<span class="xml"><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span></span><br><span class="line">  <span class="code">```</span> js</span><br><span class="line">  console.log(1)</span><br></pre></td></tr></table></figure></details>示例：<details>  <summary>折叠文本</summary>  此处可书写文本  <p>  嗯，是可以书写文本的</p></details><details>  <summary>折叠代码块</summary>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">图片alt就是当图片不能显示或者显示错误时的文字，图片title可选</span><br><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 '图片title'</span>)</span><br></pre></td></tr></table></figure><p>示例: <img src="http://heiyehk.top/public/img/logo.jpg" alt="图片alt" title="title"></p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title可选</span><br><span class="line">[<span class="string">超链接文案</span>](<span class="link">地址 'title'</span>)</span><br></pre></td></tr></table></figure><p>示例: <a href="https://www.baidu.com" target="_blank" rel="noopener" title="百度">baidu</a></p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">记得符号后面有个空格,嵌套换行加空格再加符号空格的方式</span><br><span class="line"><span class="bullet">- </span>内容</span><br><span class="line"><span class="bullet">  - </span>嵌套内容</span><br><span class="line"><span class="bullet">+ </span>内容</span><br><span class="line"><span class="bullet">* </span>内容</span><br></pre></td></tr></table></figure><p>示例:</p><ul><li>减号内容<ul><li>嵌套内容</li></ul></li></ul><ul><li>加号内容</li></ul><ul><li>星号内容</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>需要注意的是,不同的编辑器和编译md方式不一样,那么使用方法也不一样,有些不能使用有序嵌套</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数字加点加空格,嵌套换行加空格再加符号空格的方式</span><br><span class="line"><span class="bullet">1. </span>第一</span><br><span class="line"><span class="bullet"> 1. </span>第一个中的第一个</span><br><span class="line"><span class="bullet">2. </span>第二</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>示例:</p><ol><li>第一个<ol><li>第一个中的第一个</li></ol></li><li>第二个</li></ol><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表格内容允许为空</span><br><span class="line">标题1 | 标题2 | 标题3</span><br><span class="line">-|-|-</span><br><span class="line">内容1 | 内容2 | 内容3</span><br><span class="line"> | 内容2 |</span><br></pre></td></tr></table></figure><p>示例:</p><table><thead><tr><th>标题1</th><th>标题2</th><th>标题3</th></tr></thead><tbody><tr><td>内容1</td><td>内容2</td><td>内容3</td></tr><tr><td></td><td>内容2</td><td></td></tr></tbody></table><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`高亮内容`</span></span><br></pre></td></tr></table></figure><p>示例: <code>高亮</code></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">去掉多余的\</span><br><span class="line"><span class="code">```</span> js</span><br><span class="line">var a = 0;</span><br><span class="line">console.log(a);</span><br><span class="line">\</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line">\</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = <span class="number">1</span></span><br><span class="line">strs = <span class="string">'aaa'</span></span><br><span class="line">\</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; js</span><br><span class="line">var a &#x3D; 0;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 1<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = <span class="number">1</span></span><br><span class="line">strs = <span class="string">'aaa'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在md中你需要某个字符或标签不被编译的话在前面加上&lt;code&gt;\&lt;/code&gt;斜杠&lt;br&gt;MarkDown在线编辑器&lt;br&gt;&lt;a href=&quot;http://mahua.jser.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MaHua 在线markdown编辑器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zybuluo.com/mdeditor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cmd Markdown 编辑阅读器 - 作业部落出品&lt;/a&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h3&gt;&lt;figure class=&quot;highlight md&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;# h1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;## h2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;### h3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;###### h6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="MarkDown" scheme="https://heiyehk.github.io/blog/categories/MarkDown/"/>
    
    
      <category term="MarkDown" scheme="https://heiyehk.github.io/blog/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>JS事件循环机制（event loop）之宏任务/微任务</title>
    <link href="https://heiyehk.github.io/blog/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%EF%BC%88event-loop%EF%BC%89%E4%B9%8B%E5%AE%8F%E4%BB%BB%E5%8A%A1-%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <id>https://heiyehk.github.io/blog/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%EF%BC%88event-loop%EF%BC%89%E4%B9%8B%E5%AE%8F%E4%BB%BB%E5%8A%A1-%E5%BE%AE%E4%BB%BB%E5%8A%A1/</id>
    <published>2020-04-30T06:39:18.000Z</published>
    <updated>2020-05-20T08:57:50.635Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a><br>同类文章 <a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></p></blockquote><p>鉴于上篇文章有提到过 微任务与宏任务，所以，在此做个细致补充： 话不多说，直接进入正文：</p><blockquote><ul><li>[1] 本文主要根据网上资源总结而来，如有不对，请斧正。</li><li>[2] 需要知道的专业名词术语：synchronous：同步任务、asynchronous：异步任务、task queue/callback queue：任务队列、execution context stack：执行栈、heap：堆、stack：栈、macro-task：宏任务、micro-task：微任务</li></ul></blockquote><a id="more"></a><h3 id="首先我们要知道两点："><a href="#首先我们要知道两点：" class="headerlink" title="首先我们要知道两点："></a>首先我们要知道两点：</h3><ul><li>JavaScript是单线程的语言</li><li>Event Loop是javascript的执行机制</li></ul><h3 id="javascript事件循环"><a href="#javascript事件循环" class="headerlink" title="javascript事件循环"></a>javascript事件循环</h3><p>js是单线程，就像学生排队上厕所，学生需要排队一个一个上厕所，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fa38dcffce?imageslim" alt="执行图片"><br>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p><hr><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制</p><h4 id="先看一段代码："><a href="#先看一段代码：" class="headerlink" title="先看一段代码："></a>先看一段代码：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><p>打印顺序是什么？ 正确答案是：script start, script end, promise1, promise2, setTimeout 已蒙圈。。。</p><h4 id="为什么会出现这样打印顺序呢？"><a href="#为什么会出现这样打印顺序呢？" class="headerlink" title="为什么会出现这样打印顺序呢？"></a>为什么会出现这样打印顺序呢？</h4><ul><li>如下导图（此图从网站下载）<br><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fb89da87c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="执行顺序"></li></ul><p>解读：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>我们不禁要问了，那怎么知道主线程执行栈为空呢？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url:www.javascript.com,</span><br><span class="line">  data:data,</span><br><span class="line">  success:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'发送成功!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码执行结束'</span>);</span><br></pre></td></tr></table></figure><p>上面是一段简易的ajax请求代码：</p><ul><li>ajax进入Event Table，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入Event Queue。</li><li>主线程从Event Queue读取回调函数success并执行。<br>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。</li></ul><hr><h3 id="微任务-Microtasks-、宏任务-task-？"><a href="#微任务-Microtasks-、宏任务-task-？" class="headerlink" title="微任务(Microtasks)、宏任务(task)？"></a>微任务(Microtasks)、宏任务(task)？</h3><p>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢？</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fa4b42e4af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="执行顺序"></p><blockquote><p>一个掘金的老哥（ssssyoki）的文章摘要：<br>那么如此看来我给的答案还是对的。但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。 我当时看到这我就服了还有这种骚操作。</p></blockquote><ul><li>而宏任务一般是：包括整体代码script，setTimeout，setInterval、setImmediate。</li><li>微任务：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver</li><li>记住就行了。</li><li>process是什么？</li></ul><hr><p>不废话，看以下例子：</p><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><p>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'延时3秒'</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  task();</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行console'</span>);</span><br></pre></td></tr></table></figure><p>根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行console</span></span><br><span class="line"><span class="comment">// task()</span></span><br></pre></td></tr></table></figure><p>去验证一下，结果正确！ 然后我们修改一下前面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  task()</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">10000000</span>)</span><br></pre></td></tr></table></figure><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解<code>setTimeout</code>的定义。我们先说上述代码是怎么执行的：</p><ul><li>ask()进入Event Table并注册,计时开始。</li><li>执行sleep函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。</li><li>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。</li></ul><p>上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p><hr><p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？<br>答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>)</span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>代码1的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先执行这里</span><br><span class="line">执行啦</span><br></pre></td></tr></table></figure><p>代码2的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先执行这里</span><br><span class="line">&#x2F;&#x2F; ... 3s later</span><br><span class="line">&#x2F;&#x2F; 执行啦</span><br></pre></td></tr></table></figure><p><strong>关于<code>setTimeout</code>要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据<code>HTML</code>的标准，最低是<code>4毫秒</code>。有兴趣的同学可以自行了解。</strong></p><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入<code>Event Queue</code>，如果前面的任务耗时太久，那么同样需要等待。</p><p>唯一需要注意的一点是，对于<code>setInterval(fn,ms)</code>来说，我们已经知道不是每过<code>ms</code>秒会执行一次<code>fn</code>，而是每过<code>ms</code>秒，会有<code>fn</code>进入<code>Event Queue</code>。一旦<code>setInterval</code>的回调函数<code>fn</code>执行时间超过了延迟时间<code>ms</code>，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p><h3 id="Promise与process-nextTick-callback"><a href="#Promise与process-nextTick-callback" class="headerlink" title="Promise与process.nextTick(callback)"></a>Promise与process.nextTick(callback)</h3><p><code>Promise</code>的定义和功能本文不再赘述，可以学习一下 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰老师的Promise</a><br>而<code>process.nextTick(callback)</code>类似<code>node.js</code>版的”<code>setTimeout</code>“，在事件循环的下一次循环中调用 <code>callback</code> 回调函数。</p><p><strong>不同类型的任务会进入对应的<code>Event Queue</code>，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的<code>Event Queue</code>。</strong></p><p>看例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>最后输出结果是Promise1，Promise2，setTimeout1</strong></p><p><code>Promise</code>参数中的<code>Promise1</code>是同步执行的 其次是因为<code>Promise</code>是<code>microtasks</code>，会在同步任务执行完后会去清空<code>microtasks queues</code>， 最后<code>清空完微任务再去宏任务队列取值</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)  </span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>这回是嵌套，大家可以看看，最后输出结果是<code>Promise1，setTimeout1，Promise2，setTimeout2</code></strong></p><ul><li>一开始执行栈的同步任务执行完毕，会去 <code>microtasks queues</code> 找清空 <code>microtasks queues</code> ，输出<code>Promise1</code>，同时会生成一个异步任务 <code>setTimeout1</code></li><li>去宏任务队列查看此时队列是 <code>setTimeout1</code> 在 <code>setTimeout2</code> 之前，因为<code>setTimeout1</code>执行栈一开始的时候就开始异步执行,所以输出 <code>setTimeout1</code></li><li>在执行<code>setTimeout1</code>时会生成Promise2的一个 <code>microtasks</code> ，放入 <code>microtasks queues</code> 中，接着又是一个循环，去清空 <code>microtasks queues</code> ，输出 <code>Promise2</code></li><li>清空完 <code>microtasks queues</code> ，就又会去宏任务队列取一个，这回取的是 <code>setTimeout2</code></li></ul><p>如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/1649751a2eb3953f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="执行图"></p><p>最后我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ul><li>整体script作为第一个宏任务进入主线程，遇到console.log，输出<code>1</code>。</li><li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务<code>Event Queue</code>中。我们暂且记为<code>setTimeout1</code>。</li><li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li><li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出<code>7</code>。<code>then</code>被分发到微任务<code>Event Queue</code>中。我们记为<code>then1</code>。</li><li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务<code>Event Queue</code>中，我们记为<code>setTimeout2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td>process1</td></tr><tr><td>setTimeout2</td><td>then1</td></tr></tbody></table><p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了<code>1</code>和<code>7</code>。<br>我们发现了<code>process1</code>和<code>then1</code>两个微任务。</p><ul><li>执行<code>process1</code>,输出<code>6</code>。</li><li>执行<code>then1</code>，输出<code>8</code>。</li></ul><p>好了，第一轮事件循环正式结束，这一轮的结果是输出<code>1，7，6，8</code>。那么第二轮时间循环从<code>setTimeout1</code>宏任务开始：</p><ul><li>首先输出<code>2</code>。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务<code>Event Queue</code>中，记为<code>process2</code>。</li><li><code>new Promise</code>立即执行输出<code>4</code>，<code>then</code>也分发到微任务<code>Event Queue</code>中，记为<code>then2</code></li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td>process3</td></tr><tr><td></td><td>then3</td></tr></tbody></table><ul><li>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</li><li>输出10。</li><li>输出12。</li><li>第三轮事件循环结束，第三轮输出9，11，10，12。</li><li>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</li></ul><blockquote><p>作者：张倩qianniuer<br>链接：<a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">https://juejin.im/post/5b498d245188251b193d4059</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tasks, microtasks, queues and schedules&lt;/a&gt;&lt;br&gt;同类文章 &lt;a href=&quot;https://juejin.im/post/59e85eebf265da430d571f89&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这一次，彻底弄懂 JavaScript 执行机制&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;鉴于上篇文章有提到过 微任务与宏任务，所以，在此做个细致补充： 话不多说，直接进入正文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;[1] 本文主要根据网上资源总结而来，如有不对，请斧正。&lt;/li&gt;
&lt;li&gt;[2] 需要知道的专业名词术语：synchronous：同步任务、asynchronous：异步任务、task queue/callback queue：任务队列、execution context stack：执行栈、heap：堆、stack：栈、macro-task：宏任务、micro-task：微任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/JS/"/>
    
      <category term="event loop" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/JS/event-loop/"/>
    
      <category term="微任务" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/JS/event-loop/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="宏任务" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/JS/event-loop/%E5%BE%AE%E4%BB%BB%E5%8A%A1/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="https://heiyehk.github.io/blog/tags/JS/"/>
    
      <category term="event loop" scheme="https://heiyehk.github.io/blog/tags/event-loop/"/>
    
      <category term="微任务" scheme="https://heiyehk.github.io/blog/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="宏任务" scheme="https://heiyehk.github.io/blog/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Web前端开发工程师编程能力飞升之路</title>
    <link href="https://heiyehk.github.io/blog/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E9%A3%9E%E5%8D%87%E4%B9%8B%E8%B7%AF/"/>
    <id>https://heiyehk.github.io/blog/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E9%A3%9E%E5%8D%87%E4%B9%8B%E8%B7%AF/</id>
    <published>2020-04-30T05:50:26.000Z</published>
    <updated>2020-05-20T08:58:06.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【背景】"><a href="#【背景】" class="headerlink" title="【背景】"></a>【背景】</h3><p>如果你是刚进入web前端研发领域，想试试这潭水有多深，看这篇文章吧；<br>如果你是做了两三年web产品前端研发，迷茫找不着提高之路，看这篇文章吧；<br>如果你是四五年的前端开发高手，没有难题能难得住你的寂寞高手，来看这篇文章吧；</p><p>web前端研发工程师，在国内是一个朝阳职业，自07-08年正式有这个职业以来，也不过三四年的时间。这个领域没有学校的正规教育，没有行内成体 系的理论指引，几乎所有从事这个职业的人都是靠自己自学成才。自学成才，一条艰辛的坎坷路，我也是这样一路走来。从2002年开始接触web前端研发至今 已然有了9个年头，如今再回首，期间的走了很多弯路。推已及人，如果能让那些后来者少走些弯路，辛甚辛甚！</p><a id="more"></a><h3 id="【前言】"><a href="#【前言】" class="headerlink" title="【前言】"></a>【前言】</h3><p>所谓的天才，只不过是比平常人更快的掌握技能、完成工作罢了；只要你找到了正确的方向，并辅以足够的时间，你一样能够踏上成功彼岸。</p><p>本文将web前端研发编程能力划分了八个等级，每个等级都列举出了对应的特征及破级提升之方法，希望每位在看本文的同学先准确定位自己的等级（不要以你目前能力的最高点，而是以你当前能力的中档与之等级作对比，以免多走弯路），参考突破之法破之。</p><p>所谓的级别，只是你面对需求时的一种态度：能够完成、能够完美地完成、能够超出预期地完成。以追求完美的态度加以扎实的编程功力，那就是你的编程水平。<br>切记心浮气燥，级别够了，那级别里的东西自然就懂了。悟了就是悟了，没悟也没关系，静下心来，投入时间而已。</p><h3 id="【入门】"><a href="#【入门】" class="headerlink" title="【入门】"></a>【入门】</h3><p>能够解决一些问题的水平。有一定的基础（比如最常见的html标签及其属性、事件、方法；最常见的css属性；基础的javascript编程能力），能够完成一些简单的web前端研发需求。<br>举个例子：删除一字符串中指定的字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"www.baidu.com/?page"</span>;  </span><br><span class="line">str=str.replace(<span class="string">'?page'</span>,<span class="string">""</span>);  </span><br><span class="line">alert(str);  </span><br><span class="line">str=str.substring(<span class="number">0</span>,str.indexof(<span class="string">"/"</span>));  </span><br><span class="line">alert(str);</span><br></pre></td></tr></table></figure><p>首先不要苛责代码的对错严谨，毕竟每个程序员都有这样的一个过程；其次，这两段代码在这个实例里没有什么大过错，可能会有瑕疵，但能够解决问题（删除指定的字符），这就是这个级别的特征。<br>再举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算系统当前是星期几  </span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> week = <span class="keyword">new</span> date().getday();</span><br><span class="line"><span class="keyword">if</span> (week == <span class="number">0</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期日"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">1</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期一"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">2</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期二"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">3</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期三"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">4</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期四"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">5</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期五"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">6</span>) &#123;</span><br><span class="line">  str = <span class="string">"今天是星期六"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者更好一些  </span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">"今天是星期"</span>;</span><br><span class="line"><span class="keyword">var</span> week = <span class="keyword">new</span> date().getday();</span><br><span class="line"><span class="keyword">switch</span> (week) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    str1 += <span class="string">"日"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    str1 += <span class="string">"一"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    str1 += <span class="string">"二"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    str1 += <span class="string">"三"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    str1 += <span class="string">"四"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    str1 += <span class="string">"五"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    str1 += <span class="string">"六"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(str);</span><br><span class="line">alert(str1);</span><br></pre></td></tr></table></figure><p>入门”阶段是每个程序员的必经之路，只要”入门”，你就上路了。所谓”师傅领进门，修行靠个人”，有了这个”入门”的基础，自己就可以摸索着前进了。</p><p>进阶之路</p><p>将javascript、html、css之类的编码帮助手册里的每个方法/属性都通读几遍！只有将基础打好，以后的路才能走的顺畅。参考这些帮助文档，力争写出无瑕疵的代码。<br>这些编码文档建议不仅是在入门提高期看，在你以后每个阶段破阶的时候都应该看看，最基础的东西往往也是最给力的东西，有时能够给你带来意想不到的收获。</p><h3 id="【登堂】"><a href="#【登堂】" class="headerlink" title="【登堂】"></a>【登堂】</h3><p>能够正确地解决问题。不管你是通过搜索网络，或者通过改造某些成品代码（jquery/dojo/ext/yui）案例，只要能够无错地完成需求。<br>同样以上面的那段”字符串剪裁”代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"www.baidu.com/?page"</span>;</span><br><span class="line">str=str.replace(<span class="regexp">/?page/</span>,<span class="string">""</span>);</span><br><span class="line">alert(str);</span><br></pre></td></tr></table></figure><p>仅仅解决问题对于”登堂”阶段来说已经不是问题，这个级别所给出方案不能是漏洞百出。以上面这段代码为例：replace方法的第一个参数虽然可以支持字符串，但最佳的类型是正则表达式；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> array(<span class="string">"日"</span>, <span class="string">"一"</span>, <span class="string">"二"</span>, <span class="string">"三"</span>, <span class="string">"四"</span>, <span class="string">"五"</span>, <span class="string">"六"</span>);</span><br><span class="line"><span class="keyword">var</span> week = <span class="keyword">new</span> date().getday();</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"今天是星期"</span>+ a[week];</span><br><span class="line">alert(str);</span><br></pre></td></tr></table></figure><p>对比”入门级”的代码，不管是从代码量、代码效率、代码优美性、代码思路来说，”登堂”级的这个日期处理代码都要优秀很多。</p><p>进阶之路</p><p>这个阶段虽然能够给出正确的解题方案，但是不一定是最优秀的方案。如何才能得到最优秀的方案呢？首先就是积累各种能够解决需求的方案，然后再验证每个方案，在这些方案中选择最好的一种。因此该阶段的进阶之路就是”行万里路，看万卷书”，积累各个需求的各个解决方案。</p><p>你可以扎身在专业论坛（蓝色理想、无忧、csdn）里，通读所有的faq及帖子；你可以打开搜索引擎，穷举所有的搜索结果。自己建立测试环境一一 验  证这些代码：去揣摩每段代码的意图，去比较每段代码之间的差异。这两条路可以让你快速完成原始积累，当你再面对大多数需求时能够说这些问题我以前做过， 那  你就水到渠成地晋阶了。</p><h3 id="【入室】"><a href="#【入室】" class="headerlink" title="【入室】"></a>【入室】</h3><p>最强代码，知道所有能够解决需求的各种方案，能够选择使用最优秀的方案满足需求。这个级别基本上产品开发编程中的代码主力。给出的一招一式，招招都是绝招。<br>还以上面的那个例子为例，你能说出1、2、3之间的差别，以及适用于那种环境吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"www.baidu.com/?page"</span>;</span><br><span class="line"><span class="comment">// 1、字符串剪裁</span></span><br><span class="line">str.substring(<span class="number">0</span>, str.indexof(<span class="string">"?page"</span>));</span><br><span class="line"><span class="comment">// 2、正则表达式</span></span><br><span class="line">str.replace(<span class="regexp">/?page/</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">// 3、字符串分拆、合并</span></span><br><span class="line">str.split(<span class="string">"?page"</span>).join(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>能够解决问题的方法会有很多，但是对于程序员来说应该选择最优秀的。上面这段代码从代码量来说”正则表达式”最优秀；从代码执行效率来说： “字符串剪裁”法最高（chrome中”正则表达式”效率最高），split法最次；从可扩展性上来说，”正则表达式”法最优。具体使用那种方案视具体 的  需求环境而定。</p><p>“入室”阶段，程序员应该能够肯定的回答：对于这个需求而言，我的代码就是最优秀的代码。</p><p>再以”今天是星期几”为例，”登堂”级的代码你敢说是最优秀的代码了吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算系统当前是星期几</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"今天是星期"</span> + <span class="string">"日一二三四五六"</span>.charat(<span class="keyword">new</span> date().getday());</span><br></pre></td></tr></table></figure><p>对比”登堂”级的示例代码，上面这段代码给你什么感受？程序员追求的就是完美。”入室”级别追求的就是每一招每一式的完美无缺。</p><p>从web前端编程来说，通过2年左右的努力，很多人能够达到这个水平，但是，很大一部分人的编程能力也就止步于此。或限于产品的需求单一性，或限于需求开发的时间紧迫性，或限于人的惰性，能够完美地解决当前的需求就够了。</p><p>由于长期处于技术平台期，技术上得不到提高，通常这个级别的工程师会比较燥。技术上小有所成；或追求个人的突破；或追求产品差异性带来的新鲜感；或者只是想换个心情；因此很多此级别的工程师会经常换公司。</p><p>戒骄戒躁：</p><p>切勿以为自己能写一手漂亮的代码而自满；<br>切莫以为别人”尊称”你一声”大侠”你就以 “大侠”自居；<br>切莫以为自己积累了一些得意的代码就成了框架式开发。</p><p>细节决定成败，优秀的方案并不能保证最终的成功。还以”删除指定字符串”为例，原始字符串从格式上来看应该是了个url链接，在去除”pn=0″之 后，最末尾处留了一个尾巴”?”；如果原始字符串是”<code>http://www.xxx.com/?pn=0&amp;a=1</code>″，去除”pn=0″之后 ? 和 &amp; 两个符号紧贴一起，这更是明显的bug。</p><p>进阶之路</p><p>此阶段进阶之路就是：切勿心浮气躁；你不再被需求牵着走，而是你牵着需求走。注重细节，注意那些当前需求里没有明文给出的细节：代码性能的差异、运行平台（浏览器）的差异、需求的隐性扩展、代码的向后兼容等等。</p><p>再通读几遍html/css/javascript帮助文档。</p><p>我建议这个级别的工程师做一做webtreeview控件，要求总节点量一万左右操作流畅，你的晋升之路就在这个控件的编码过程中。</p><h3 id="【入微】"><a href="#【入微】" class="headerlink" title="【入微】"></a>【入微】</h3><p>最强解决方案。你能够走在需求的前面，将当前需求里有的、没有直接提出来的、现在暂时没有但将来可能有的等等，及前端编程潜规则等各个方方面面都综合考虑，给出最优方案。以一招胜万招。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.xxx.com/?pn=0"</span>; <span class="comment">// 删除指定字符 pn=0</span></span><br><span class="line"><span class="comment">// 我将这个字符串里所可能想到的各种情况都列举出来</span></span><br><span class="line"><span class="keyword">var</span> a = [</span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?pn=0"</span>, <span class="comment">// pn= 可能出现在 ? 前</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?pn="</span>, <span class="comment">// url里允许pn 值为空</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?pn=0&amp;a=1"</span>, <span class="comment">// url 里可有多个字段</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?a=1&amp;pn=0"</span>, <span class="comment">// 可能排在最后</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1"</span>, <span class="comment">// 可能有多个 pn 字段</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=2"</span>, <span class="comment">// 可能在中间</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1&amp;b=1"</span>, <span class="comment">// 可能在中间成组</span></span><br><span class="line">  <span class="string">"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=1&amp;pn=1"</span> <span class="comment">// 可能零星分布</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">/* 需求的不言之秘</span></span><br><span class="line"><span class="comment">? 若出现在字符串最尾则要去之</span></span><br><span class="line"><span class="comment">? &amp; 两个符号不可重叠</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/((\?)(pn=[^&amp;]*&amp;)+(?!pn=))|(((\?|&amp;)pn=[^&amp;]*)+$)|(&amp;pn=[^&amp;]*)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  alert(a + <span class="string">"\n"</span> + a.replace(reg, <span class="string">"$2"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个阶段已经不再追求一招一式，对你来说不是使用什么创新绝招解决需求，而是给出成熟稳重的方案，从根上解决问题。针对某个当前需求你的代码可能不是最优，但是针对此类的需求你的代码却是最优秀的代码。</p><p>进阶之路</p><p>很多web前端研发工程师在做了3-4年之后就会进入一个瓶颈期：产品开发需求是小菜一碟，没有新鲜的可以挑战的东西；代码开发中的稀奇的解题方 法  都已经尝试过。没有了可挑战的难题，失去了探索的激情，也就没有了再上升的动力，好不容易走过”入室”级别的人又会有八九成止步于此。或转做技术领导 人，  或转到其它的领域，或换公司。</p><p>这些人的上升之路在哪里呢？</p><p>这个阶段单单依靠技巧和数量的累积已经没有什么效果了，突破之路在第5层《化蝶》里会详细说明，我建议你在这个阶段末尾着重关注编程理论：面向对象/过程、代码组织形式、编译、代码规范、其它的框架设计等等。</p><p>我建议这个级别的工程师做一做webeditor控件，不要求完整功能，但是该控件里的模块划分、代码组织、编程思想做到位，给出一个系统的解决方案。</p><h3 id="【化蝶】"><a href="#【化蝶】" class="headerlink" title="【化蝶】"></a>【化蝶】</h3><p>破茧重生，这个层次关注的是编程语言本身，而不再关心产品需求。什么是茧？产品需求就是茧。当你一招胜万招，打遍天下需求之时，你如果还拘泥于需求开发，那就是你限于茧中而不自知。要么就在这个茧里默默地老去，要么就破开茧获得新生。</p><p>还是以那个”字符串剪裁”的老例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:meizz</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>: 2010/12/16</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>str     被正则表达式字符串保护编码的字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return              <span class="type">&#123;string&#125;</span>                </span>被保护处理过后的字符串</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapereg</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="keyword">new</span> regexp(<span class="string">"([.*+?^=!:\x24&#123;&#125;()|[\\]\/\\\\])"</span>, <span class="string">"g"</span>), <span class="string">"\\\x241"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除url字符串中指定的 query</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:meizz</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>:2010/12/16</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>url     url字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>key     被删除的query名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return              <span class="type">&#123;string&#125;</span>                </span>被删除指定 query 后的url字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delurlquery</span>(<span class="params">url, key</span>) </span>&#123;</span><br><span class="line">  key = escapereg(key);</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> regexp(<span class="string">"((\\?)("</span>+ key +<span class="string">"=[^&amp;]*&amp;)+(?!"</span>+ key + <span class="string">"=))|(((\\?|&amp;)"</span>+ key +<span class="string">"=[^&amp;]*)+$)|(&amp;"</span>+ key +<span class="string">"=[^&amp;]*)"</span>, <span class="string">"g"</span>);</span><br><span class="line">  <span class="keyword">return</span> url.replace(reg, <span class="string">"\x241"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用实例</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.xxx.com/?pn=0"</span>; <span class="comment">// 删除指定字符 pn=0</span></span><br><span class="line">delurlquery(str, <span class="string">"pn"</span>);</span><br></pre></td></tr></table></figure><p>这段代码相对于层次4《入微》有什么区别吗？从代码实现上来说没有太大的区别，但是从思路上来说却有着本质的区别：1、不再是就事论事，头疼医头，而是把一类问题抽象理论化，一招破万招；2、有封装的概念，不再是每次从零开始，而是站在半山腰开始爬。</p><p>在web前端研发队伍里也有很大一部分人《入室》层次时就自我感觉良好，直接跨跃到《化蝶》，积累自己的代码库，抽象化问题。但没有基础，缺少强 大  的后劲，即使能够破茧也经受不了风吹雨打。一份不成熟的架构设计对团队开发带来的危害远大于它带来的好处，这种例子在业界屡见不鲜。不要拔苗助长，不要 不  会走就想着跑，夯实基础，水到渠成地成长，厚积薄发，强力地破茧而出。</p><p>进阶之路</p><p>你已经从原始积累，到厚积薄发，到破茧而出之后，你所关注的应该不再是一招一式、一个项目、一个模块，而应该是一种思路，一种理论。你可以做以下 几  个步骤以突破到更高层次：再仔细看几遍html/css/javascript接口帮助文档；选择一门强语言（c++/c#/java等）观察理解这些 语  言的组织结构，语言设计；看看原型链，链式语法编程，泛型，接口编程，dom遥控器等等；仔细阅读成熟的web前端开发框架的设计文档，看他们为什么要 这  样设计。</p><h3 id="【大侠】"><a href="#【大侠】" class="headerlink" title="【大侠】"></a>【大侠】</h3><p>这里所说的大侠，不是大家互相吹捧的”大侠”，而是实至名归的高手。这个级别的人完全有能力写出不差于bindows/jquery/ext/yui/dojo的同等级别规模的前端开发框架。应用成熟的开发框架指导、解决问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库文件 /mz/string/escapereg.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:meizz</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>: 2010/12/16</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>str     被正则表达式字符串保护编码的字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return              <span class="type">&#123;string&#125;</span>                </span>被保护处理过后的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mz.string.escapereg = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="keyword">new</span> regexp(<span class="string">"([.*+?^=!:\x24&#123;&#125;()|[\\]\/\\\\])"</span>, <span class="string">"g"</span>), <span class="string">"\\\x241"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库文件 /mz/url/delquery.js</span></span><br><span class="line"><span class="comment">/// include mz.string.escapereg;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除url字符串中指定的 query</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:meizz</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>:2010/12/16</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>url     url字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>key     被删除的query名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return              <span class="type">&#123;string&#125;</span>                </span>被删除指定 query 后的url字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mz.url.delquery = <span class="function"><span class="keyword">function</span>(<span class="params">url, key</span>) </span>&#123;</span><br><span class="line">  key = mz.string.escapereg(key);</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> regexp(<span class="string">"((\\?)("</span> + key + <span class="string">"=[^&amp;]*&amp;)+(?!"</span> + key + <span class="string">"=))|(((\\?|&amp;)"</span> + key + <span class="string">"=[^&amp;]*)+$)|(&amp;"</span> + key + <span class="string">"=[^&amp;]*)"</span>, <span class="string">"g"</span>);</span><br><span class="line">  <span class="keyword">return</span> url.replace(reg, <span class="string">"\x241"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用实例</span></span><br><span class="line"><span class="comment">/// include mz.url.delquery;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.xxx.com/?pn=0"</span>; <span class="comment">// 删除指定字符 pn=0</span></span><br><span class="line">mz.url.delquery(str, <span class="string">"pn"</span>);</span><br></pre></td></tr></table></figure><p>自成体系，有基础，也有理论高度。知道为什么这样设计，也知道什么样的设计最好。比如这个例子可以有这样的封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库文件 /mz/url/delquery.js</span></span><br><span class="line"><span class="comment">/// include mz.string.escapereg;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除url字符串中指定的 query</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:meizz</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>:2010/12/16</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>url     url字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param               <span class="type">&#123;string&#125;</span>        </span>key     被删除的query名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return              <span class="type">&#123;string&#125;</span>                </span>被删除指定 query 后的url字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">string.prototype.delquery = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    key = mz.string.escapereg(key);</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> regexp(<span class="string">"((\\?)("</span> + key + <span class="string">"=[^&amp;]*&amp;)+(?!"</span> + key + <span class="string">"=))|(((\\?|&amp;)"</span> + key + <span class="string">"=[^&amp;]*)+$)|(&amp;"</span> + key + <span class="string">"=[^&amp;]*)"</span>, <span class="string">"g"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(reg, <span class="string">"\x241"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用实例</span></span><br><span class="line"><span class="comment">/// include mz.url.delquery;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.xxx.com/?pn=0"</span>; <span class="comment">// 删除指定字符 pn=0</span></span><br><span class="line">str.delquery(<span class="string">"pn"</span>);</span><br></pre></td></tr></table></figure><p>而为什么不采用下面的那种封装呢？经过了《知微》和《化蝶》你就懂了。</p><p>进阶出路</p><p>道法自然，从根上去寻找突破的契机。你可以研读html解析引擎设计与实现，js解析引擎设计与实现，其它语言的代码解析与编译实现等等。<br>或者出些书。低级别的人写的书要么是一大抄，空无一物；要么是害人。</p><h3 id="【宗师】"><a href="#【宗师】" class="headerlink" title="【宗师】"></a>【宗师】</h3><p>这个级别的人已然到了无招胜有招的境界。项目开发中的难题？没有难题！运行平台的差异？从根本上搞定！代码规范、开发模式，早已经被抛在身后。这个级别的人已经不再关注于某个前端开发框架，而是应对具体的环境给出最佳的理论指导。</p><p>这个级别的人所注意的应该是以最合理的系统架构引领着整个团队的进步，在什么样的场景下该用什么样的架构设计。3个、10个、50个、100个人的团队最应该用哪种模式？等你到了宗师级别，你再来回答吧。</p><p>进阶出路</p><p>每一个宗师就是一个高山，就是一个领域里的神，但是你仅满足于在一群比你弱的群体展现你的强大吗？如果还你是止步原地，那总会有人乘着飞机、宇宙飞船从你的头领掠过，高处不胜寒！</p><p>要突破这片领域，那就必须跳出这片领域。要想突破web前端研发的宗师级，那就跳出web前端吧，上面还有web开发。即使你是web前端的宗师， 但没有快速的数据响应，没有高速的网络架构，没有优美的系统支持，你又能如何？所以突破之路就是把目光投到整条web开发的链条中去。</p><h3 id="【飞升】"><a href="#【飞升】" class="headerlink" title="【飞升】"></a>【飞升】</h3><p>其实严格来说，飞升已经不是原领域的范围了。在web研发领域，对于这个层次的有一个很好听的称谓：架构师。当然那些”伪架构师”另当别论。</p><p>一法通，万法通。在其它的技术领域，也可以按照《入门》《登堂》《入室》《入微》《化蝶》《大侠》《宗师》来划分等级；一样也可以按照我这里所写的每个级别的【进阶之路】来快速提升。</p><p>祝贺你再获辉煌！</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><blockquote><p>原文地址已经找不到了,最早2011年3月23日只从CSDN别人转载处找到地址(不确定是不是这个是原文): <a href="http://hszy00232.blog.163.com/blog/static/430227532011119105237357/" target="_blank" rel="noopener">http://hszy00232.blog.163.com/blog/static/430227532011119105237357/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【背景】&quot;&gt;&lt;a href=&quot;#【背景】&quot; class=&quot;headerlink&quot; title=&quot;【背景】&quot;&gt;&lt;/a&gt;【背景】&lt;/h3&gt;&lt;p&gt;如果你是刚进入web前端研发领域，想试试这潭水有多深，看这篇文章吧；&lt;br&gt;如果你是做了两三年web产品前端研发，迷茫找不着提高之路，看这篇文章吧；&lt;br&gt;如果你是四五年的前端开发高手，没有难题能难得住你的寂寞高手，来看这篇文章吧；&lt;/p&gt;
&lt;p&gt;web前端研发工程师，在国内是一个朝阳职业，自07-08年正式有这个职业以来，也不过三四年的时间。这个领域没有学校的正规教育，没有行内成体 系的理论指引，几乎所有从事这个职业的人都是靠自己自学成才。自学成才，一条艰辛的坎坷路，我也是这样一路走来。从2002年开始接触web前端研发至今 已然有了9个年头，如今再回首，期间的走了很多弯路。推已及人，如果能让那些后来者少走些弯路，辛甚辛甚！&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="能力提升" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="能力提升" scheme="https://heiyehk.github.io/blog/tags/%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>你应该知道的前端--缓存</title>
    <link href="https://heiyehk.github.io/blog/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E5%89%8D%E7%AB%AF-%E7%BC%93%E5%AD%98/"/>
    <id>https://heiyehk.github.io/blog/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E5%89%8D%E7%AB%AF-%E7%BC%93%E5%AD%98/</id>
    <published>2020-04-30T05:36:11.000Z</published>
    <updated>2020-05-20T08:55:42.654Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web-缓存"><a href="#web-缓存" class="headerlink" title="web 缓存"></a>web 缓存</h3><p>web 缓存是可以通过自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时,如果本地有以缓存的副本,就可以从本地存储设备而不是原始服务器中提取这个文档。</p><h3 id="1-为什么需要缓存"><a href="#1-为什么需要缓存" class="headerlink" title="1. 为什么需要缓存"></a>1. 为什么需要缓存</h3><ul><li>冗余的数据传输</li></ul><p>有很多客户端访问一个流行的原始服务器页面时,服务器会多次传输同一份文档,每次传送给一个客户端,一些相同的字节会在网络中一遍遍的传输。这些冗余的数据传输会耗尽昂贵的网络带宽。而通过缓存我们可以保留第一家服务器响应的副本,后继请求就可以由缓存的副本来应对</p><ul><li>带宽瓶颈</li></ul><a id="more"></a><p>缓存还可以缓解网络的瓶颈问题。很多网络会为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器。如果客户端从一个快速局域网的缓存中得到一份副本,那么缓存就可以提高性能——尤其是要传输比较大的文件时</p><ul><li>瞬间拥塞</li></ul><p>缓存在破环瞬间拥塞时显得非常中重要。突发事件(比如爆炸性新闻,批量 E-mail 公告, 或者某个名人事件)是很多人几乎同时去访问一个 web 文档时,就会出现瞬间拥塞。由此造成的过多流量峰值可能会使网络和 web 服务器发生灾难性的崩溃</p><ul><li>距离时延</li></ul><p>即使带宽不是问题,距离也可能称为问题。每台网络路由器都会增加因特网流量的时延,即使客户端和服务器之间没有太多路由器,光速本身也会造成时延长。将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米</p><h3 id="2-缓存的命中和未命中"><a href="#2-缓存的命中和未命中" class="headerlink" title="2. 缓存的命中和未命中"></a>2. 缓存的命中和未命中</h3><p>但是缓存无法保存世界上每份文档的副本,这样就会分成两种情况：</p><ul><li>可以用已有的副本为某些到达缓存的请求提供服务,这被称之为缓存命中</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfaa771243b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><ul><li>其他一些到达缓存的请求可能会由于没有副本可用,而被转发给原始服务器,这被称之为缓存未命中</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfab46a3b1c3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><h3 id="3-新鲜度检测规则"><a href="#3-新鲜度检测规则" class="headerlink" title="3. 新鲜度检测规则"></a>3. 新鲜度检测规则</h3><p>HTTP通过缓存将服务器文档的副本保留一段时间。在这段时间里,都认为文档时新鲜的,缓存可以在不联系服务器的情况下,直接提供该文档。我们称之为<strong>强缓存命中</strong>,此时浏览器会返回200状态码(from cache)</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfaa771243b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><p>但一旦以缓存副本停留的时间太长,超过了文档的新鲜度限值,就认为文档过期了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfaa7726cf25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><p>再提供文档之前,缓存要再次与服务器进行再验证,已查看文档是否发生了变化。我们称之为<strong>协商缓存</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfaa770151bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><ul><li>在验证命中: 如果服务器对象没有被修改,服务器会向客户端发送一个小的HTTP 304 Not Modeified响应</li><li>再验证未命中: 如果服务器对象与以缓存副本不同,服务器向客户端送一条普通的带有完整内容的HTTP 200 ok 响应</li><li>对象被删除: 如果服务器对象已经被删除了,服务器就回送一个404 Not Found 响应,缓存也会将其副本删除</li></ul><h3 id="4-强缓存原理"><a href="#4-强缓存原理" class="headerlink" title="4. 强缓存原理"></a>4. 强缓存原理</h3><p>通过特殊的<strong>HTTPCache-Control</strong>首部和<strong>Expries</strong>首部,HTTP让原始服务器向每个文档附加了一个<strong>过期日期</strong>,这些首部说明了在多长时间内可以将这些内容视为新鲜的。</p><p>浏览器第二次发送请求相同资源时,拿出过期时间和当前时间进行比较,如果在过期日期之前,则强缓存命中,如果缓存文档过期,缓存就必须与服务器进行核对,询问文档是否过期,如果被修改过,就要获取一份新鲜(带有新的过期日期)的副本</p><h4 id="4-1-强缓存首部"><a href="#4-1-强缓存首部" class="headerlink" title="4.1 强缓存首部"></a>4.1 强缓存首部</h4><ul><li><strong>Cache-Control: max-age:</strong></li></ul><p><strong>max-age</strong>值定义了文档的最大使用期——从第一次生成文档到文档不再新鲜,无法使用为止,最大的合法生存时间(以秒为单位)</p><ul><li><strong>Expires:</strong></li></ul><p>指定一个绝对的过期日期,如果过期日期已经过了,就说明文档不在新鲜了,不过由于我们可以去更改客户端的时间,因此可以更改缓存命中的结果。因此我们优先使用<strong>Cache-Control</strong><br><strong>Cache-Control</strong>指令：</p><ul><li><strong>no-cache和no-store:</strong></li></ul><p><strong>no-cache</strong>表示必须先与服务器确认返回的响应是否发生了变化,然后才能使用响应来满足后续对同意网址的请求。因此如果存在合适的验证令牌(<strong>ETag</strong>),<strong>no-cache</strong>会发起往返通信来验证缓存的响应,但如果资源未发生变化,则可避免下载<br><strong>no-store</strong>表示直接禁止浏览器以及所有中间缓存存储任何版本的返回响应,例如,包含个人隐私数据或银行业务数据的响应。每次用户请求该资产时,都会向服务器发送请求,并下载完整的响应</p><ul><li><strong>public与private:</strong></li></ul><p><strong>public</strong>出现再响应首部,则即使他有关联的HTTP验证,甚至响应状态代码代码通常无法缓存,也可以缓存响应。大多数情况下,<strong>public</strong>不是必须的,因为明确的缓存信息(例如<strong>max-age</strong>)已表示响应是可以缓存<br>相比之下,浏览器可以缓存private响应。不过这些响应通常只为单个用户缓存,因此不允许任何中间缓存对其进行缓存,例如,用户的浏览器可以缓存包含用户私人信息的HTML网页,但CDN不能缓存</p><ul><li><strong>max-age:</strong></li></ul><p>指令指定从请求的时间开始,允许获取的响应被重用的最长时间。例如<strong>max-age=60</strong>表示可以在接下来的60s缓存和重用响应</p><ul><li><strong>must-revalidate:</strong></li></ul><p><strong>must-revalidate</strong>告诉缓存,再事先没有跟原始服务器进行再验证的情况下,不能提供这个对象的陈旧副本,缓存仍然可以随意提供新鲜的副本。如果在缓存进行<strong>must-revalidate</strong>新鲜度检查时,原始服务器不可用,缓存就必须返回一条504错误</p><p>最佳Cache-Control策略:</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfab954de5e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><h3 id="5-协商缓存原理"><a href="#5-协商缓存原理" class="headerlink" title="5. 协商缓存原理"></a>5. 协商缓存原理</h3><p>仅仅是以缓存过期了并不意味着他和原始服务器目前处于活跃状态的文档有实际的区别,这只是意味着到了要进行核对的时间了,这种情况被称为<strong>协商缓存</strong>,说明缓存需要询问原始服务器是否发生变化</p><ul><li>如果再验证显示内容发生了变化,缓存会获取一份新的文档副本,并将其存储在旧文档的位置上,然后将文档发送给客户端。</li><li>如果再验证内容没有发生变化,缓存只需要获取新的首部,包括一个新的过期日期,并对缓存中的首部进行更新,并对缓存中的首部进行更新就行了</li></ul><h4 id="5-1-用条件方法进行再验证"><a href="#5-1-用条件方法进行再验证" class="headerlink" title="5.1 用条件方法进行再验证"></a>5.1 用条件方法进行再验证</h4><p>HTTP的条件方法可以高效的实现再验证。HTTP允许缓存向原始服务器发送一个条件GET,请求服务器只有在文档与缓存中现有的副本不同时,才回送对象主体,对于缓存在验证来说最有用的2个首部时</p><ul><li><code>If-Modified-Since: &lt;date&gt;</code>  </li></ul><p>如果从指定日期之后,文档被修改了,就执行请求的方法。可以与<strong>Last-Modfied</strong>服务器响应首部配合使用,只有在内容修改后与已缓存版本有所不同的时候才去获取内容</p><ul><li><code>If-None-Match:&lt;tags&gt;:</code></li></ul><p>服务器可以为文档提供特殊的标签(ETag),而不是将其与最近修改日期向匹配,这些标签就像序列号一样。如果已缓存标签与服务器文档中的标签有所不同,<strong>If-None-Match</strong>首部就会执行所请求的方法</p><h4 id="5-2-If-Modified-Since-Last-Modified"><a href="#5-2-If-Modified-Since-Last-Modified" class="headerlink" title="5.2 If-Modified-Since:  / Last-Modified####"></a>5.2 If-Modified-Since:  / Last-Modified####</h4><p>具体流程如下:</p><ol><li>客户端第一次向服务器发起请求,服务器将最后的修改日期(<strong>Last-Modified</strong>)附加到所提供的文档上去</li><li>当再一次请求资源时间,如果没有命中强缓存,在执行在验证时,会包含一个<strong>If-Modifed-Since</strong>首部,其中携带有最后修改已缓存副本的日期: <code>If-Modified-Since: &lt;cached last-modified data&gt;</code></li><li>如果内容被修改了,服务器回送新的文档,返回200状态码和最新的修改日期</li><li>如果内容没有被修改,会返回一个<strong>304 Not Modified</strong>响应</li></ol><h4 id="5-3-If-None-Match-ETag"><a href="#5-3-If-None-Match-ETag" class="headerlink" title="5.3 If-None-Match / ETag"></a>5.3 If-None-Match / ETag</h4><p>有些情况下仅使用最后修改日期进行再验证是不够的</p><ul><li>有些文档有可能会被周期性的重写(比如: 从一个后台进程中写入),但实际上包含的数据常常是一样分,尽管内容没有变化,但修改日期会发生变化</li><li>有些文档可能被修改了,但所做修改并不重要.不需要让世界范围内的缓存都重装数据(比如填写注释)</li><li>有些服务器无法准确判定其页面的最后修改日期</li><li>有些服务器提供的文档会在毫秒间隙发生变化(比如,实时监视器),对这些服务器来说,以一秒为粒度的修改日期可能就不够用了</li></ul><p>因此HTTP允许用户对被称为实体标签的(<strong>ETag</strong>)的版本标识符进行比较。实体标签是附加到文档上的任意标签(引用字符串),服务器生成并返回的随机令牌通常是文件内容的哈希值或其他指纹。客户端不需要指纹是如何生成的，只需在下一次请求时将其发送至服务器。如果指纹仍然相同，则表示资源未发生变化，您就可以跳过下载。</p><p>在上例中，客户端自动在<strong>“If-None-Match” HTTP 请求标头内提供 ETag 令牌</strong>。服务器根据当前资源核对令牌。如果它未发生变化，服务器将返回304 Not Modified响应，告知浏览器缓存中的响应未发生变化，可以再延用 120 秒。请注意，您不必再次下载响应，这节约了时间和带宽。</p><p><strong>更新和废弃响应</strong></p><p>浏览器发出的所有HTTP请求会首先路由到浏览器缓存,已确认是否缓存可用于请求的有效响应。如果有匹配的响应,则从缓存中读取响应,这样就避免了网路延迟和传送产生的流量费用</p><p>*<em>不过如果我们向更新或废弃缓存的响应,该怎么办, *</em>例如我们有一个css样式表缓存长达24小时,但是我们需要立即更新他,我们如何通知已过时的CSS缓存副本的所有访问者更新其缓存。在不更改资源网址的情况下,是做不到的。</p><p>所以,如何才能实现客户端缓存和快速更新,你可以在资源内容发生变化时,更改它的网址,强制用户下载新响应。通常情况下,可以通过再文件名中嵌入文件的指纹或版本号来实现</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcfaaf3b76754?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><ul><li>HTML被标记为<strong>no-cache</strong>,这意味着浏览器再每次请求时都始终重新验证文档,并在内容变化时获取最新版本。此外再HTML标记内,再CSS和javascript中嵌入指纹,如果这些文件的内容发生变化,网页的HTML也会随之改变,并会下载HTML响应的新副本</li><li>允许浏览器和中间缓存(例如CDN)缓存CSS,并将CSS设置为1年后到期,因为再文件名中嵌入了文件的指纹,CSS更新时网址也会随之变化</li><li>JavaScript同样设置为1年后到期,但标记为<strong>private</strong>,这或许是因为它包含的某些用户私人数据是CDN不应缓存的。</li><li>图像缓存时不包含版本或唯一指纹,并设置为一天后到期</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="noopener">HTTP缓存</a></li><li><a href="https://www.cnblogs.com/lyzg/p/5125934.html#_label4" target="_blank" rel="noopener">浏览器缓存知识小结及应用</a></li><li><a href="http://www.yzmspirit.com/2017/03/28/http%E7%88%86%E7%82%B8%E9%87%8D%E7%82%B9%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">http爆炸重点学习——缓存</a></li></ul><blockquote><p>作者：SGAMER-rain<br>链接：<a href="https://juejin.im/post/5ae081aaf265da0b767d263a" target="_blank" rel="noopener">https://juejin.im/post/5ae081aaf265da0b767d263a</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;web-缓存&quot;&gt;&lt;a href=&quot;#web-缓存&quot; class=&quot;headerlink&quot; title=&quot;web 缓存&quot;&gt;&lt;/a&gt;web 缓存&lt;/h3&gt;&lt;p&gt;web 缓存是可以通过自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时,如果本地有以缓存的副本,就可以从本地存储设备而不是原始服务器中提取这个文档。&lt;/p&gt;
&lt;h3 id=&quot;1-为什么需要缓存&quot;&gt;&lt;a href=&quot;#1-为什么需要缓存&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要缓存&quot;&gt;&lt;/a&gt;1. 为什么需要缓存&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;冗余的数据传输&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有很多客户端访问一个流行的原始服务器页面时,服务器会多次传输同一份文档,每次传送给一个客户端,一些相同的字节会在网络中一遍遍的传输。这些冗余的数据传输会耗尽昂贵的网络带宽。而通过缓存我们可以保留第一家服务器响应的副本,后继请求就可以由缓存的副本来应对&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带宽瓶颈&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="缓存" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="缓存" scheme="https://heiyehk.github.io/blog/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>从输入url到显示网页发生了什么</title>
    <link href="https://heiyehk.github.io/blog/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://heiyehk.github.io/blog/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2020-04-30T05:29:44.000Z</published>
    <updated>2020-04-30T09:27:42.758Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在浏览器中输入url到显示网页主要包含两个部分： <strong>网络通信和页面渲染</strong></p><p>互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走</p><a id="more"></a><h3 id="1-浏览器的地址栏输入URL并按下回车"><a href="#1-浏览器的地址栏输入URL并按下回车" class="headerlink" title="1.浏览器的地址栏输入URL并按下回车"></a>1.浏览器的地址栏输入URL并按下回车</h3><p>我们常见的RUL是这样的: <code>www.baidu.com</code>,域名通常由3部分组成：<strong>协议 域名 端口号</strong></p><ol><li>协议：主要是HTTP协议，HTTPS协议，FTP协议，FILe协议</li><li>域名：url中间部分为域名或者IP</li><li>端口号：通常默认都是隐藏的 http默认端口号为80 https默认端口号为443</li></ol><p>涉及知识点： 跨域<br>在前端进行数据请求时，由于浏览器的同源策略，协议，域名，端口号有一个不同会存在跨域请求，需要进行跨域处理，相关的跨域方法点击<a href="https://user-gold-cdn.xitu.io/2018/11/19/1672a68aae05f7f6" target="_blank" rel="noopener">https://user-gold-cdn.xitu.io/2018/11/19/1672a68aae05f7f6</a></p><h3 id="2-DNS域名解析"><a href="#2-DNS域名解析" class="headerlink" title="2.DNS域名解析"></a>2.DNS域名解析</h3><p>互联网上每一台计算机的唯一标识是它的<strong>IP地址</strong>，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析，即实现了网址到IP地址的转换</p><p>解析过程<br>DNS解析是一个递归查询的过程。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a5a206a7e309" alt="avatar"></p><p>上述图片是查找<code>www.google.com</code>的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。</p><p>从上述过程中，可以看出网址的解析是一个从右向左的过程: <code>com</code> -&gt; <code>google.com</code> -&gt; <code>www.google.com</code>。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是<code>www.google.com</code>.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: <code>.</code> -&gt; <code>.com</code> -&gt; <code>google.com</code>. -&gt; <code>www.google.com</code>.。</p><h4 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h4><p>DNS缓存和DNS负载均衡</p><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p><ol><li>在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。</li><li>系统缓存主要存在/etc/hosts(Linux系统)中:</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a566f8cebd65" alt="avatar"></p><p>DNS负载均衡</p><p>真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向</p><h3 id="3-建立TCP连接"><a href="#3-建立TCP连接" class="headerlink" title="3.建立TCP连接"></a>3.建立TCP连接</h3><p>在通过DNS域名解析后，获取到了服务器的IP地址，在获取到IP地址后，便会开始建立一次连接，这是由TCP协议完成的，主要通过三次握手进行连接。</p><ol><li>第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；</li><li>第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 这里需要了解下<strong>ACK，SYN</strong>的意义</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a5a206a7e309" alt="avatar"><br>完成TCP连接后开使向服务器进行请求</p><h3 id="4-向服务器发送请求"><a href="#4-向服务器发送请求" class="headerlink" title="4.向服务器发送请求"></a>4.向服务器发送请求</h3><p>完整的HTTP请求包含<strong>请求起始行、请求头部、请求主体</strong>三部分。<br><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a5d02bc0d8fd" alt="avatar"></p><h3 id="5-服务器接受响应"><a href="#5-服务器接受响应" class="headerlink" title="5.服务器接受响应"></a>5.服务器接受响应</h3><p>服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。<br>状态码主要包括以下部分:</p><p>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。<br><strong>响应头</strong>主要由Cache-Control、 Connection、Date、Pragma等组成。<br><strong>响应体</strong>为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成。</p><h3 id="6-页面渲染"><a href="#6-页面渲染" class="headerlink" title="6.页面渲染"></a>6.页面渲染</h3><p> 如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。  在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：<strong>Reflow</strong>和<strong>Repaint</strong>。<br><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a637a7508bca" alt="avatar"></p><ol><li>Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。  </li><li>Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。</li></ol><p>所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。</p><h3 id="7-关闭TCP连接或继续保持连接"><a href="#7-关闭TCP连接或继续保持连接" class="headerlink" title="7.关闭TCP连接或继续保持连接"></a>7.关闭TCP连接或继续保持连接</h3><p>通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672a64fbd06d50d" alt="avatar"></p><ol><li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li><li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li><li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li><li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li></ol><blockquote><p>作者：rosenWang<br>链接：<a href="https://juejin.im/post/5bf23afa6fb9a049be5d1494" target="_blank" rel="noopener">https://juejin.im/post/5bf23afa6fb9a049be5d1494</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在浏览器中输入url到显示网页主要包含两个部分： &lt;strong&gt;网络通信和页面渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="DNS" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/DNS/"/>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="DNS" scheme="https://heiyehk.github.io/blog/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>11道浏览器原理面试题</title>
    <link href="https://heiyehk.github.io/blog/11%E9%81%93%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://heiyehk.github.io/blog/11%E9%81%93%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-30T04:53:59.000Z</published>
    <updated>2020-04-30T09:27:28.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见的浏览器内核有哪些"><a href="#常见的浏览器内核有哪些" class="headerlink" title="常见的浏览器内核有哪些?"></a>常见的浏览器内核有哪些?</h3><table><thead><tr><th>浏览器/RunTime</th><th>内核（渲染引擎）</th><th>JavaScript 引擎</th></tr></thead><tbody><tr><td>Chrome</td><td>Blink（28~）Webkit（Chrome 27）</td><td>V8</td></tr><tr><td>FireFox</td><td>Gecko</td><td>SpiderMonkey</td></tr><tr><td>Safari</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>Edge</td><td>EdgeHTML</td><td>Chakra(for JavaScript)</td></tr><tr><td>IE</td><td>Trident</td><td>Chakra(for JScript)</td></tr><tr><td>PhantomJS</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>Node.js</td><td>-</td><td>V8</td></tr></tbody></table><a id="more"></a><h3 id="浏览器的主要组成部分是什么？"><a href="#浏览器的主要组成部分是什么？" class="headerlink" title="浏览器的主要组成部分是什么？"></a>浏览器的主要组成部分是什么？</h3><ol><li>用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li><li>浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</li><li>呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li>网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li><li>用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li><li>JavaScript 解释器。用于解析和执行 JavaScript 代码。</li><li>数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li></ol><p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p><h3 id="浏览器是如何渲染UI的？"><a href="#浏览器是如何渲染UI的？" class="headerlink" title="浏览器是如何渲染UI的？"></a>浏览器是如何渲染UI的？</h3><ol><li>浏览器获取HTML文件，然后对文件进行解析，形成<code>DOM Tree</code></li><li>与此同时，进行<code>CSS</code>解析，生成<code>Style Rules</code></li><li>接着将<code>DOM Tree</code>与<code>Style Rules</code>合成为 <code>Render Tree</code></li><li>接着进入布局<code>（Layout）</code>阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标</li><li>随后调用<code>GPU</code>进行绘制<code>（Paint）</code>，遍历<code>Render Tree</code>的节点，并将元素呈现出来</li></ol><h3 id="浏览器如何解析css选择器？"><a href="#浏览器如何解析css选择器？" class="headerlink" title="浏览器如何解析css选择器？"></a>浏览器如何解析css选择器？</h3><p>浏览器会『从右往左』解析CSS选择器。<br>我们知道<code>DOM Tree</code>与<code>Style Rules</code>合成为 <code>Render Tree</code>，实际上是需要将<code>Style Rules</code>附着到DOM Tree上，因此需要根据选择器提供的信息对<code>DOM Tree</code>进行遍历，才能将样式附着到对应的DOM元素上。<br>以下这段css为例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mod-nav</span> <span class="selector-tag">h3</span> <span class="selector-tag">span</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>;&#125;</span><br></pre></td></tr></table></figure><p>若从左向右的匹配，过程是：  </p><ol><li>从 <code>.mod-nav</code> 开始，遍历子节点 <code>header</code> 和子节点 <code>div</code></li><li>然后各自向子节点遍历。在右侧 <code>div</code> 的分支中</li><li>最后遍历到叶子节点 <code>a</code> ，发现不符合规则，需要回溯到 <code>ul</code> 节点，再遍历下一个 <code>li-a</code>，一颗<code>DOM</code>树的节点动不动上千，这种效率很低。</li></ol><p>如果从右至左的匹配：  </p><ol><li>先找到所有的最右节点 <code>span</code>，对于每一个 <code>span</code>，向上寻找节点 <code>h3</code></li><li>由 <code>h3</code>再向上寻找 <code>class=mod-nav</code> 的节点</li><li>最后找到根元素 <code>html</code> 则结束这个分支的遍历。</li></ol><p>后者匹配性能更好，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）；而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p><h3 id="DOM-Tree是如何构建的？"><a href="#DOM-Tree是如何构建的？" class="headerlink" title="DOM Tree是如何构建的？"></a>DOM Tree是如何构建的？</h3><ol><li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串</li><li>生成<code>Tokens</code>: 之后开始parser，浏览器会将HTML字符串解析成<code>Tokens</code></li><li>构建<code>Nodes</code>: 对Node添加特定的属性，通过指针确定 <code>Node</code> 的父、子、兄弟关系和所属 <code>treeScope</code></li><li>生成<code>DOM Tree</code>: 通过<code>node</code>包含的指针确定的关系构建出<code>DOM Tree</code></li></ol><h3 id="浏览器重绘与重排的区别？"><a href="#浏览器重绘与重排的区别？" class="headerlink" title="浏览器重绘与重排的区别？"></a>浏览器重绘与重排的区别？</h3><ul><li>重排: 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素</li><li>重绘: 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变</li></ul><p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p><p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p><p>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</p><h3 id="如何触发重排和重绘？"><a href="#如何触发重排和重绘？" class="headerlink" title="如何触发重排和重绘？"></a>如何触发重排和重绘？</h3><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点</li><li>通过<code>display: none</code>隐藏一个DOM节点-触发重排和重绘</li><li>通过<code>visibility: hidden</code>隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的<code>DOM</code>节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><h3 id="如何避免重绘或者重排？"><a href="#如何避免重绘或者重排？" class="headerlink" title="如何避免重绘或者重排？"></a>如何避免重绘或者重排？</h3><h4 id="集中改变样式"><a href="#集中改变样式" class="headerlink" title="集中改变样式"></a>集中改变样式</h4><p>我们往往通过改变class的方式来集中改变样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否是黑色系样式</span></span><br><span class="line"><span class="keyword">const</span> theme = isDark ? <span class="string">'dark'</span> : <span class="string">'light'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据判断来设置不同的class</span></span><br><span class="line">ele.setAttribute(<span class="string">'className'</span>, theme)</span><br></pre></td></tr></table></figure><h4 id="使用DocumentFragment"><a href="#使用DocumentFragment" class="headerlink" title="使用DocumentFragment"></a>使用DocumentFragment</h4><p>我们可以通过<code>createDocumentFragment</code>创建一个游离于DOM树之外的节点，然后在此节点上批量操作，最后插入DOM树中，因此只触发一次重排</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">  node.innerHTML = i;</span><br><span class="line">  fragment.appendChild(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(fragment);</span><br></pre></td></tr></table></figure><h4 id="提升为合成层"><a href="#提升为合成层" class="headerlink" title="提升为合成层"></a>提升为合成层</h4><p>将元素提升为合成层有以下优点：</p><ul><li>合成层的位图，会交由 <code>GPU</code> 合成，比 <code>CPU</code> 处理要快</li><li>当需要 <code>repaint</code> 时，只需要 <code>repaint</code> 本身，不会影响到其他的层</li><li>对于 <code>transform</code> 和 <code>opacity</code> 效果，不会触发 <code>layout</code> 和 <code>paint</code></li></ul><p>提升合成层的最好方式是使用 <code>CSS</code> 的 <code>will-change</code> 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于合成层的详解请移步<a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noopener">无线性能优化：Composite</a></p></blockquote><h3 id="前端如何实现即时通讯？"><a href="#前端如何实现即时通讯？" class="headerlink" title="前端如何实现即时通讯？"></a>前端如何实现即时通讯？</h3><h4 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h4><p>短轮询的原理很简单，每隔一段时间客户端就发出一个请求，去获取服务器最新的数据，一定程度上模拟实现了即时通讯。</p><ul><li>优点：兼容性强，实现非常简单</li><li>缺点：延迟性高，非常消耗请求资源，影响性能</li></ul><h4 id="comet"><a href="#comet" class="headerlink" title="comet"></a>comet</h4><p>comet有两种主要实现手段，一种是基于 <code>AJAX</code> 的长轮询<code>（long-polling）</code>方式，另一种是基于 <code>Iframe</code> 及 <code>htmlfile</code> 的<code>流（streaming）</code>方式，通常被叫做<code>长连接</code>。  </p><blockquote><p>具体两种手段的操作方法请移步<a href="http://www.52im.net/thread-334-1-1.html" target="_blank" rel="noopener">Comet技术详解：基于HTTP长连接的Web端实时通信技术</a></p></blockquote><p>长轮询优缺点：</p><ul><li>优点：兼容性好，资源浪费较小</li><li>缺点：服务器<code>hold</code>连接会消耗资源，返回数据顺序无保证，难于管理维护</li></ul><p>长连接优缺点：</p><ul><li>优点：兼容性好，消息即时到达，不发无用请求</li><li>缺点：服务器维护长连接消耗资源<h4 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h4><blockquote><p>使用指南请看<a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">Server-Sent Events 教程</a></p></blockquote></li></ul><p>SSE（Server-Sent Event，服务端推送事件）是一种允许服务端向客户端推送新数据的HTML5技术。  </p><ul><li>优点：基于HTTP而生，因此不需要太多改造就能使用，使用方便，而websocket非常复杂，必须借助成熟的库或框架</li><li>缺点：基于文本传输效率没有<code>websocket</code>高，不是严格的双向通信，客户端向服务端发送请求无法复用之前的连接，需要重新发出独立的请求</li></ul><h4 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h4><p>使用指南请看<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a></p><p>Websocket是一个全新的、独立的协议，基于<code>TCP协议</code>，与h<code>ttp协议</code>兼容、却不会融入<code>http协议</code>，仅仅作为<code>html5</code>的一部分，其作用就是在服务器和客户端之间建立实时的双向通信。  </p><ul><li>优点：真正意义上的实时双向通信，性能好，低延迟</li><li>缺点：独立与http的协议，因此需要额外的项目改造，使用复杂度高，必须引入成熟的库，无法兼容低版本浏览器</li></ul><h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><blockquote><p>后面性能优化部分会用到，先做了解</p></blockquote><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">Web Worker教程</a></p></blockquote><h4 id="Service-workers"><a href="#Service-workers" class="headerlink" title="Service workers"></a>Service workers</h4><blockquote><p>后面性能优化部分会用到，先做了解</p></blockquote><p>Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理，创建有效的离线体验。</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service workers教程</a></p></blockquote><h4 id="什么是浏览器同源策略？"><a href="#什么是浏览器同源策略？" class="headerlink" title="什么是浏览器同源策略？"></a>什么是浏览器同源策略？</h4><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。<br>同源是指<code>&quot;协议+域名+端口&quot;</code>三者相同，即便两个不同的域名指向同一个ip地址，也非同源。<br>下表给出了相对<a href="http://store.company.com/dir/page.html同源检测的示例" target="_blank" rel="noopener">http://store.company.com/dir/page.html同源检测的示例</a>:</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/24/16d610123996dc1e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://store.company.com/dir/page.html同源检测的示例"></p><p>浏览器中的大部分内容都是受同源策略限制的，但是以下三个标签可以不受限制：</p><ul><li>&lt;img src=XXX&gt;</li><li>&lt;link href=XXX&gt;</li><li>&lt;script src=XXX&gt;</li></ul><h3 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h3><p>跨域是个比较古老的命题了，历史上跨域的实现手段有很多，我们现在主要介绍三种比较主流的跨域方案，其余的方案我们就不深入讨论了，因为使用场景很少，也没必要记这么多奇技淫巧。</p><h4 id="最经典的跨域方案jsonp"><a href="#最经典的跨域方案jsonp" class="headerlink" title="最经典的跨域方案jsonp"></a>最经典的跨域方案jsonp</h4><p>jsonp本质上是一个<code>Hack</code>，它利用<code>&lt;script&gt;</code>标签不受同源策略限制的<code>特性进行跨域</code>操作。<br>jsonp优点：</p><ul><li>实现简单</li><li>兼容性非常好</li></ul><p>jsonp的缺点：</p><ul><li>只支持get请求（因为<code>&lt;script&gt;</code>标签只能get）</li><li>有安全性问题，容易遭受xss攻击</li><li>需要服务端配合jsonp进行一定程度的改造</li></ul><p>jsonp的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSONP</span>(<span class="params">&#123;  </span></span></span><br><span class="line"><span class="function"><span class="params">  url,</span></span></span><br><span class="line"><span class="function"><span class="params">  params,</span></span></span><br><span class="line"><span class="function"><span class="params">  callbackKey,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在参数里制定 callback 的名字</span></span><br><span class="line">  params = params || &#123;&#125;</span><br><span class="line">  params[callbackKey] = <span class="string">'jsonpCallback'</span></span><br><span class="line">    <span class="comment">// 预留 callback</span></span><br><span class="line">  <span class="built_in">window</span>.jsonpCallback = callback</span><br><span class="line">    <span class="comment">// 拼接参数字符串</span></span><br><span class="line">  <span class="keyword">const</span> paramKeys = <span class="built_in">Object</span>.keys(params)</span><br><span class="line">  <span class="keyword">const</span> paramString = paramKeys</span><br><span class="line">    .map(<span class="function"><span class="params">key</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>)</span><br><span class="line">    .join(<span class="string">'&amp;'</span>)</span><br><span class="line">    <span class="comment">// 插入 DOM 元素</span></span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.setAttribute(<span class="string">'src'</span>, <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;paramString&#125;</span>`</span>)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSONP(&#123;  </span><br><span class="line">  url: <span class="string">'http://s.weibo.com/ajax/jsonp/suggestion'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    key: <span class="string">'test'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  callbackKey: <span class="string">'_cb'</span>,</span><br><span class="line">  callback(result) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="最流行的跨域方案cors"><a href="#最流行的跨域方案cors" class="headerlink" title="最流行的跨域方案cors"></a>最流行的跨域方案cors</h4><p><code>cors</code>是目前主流的跨域解决方案，跨域资源共享(CORS) 是一种机制，它使用额外的 <code>HTTP 头</code>来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个<code>跨域 HTTP</code> 请求。 </p><p>如果你用<code>express</code>，可以这样在后端设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CORS middleware</span></span><br><span class="line"><span class="keyword">var</span> allowCrossDomain = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://example.com'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET,PUT,POST,DELETE'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type'</span>);</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">app.configure(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    app.use(express.bodyParser());</span><br><span class="line">    app.use(express.cookieParser());</span><br><span class="line">    app.use(express.session(&#123; <span class="attr">secret</span>: <span class="string">'cool beans'</span> &#125;));</span><br><span class="line">    app.use(express.methodOverride());</span><br><span class="line">    app.use(allowCrossDomain);</span><br><span class="line">    app.use(app.router);</span><br><span class="line">    app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在生产环境中建议用成熟的开源中间件解决问题。</p><h3 id="最方便的跨域方案Nginx"><a href="#最方便的跨域方案Nginx" class="headerlink" title="最方便的跨域方案Nginx"></a>最方便的跨域方案Nginx</h3><p>nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</p><p>现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/24/16d610123c354a18?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="nginx的反向代理"></p><p>反向代理的原理很简单，即所有客户端的请求都必须先经过nginx的处理，nginx作为代理服务器再讲请求转发给node或者java服务，这样就规避了同源策略。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进程, 可更具cpu数量调整</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment">#连接数</span></span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#连接超时时间，服务器会在这个时间过后关闭连接。</span></span><br><span class="line">    keepalive_timeout  10;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gizp压缩</span></span><br><span class="line">    gzip  on;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 直接请求nginx也是会报跨域错误的这里设置允许跨域</span></span><br><span class="line">    <span class="comment"># 如果代理地址已经允许跨域则不需要这些, 否则报错(虽然这样nginx跨域就没意义了)</span></span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">    add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># srever模块配置是http模块中的一个子模块，用来定义一个虚拟访问主机</span></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根路径指到index.html</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># localhost/api 的请求会被转发到192.168.0.103:8080</span></span><br><span class="line">        location /api &#123;</span><br><span class="line">            rewrite ^/b/(.*)$ /<span class="variable">$1</span> <span class="built_in">break</span>; <span class="comment"># 去除本地接口/api前缀, 否则会出现404</span></span><br><span class="line">            proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            proxy_pass http://192.168.0.103:8080; <span class="comment"># 转发地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 重定向错误页面到/50x.html</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它跨域方案"><a href="#其它跨域方案" class="headerlink" title="其它跨域方案"></a>其它跨域方案</h3><ol><li><code>HTML5 XMLHttpRequest</code> 有一个<code>API</code>，<code>postMessage()</code>方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</li><li><code>WebSocket</code> 是一种<code>双向通信协议</code>，在建立连接之后，<code>WebSocket</code> 的 <code>server</code> 与 <code>client</code> 都能<code>主动向对方发送或接收数据</code>，连接建立好了之后 <code>client</code> 与 <code>server</code> 之间的<code>双向通信就与 HTTP 无关</code>了，因此可以跨域。</li><li><code>window.name</code> + <code>iframe：window.name</code>属性值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 <code>name</code> 值，我们可以利用这个特点进行跨域。</li><li><code>location.hash</code> + <code>iframe：a.html</code>欲与<code>c.html</code>跨域相互通信，通过中间页<code>b.html</code>来实现。 三个页面，不同域之间利用<code>iframe</code>的<code>location.hash</code>传值，相同域之间直接<code>js</code>访问来通信。</li><li><code>document.domain + iframe</code>： 该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式，我们只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域，两个页面都通过js强制设置<code>document.domain</code>为基础主域，就实现了同域。</li></ol><blockquote><p>其余方案来源于<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1#heading-19" target="_blank" rel="noopener">九种跨域方式</a></p></blockquote><p>参考文章:</p><ul><li><a href="https://segmentfault.com/q/1010000000713509" target="_blank" rel="noopener">为什么 CSS 选择器解析的时候是从右往左？</a></li></ul><blockquote><p>作者：寻找海蓝96<br>链接：<a href="https://juejin.im/post/5d89798d6fb9a06b102769b1" target="_blank" rel="noopener">https://juejin.im/post/5d89798d6fb9a06b102769b1</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常见的浏览器内核有哪些&quot;&gt;&lt;a href=&quot;#常见的浏览器内核有哪些&quot; class=&quot;headerlink&quot; title=&quot;常见的浏览器内核有哪些?&quot;&gt;&lt;/a&gt;常见的浏览器内核有哪些?&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;浏览器/RunTime&lt;/th&gt;
&lt;th&gt;内核（渲染引擎）&lt;/th&gt;
&lt;th&gt;JavaScript 引擎&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Chrome&lt;/td&gt;
&lt;td&gt;Blink（28~）Webkit（Chrome 27）&lt;/td&gt;
&lt;td&gt;V8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FireFox&lt;/td&gt;
&lt;td&gt;Gecko&lt;/td&gt;
&lt;td&gt;SpiderMonkey&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Safari&lt;/td&gt;
&lt;td&gt;Webkit&lt;/td&gt;
&lt;td&gt;JavaScriptCore&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge&lt;/td&gt;
&lt;td&gt;EdgeHTML&lt;/td&gt;
&lt;td&gt;Chakra(for JavaScript)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IE&lt;/td&gt;
&lt;td&gt;Trident&lt;/td&gt;
&lt;td&gt;Chakra(for JScript)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PhantomJS&lt;/td&gt;
&lt;td&gt;Webkit&lt;/td&gt;
&lt;td&gt;JavaScriptCore&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Node.js&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;V8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="面试" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="面试" scheme="https://heiyehk.github.io/blog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的回流与重绘 (Reflow &amp; Repaint)</title>
    <link href="https://heiyehk.github.io/blog/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98-Reflow-Repaint/"/>
    <id>https://heiyehk.github.io/blog/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98-Reflow-Repaint/</id>
    <published>2020-04-30T04:40:46.000Z</published>
    <updated>2020-04-30T09:27:47.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>在讨论回流与重绘之前，我们要知道：</p><ol><li>浏览器使用流式布局模型 (Flow Based Layout)。</li><li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>Render Tree</code>。</li><li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li><li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一。</li></ol><p>一句话：回流必将引起重绘，重绘不一定会引起回流。</p><a id="more"></a><h3 id="回流-Reflow"><a href="#回流-Reflow" class="headerlink" title="回流 (Reflow)"></a>回流 (Reflow)</h3><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。<br>会导致回流的操作：</p><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><p>一些常用且会导致回流的属性和方法：</p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li><li><code>scrollTo()</code></li></ul><h3 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘 (Repaint)"></a>重绘 (Repaint)</h3><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p><strong>回流比重绘的代价要更高。</strong><br>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。<br>现代浏览器会对频繁的回流或重绘操作进行优化：<br>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。<br>当你访问以下属性或方法时，浏览器会立刻清空队列：</p><p>getComputedStyle()<br>getBoundingClientRect()</p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>width</code>、<code>height</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li></ul><p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p><h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><ul><li>避免使用<code>table</code>布局。</li><li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li><li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li></ul><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul><li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li><li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM</code>操作，最后再把它添加到文档中。</li><li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><blockquote><p>作者：腰花<br>链接：<a href="https://juejin.im/post/5a9923e9518825558251c96a" target="_blank" rel="noopener">https://juejin.im/post/5a9923e9518825558251c96a</a><br>来源：掘金</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;在讨论回流与重绘之前，我们要知道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器使用流式布局模型 (Flow Based Layout)。&lt;/li&gt;
&lt;li&gt;浏览器会把&lt;code&gt;HTML&lt;/code&gt;解析成&lt;code&gt;DOM&lt;/code&gt;，把&lt;code&gt;CSS&lt;/code&gt;解析成&lt;code&gt;CSSOM&lt;/code&gt;，&lt;code&gt;DOM&lt;/code&gt;和&lt;code&gt;CSSOM&lt;/code&gt;合并就产生了&lt;code&gt;Render Tree&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;有了&lt;code&gt;RenderTree&lt;/code&gt;，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。&lt;/li&gt;
&lt;li&gt;由于浏览器使用流式布局，对&lt;code&gt;Render Tree&lt;/code&gt;的计算通常只需要遍历一次就可以完成，但&lt;code&gt;table&lt;/code&gt;及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用&lt;code&gt;table&lt;/code&gt;布局的原因之一。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一句话：回流必将引起重绘，重绘不一定会引起回流。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="回流" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%9E%E6%B5%81/"/>
    
      <category term="重绘" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%9E%E6%B5%81/%E9%87%8D%E7%BB%98/"/>
    
      <category term="Reflow" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%9E%E6%B5%81/%E9%87%8D%E7%BB%98/Reflow/"/>
    
      <category term="Repaint" scheme="https://heiyehk.github.io/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%9E%E6%B5%81/%E9%87%8D%E7%BB%98/Reflow/Repaint/"/>
    
    
      <category term="浏览器" scheme="https://heiyehk.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="回流" scheme="https://heiyehk.github.io/blog/tags/%E5%9B%9E%E6%B5%81/"/>
    
      <category term="重绘" scheme="https://heiyehk.github.io/blog/tags/%E9%87%8D%E7%BB%98/"/>
    
      <category term="Reflow" scheme="https://heiyehk.github.io/blog/tags/Reflow/"/>
    
      <category term="Repaint" scheme="https://heiyehk.github.io/blog/tags/Repaint/"/>
    
  </entry>
  
  <entry>
    <title>HTML5-新特性</title>
    <link href="https://heiyehk.github.io/blog/HTML5-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://heiyehk.github.io/blog/HTML5-%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-04-30T04:34:48.000Z</published>
    <updated>2020-05-20T08:57:04.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1.语义化标签"></a>1.语义化标签</h3><p>语义化标签 为页面提供了更好的页面结构。</p><table><thead><tr><th>描述</th><th>属性</th></tr></thead><tbody><tr><td>&lt;header&gt;&lt;/header&gt;</td><td>定义文档的头部区域</td></tr><tr><td>&lt;footer&gt;&lt;/footer&gt;</td><td>定义文档的尾部区域</td></tr><tr><td>&lt;nav&gt;&lt;/nav&gt;</td><td>定义文档的导航区域</td></tr><tr><td>&lt;section&gt;&lt;/section&gt;</td><td>定义文档的段落</td></tr><tr><td>&lt;article&gt;&lt;/article&gt;</td><td>定义页面独立的内容区域</td></tr><tr><td>&lt;aside&gt;&lt;/aside&gt;</td><td>定义页面侧边栏内容</td></tr><tr><td>&lt;command&gt;&lt;/command&gt;</td><td>定义命令按钮</td></tr><tr><td>&lt;details&gt;&lt;/details&gt;</td><td>标签包含 details 元素的标题</td></tr><tr><td>&lt;dialog&gt;&lt;/dialog&gt;</td><td>定义对话框</td></tr></tbody></table><a id="more"></a><h3 id="2-增强型表单"><a href="#2-增强型表单" class="headerlink" title="2.增强型表单"></a>2.增强型表单</h3><p>HTML5 提供了多个新的表单输入类型。</p><table><thead><tr><th>输入类型</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>主要用于选取颜色</td></tr><tr><td>date</td><td>从一个日期选择器选择一个日期</td></tr><tr><td>datetime</td><td>选择一个日期（UTC 时间）</td></tr><tr><td>datetime-local</td><td>选择一个日期和时间 (无时区)</td></tr><tr><td>email</td><td>包含 e-mail 地址的输入域</td></tr><tr><td>month</td><td>选择一个月份</td></tr><tr><td>number</td><td>数值的输入域</td></tr><tr><td>range</td><td>一定范围内数字值的输入域</td></tr><tr><td>search</td><td>用于搜索域</td></tr><tr><td>tel</td><td>定义输入电话号码字段</td></tr><tr><td>time</td><td>选择一个时间</td></tr><tr><td>url</td><td>URL 地址的输入域</td></tr><tr><td>week</td><td>选择周和年</td></tr></tbody></table><p>同时，还增加了新的表单属性：</p><ol><li>placehoder 属性，简短的提示在用户输入值前会显示在输入域上。即我们常见的输入框默认提示，在用户输入后消失。</li><li>required  属性，是一个 boolean 属性。要求填写的输入域不能为空</li><li>pattern 属性，描述了一个正则表达式用于验证<code>&lt;input&gt;</code> 元素的值。</li><li>min 和 max 属性，设置元素最小值与最大值。</li><li>step 属性，为输入域规定合法的数字间隔。</li><li>height 和 width 属性，用于 image 类型的 <code>&lt;input&gt;</code> 标签的图像高度和宽度。</li><li>autofocus 属性，是一个 boolean 属性。规定在页面加载时，域自动地获得焦点。</li><li>multiple 属性 ，是一个 boolean 属性。规定<code>&lt;input&gt;</code> 元素中可选择多个值。　　</li></ol><h3 id="3-音频和视频"><a href="#3-音频和视频" class="headerlink" title="3.音频和视频"></a>3.音频和视频</h3><p>HTML5 提供了 音频和视频 。</p><p><strong>音频：<code>&lt;audio&gt;</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"xxx.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"xxx.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span>&gt;</span></span><br><span class="line">  您的浏览器不支持 audio 元素。</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>视频：<code>&lt;video&gt;</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"300"</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"xxx.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"xxx.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>&gt;</span></span><br><span class="line">  您的浏览器不支持Video标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-canvas-绘图"><a href="#4-canvas-绘图" class="headerlink" title="4.canvas 绘图"></a>4.canvas 绘图</h3><ul><li>HTML5 <code>&lt;canvas&gt;</code> 标签用于绘制图像（通过脚本，通常是 JavaScript）。  </li><li>不过，<code>&lt;canvas&gt;</code> 元素本身并没有绘制能力（它仅仅是图形的容器） - 您必须使用脚本来完成实际的绘图任务。  </li><li>getContext() 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。</li></ul><h3 id="5-SVG-绘图"><a href="#5-SVG-绘图" class="headerlink" title="5.SVG 绘图"></a>5.SVG 绘图</h3><p>SVG 意为可缩放矢量图形（Scalable Vector Graphics）</p><p>SVG 与 Canvas两者间的区别</p><ul><li>SVG 是一种使用 XML 描述 2D 图形的语言。</li><li>Canvas 通过 JavaScript 来绘制 2D 图形。</li><li>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</li><li>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</li><li>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</li></ul><h3 id="6-地理定位（Geolocation）"><a href="#6-地理定位（Geolocation）" class="headerlink" title="6.地理定位（Geolocation）"></a>6.地理定位（Geolocation）</h3><p>HTML5 Geolocation（地理定位）用于定位用户的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.geolocation &#123;</span><br><span class="line">  getCurrentPosition:  fn  <span class="comment">// 用于获取当前的位置数据</span></span><br><span class="line">  watchPosition: fn  <span class="comment">// 监视用户位置的改变</span></span><br><span class="line">  clearWatch: fn  <span class="comment">// 清除定位监视</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取用户定位信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">pos</span>) </span>&#123; <span class="comment">// 定位成功的回调</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用户定位数据获取成功'</span>)</span><br><span class="line">    <span class="comment">// console.log(arguments);</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'定位时间：'</span>,pos.timestamp)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'经度：'</span>,pos.coords.longitude)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'纬度：'</span>,pos.coords.latitude)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'海拔：'</span>,pos.coords.altitude)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'速度：'</span>,pos.coords.speed)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; <span class="comment">// 定位失败的回调</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用户定位数据获取失败'</span>)</span><br><span class="line">    <span class="comment">//console.log(arguments);</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="7-拖放API"><a href="#7-拖放API" class="headerlink" title="7.拖放API"></a>7.拖放API</h3><p>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。<br>在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。</p><h3 id="8-Web-Storage"><a href="#8-Web-Storage" class="headerlink" title="8.Web Storage"></a>8.Web Storage</h3><p>使用HTML5可以在本地存储用户的浏览数据。<br>客户端存储数据的两个对象为：</p><p><strong>localStorage</strong>：没有时间限制的数据存储<br><strong>sessionStorage</strong>： 针对一个 session 的数据存储, 当用户关闭浏览器窗口后，数据会被删除。</p><p>不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：</p><ol><li>保存数据：localStorage.setItem(key,value);</li><li>读取数据：localStorage.getItem(key);</li><li>删除单个数据：localStorage.removeItem(key);</li><li>删除所有数据：localStorage.clear();</li><li>得到某个索引的key：localStorage.key(index);</li></ol><h3 id="9-WebSocket"><a href="#9-WebSocket" class="headerlink" title="9.WebSocket"></a>9.WebSocket</h3><p>WebSocket 是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。<br>在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。<br>两者之间就直接可以数据互相传送。<br>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。<br>当你获取 Web Socket 连接后，你可以通过 <strong>send()</strong> 方法来向服务器发送数据，并通过 <strong>onmessage</strong> 事件来接收服务器返回的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>W3Cschool教程(w3cschool.cn)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">WebSocketTest</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">         <span class="keyword">if</span> (<span class="string">"WebSocket"</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"您的浏览器支持 WebSocket!"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 打开一个 web socket</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:9998/echo"</span>);</span></span><br><span class="line"><span class="actionscript">            ws.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">               <span class="comment">// Web Socket 已连接上，使用 send() 方法发送数据</span></span></span><br><span class="line"><span class="actionscript">               ws.send(<span class="string">"发送数据"</span>);</span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"数据发送中..."</span>);</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            ws.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(evt)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">               <span class="keyword">var</span> received_msg = evt.data;</span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"数据已接收..."</span>);</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            ws.onclose = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">               <span class="comment">// 关闭 websocket</span></span></span><br><span class="line"><span class="actionscript">               alert(<span class="string">"连接已关闭..."</span>);</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">         &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 浏览器不支持 WebSocket</span></span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"您的浏览器不支持 WebSocket!"</span>);</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sse"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:WebSocketTest()"</span>&gt;</span>运行 WebSocket<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>非商用，侵删，转自: <a href="https://www.cnblogs.com/gaosirs/p/10756524.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaosirs/p/10756524.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-语义化标签&quot;&gt;&lt;a href=&quot;#1-语义化标签&quot; class=&quot;headerlink&quot; title=&quot;1.语义化标签&quot;&gt;&lt;/a&gt;1.语义化标签&lt;/h3&gt;&lt;p&gt;语义化标签 为页面提供了更好的页面结构。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&amp;lt;header&amp;gt;&amp;lt;/header&amp;gt;&lt;/td&gt;
&lt;td&gt;定义文档的头部区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;footer&amp;gt;&amp;lt;/footer&amp;gt;&lt;/td&gt;
&lt;td&gt;定义文档的尾部区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;nav&amp;gt;&amp;lt;/nav&amp;gt;&lt;/td&gt;
&lt;td&gt;定义文档的导航区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;section&amp;gt;&amp;lt;/section&amp;gt;&lt;/td&gt;
&lt;td&gt;定义文档的段落&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;article&amp;gt;&amp;lt;/article&amp;gt;&lt;/td&gt;
&lt;td&gt;定义页面独立的内容区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;aside&amp;gt;&amp;lt;/aside&amp;gt;&lt;/td&gt;
&lt;td&gt;定义页面侧边栏内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;command&amp;gt;&amp;lt;/command&amp;gt;&lt;/td&gt;
&lt;td&gt;定义命令按钮&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;details&amp;gt;&amp;lt;/details&amp;gt;&lt;/td&gt;
&lt;td&gt;标签包含 details 元素的标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;dialog&amp;gt;&amp;lt;/dialog&amp;gt;&lt;/td&gt;
&lt;td&gt;定义对话框&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML5" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/HTML5/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML5" scheme="https://heiyehk.github.io/blog/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>HTML5-语义化</title>
    <link href="https://heiyehk.github.io/blog/HTML5-%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    <id>https://heiyehk.github.io/blog/HTML5-%E8%AF%AD%E4%B9%89%E5%8C%96/</id>
    <published>2020-04-30T04:33:37.000Z</published>
    <updated>2020-05-20T08:57:17.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>什么是语义化？就是用合理、正确的标签来展示内容，比如h1~h6定义标题。</p><h3 id="语义化优点："><a href="#语义化优点：" class="headerlink" title="语义化优点："></a>语义化优点：</h3><ul><li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</li><li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li><li>方便其他设备解析，如盲人阅读器根据语义渲染网页</li><li>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。</li></ul><a id="more"></a><p><img src="http://www.daqianduan.com/wp-content/uploads/2018/03/html5-768x508.png" alt="avatar"></p><ol><li><code>&lt;header&gt;</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在一个文档中，您可以定义多个&#96;&#96;&#96;&lt;header&gt;&#96;&#96;&#96;元素，但需要注意的是&#96;&#96;&#96;&lt;header&gt;&#96;&#96;&#96;元素不能作为&#96;&#96;&#96;&lt;address&gt;&#96;&#96;&#96;、&#96;&#96;&#96;&lt;footer&gt;&#96;&#96;&#96; 或 &#96;&#96;&#96;&lt;header&gt;&#96;&#96;&#96; 元素的子元素。</span><br><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;&lt;nav&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在一个文档中，可定义多个&#96;&#96;&#96;&lt;nav&gt;&#96;&#96;&#96;元素。</span><br><span class="line"></span><br><span class="line">3. &#96;&#96;&#96;&lt;main&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>定义文档的主要内容，该内容在文档中应当是独一无二的，不包含任何在文档中重复的内容，比如侧边栏，导航栏链接，版权信息，网站logo，搜索框（除非搜索框作为文档的主要功能）。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">需要注意的是在一个文档中不能出现多个&#96;&#96;&#96;&lt;main&gt;&#96;&#96;&#96;标签。</span><br><span class="line"></span><br><span class="line">4. &#96;&#96;&#96;&lt;article&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当&#96;&#96;&#96;&lt;article&gt;&#96;&#96;&#96;元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的&#96;&#96;&#96;&lt;article&gt;&#96;&#96;&#96;元素可嵌套在代表博客文章的&#96;&#96;&#96;&lt;article&gt;&#96;&#96;&#96;元素中。</span><br><span class="line"></span><br><span class="line">5. &#96;&#96;&#96;&lt;aside&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分且可以被单独的拆分出来而不会影响整体。通常表现为侧边栏或嵌入内容。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. &#96;&#96;&#96;&lt;footer&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用footer插入联系信息时，应在 footer 元素内使用 &#96;&#96;&#96;&lt;address&gt;&#96;&#96;&#96; 元素。</span><br><span class="line"></span><br><span class="line">注意不能包含&#96;&#96;&#96;&lt;footer&gt;&#96;&#96;&#96;或者&#96;&#96;&#96;&lt;header&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li><code>&lt;section&gt;</code></li></ol><p><code>&lt;section&gt;</code>表示文档中的一个区域（或节），比如，内容中的一个专题组。</p><p>如果元素内容可以分为几个部分的话，应该使用 <code>&lt;article&gt;</code> 而不是 <code>&lt;section&gt;</code>。<br>不要把 <code>&lt;section&gt;</code> 元素作为一个普通的容器来使用，特别是当<code>&lt;section&gt;</code>仅仅是为了美化样式或方便脚本使用的时候，应使用<code>&lt;div&gt;</code>。</p><p>这几个标签，比较容易混淆的是<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>，所以这里特别说明：</p><p>“Authors are encouraged to use the article element instead of the section element when it would make sense to syndicate the contents of the elemen.”</p><p>通俗来说就是<code>&lt;article&gt;</code>比<code>&lt;section&gt;</code>更具有独立性、完整性。可通过该段内容脱离了所在的语境，是否完整、独立来判断。</p><blockquote><p>非商用，侵删，转自: <a href="http://www.daqianduan.com/6549.html" target="_blank" rel="noopener">http://www.daqianduan.com/6549.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;什么是语义化？就是用合理、正确的标签来展示内容，比如h1~h6定义标题。&lt;/p&gt;
&lt;h3 id=&quot;语义化优点：&quot;&gt;&lt;a href=&quot;#语义化优点：&quot; class=&quot;headerlink&quot; title=&quot;语义化优点：&quot;&gt;&lt;/a&gt;语义化优点：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。&lt;/li&gt;
&lt;li&gt;有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。&lt;/li&gt;
&lt;li&gt;方便其他设备解析，如盲人阅读器根据语义渲染网页&lt;/li&gt;
&lt;li&gt;有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML5" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/HTML5/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML5" scheme="https://heiyehk.github.io/blog/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>SEO关键词</title>
    <link href="https://heiyehk.github.io/blog/SEO%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
    <id>https://heiyehk.github.io/blog/SEO%E5%85%B3%E9%94%AE%E8%AF%8D/</id>
    <published>2020-04-30T03:29:41.000Z</published>
    <updated>2020-05-20T08:57:58.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="title（网站标题）"><a href="#title（网站标题）" class="headerlink" title="title（网站标题）"></a>title（网站标题）</h3><p>title，就是浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到（搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。）title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。 </p><p>用法：<code>&lt;title&gt;网站标题&lt;/title&gt;</code>  </p><a id="more"></a><p>1）首页title写法，一般是“网站名称-主关键词或一句含有主关键词的描述”。小编在做优化时习惯把网站名称放最前面，主关键词放后面，因为搜索引擎给予标题最前面的词比后面的高。比如，做“贷款”这个词，就这样写“家财管加-成都贷款公司_成都个人贷款_成都抵押贷款_成都小额贷款_成都信用贷款”。</p><p>2）栏目页title写法，一般有2种：“栏目名称-网站名称”、“栏目名称栏目关键词-网站名称”。小编建议用“栏目名称-网站名称”。而且栏目名称最好用关键词来确定，比如贷款产品类型栏目最好就用贷款类型，而不要起个让人无法识别的名字如贷款来人，贷款看看，或贷款加上一些特殊符号，这种写法虽然很有个性，但会让你的网站在优化上占了下风。</p><p>3）分类列表页title写法，一般是“分类列表页名称-栏目名称-网站名称”，这个和栏目页差不多。</p><p>4）文章页title写法，一般有3种：“文章标题-网站名称”、“内容标题-栏目名称”、“内容标题-栏目名称-网站名称”。其中，“内容标题-栏目名称-网站名称”的写法最为规范，但也相对复杂，它能给用户很好的提示，让用户知道他在访问哪篇文章，并且是在哪个网站的哪个栏目下。</p><h3 id="keywords（关键词）"><a href="#keywords（关键词）" class="headerlink" title="keywords（关键词）"></a>keywords（关键词）</h3><p>keywords，是用户不查看源代码看不到的。主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此keywords的每个词都要能在内容中找到相应匹配，才有利于排名。keywords一般不超过3个，每个关键词不宜过长，而且词语间要用英文“,”隔开。为什么用英文上文已经说过。而且，尽量将重要的关键字靠前放，因为靠后的关键字排名较差，除非你站有很高的权重。</p><p>小道消息称keywords曾被百度、谷歌、雅虎等搜索引擎剔除，将不会再影响搜索引擎的排序结果，小编认为设置一下总没坏处，还是有一些搜索引擎比较重视keywords标签的。</p><p>用法：<code>&lt;meta name=&quot;Keywords&quot; Content=&quot;关键词1,关键词2,关键词3,关键词4&quot;&gt;</code></p><p>1）首页keywords写法，一般是“网站名称,主要栏目名,主要关键词”。</p><p>2）栏目页keywords写法，一般是“栏目名称,栏目关键字,栏目分类列表名称”。</p><p>3）分类列表页keywords写法，这个就比较简单了，只要将你这个栏目中的主要关键字写入即可。</p><p>4）文章页keywords写法，建议大家提取文章中的关键词，比如我的文章主要是讲信用贷款的，那么我关键词肯定是信用贷款，如果你觉得你提取关键词的能力较差，也可以选择文章中出现比较多的词来作为关键词，比如我现在写的内容是关于title、keywords、description的，那我的文章页关键词就是这3个。</p><h3 id="description（内容摘要）"><a href="#description（内容摘要）" class="headerlink" title="description（内容摘要）"></a>description（内容摘要）</h3><p>description，和上面的keywords一样，是用户不查看源代码看不到的，而且也是对于一个网页的简要内容概况。不同的是，keywords是由几个词语的组成的，而description则是完整的一句话。description一般不超过150个字符，描述内容要和页面内容相关。</p><p>用法：<code>&lt;meta name=&quot;Description&quot; Content=&quot;你网页的简述&quot;&gt;</code></p><p>1）首页description写法，一般是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍。</p><p>2）栏目页description写法，一般是将栏目的标题、关键字、分类列表名称融合到里面，写成简单的介绍。</p><p>3）分类列表页description，这个就比较简单了，一般只需要把分类列表的标题、关键词融合在一起，写成简单的介绍。</p><p>4）文章页description写法，一般有2种写法，标准写法就和前面的一样，将文章标题、文章中的重要内容和关键词融合在一起，写成简单的介绍。这是最好最标准的写法。但是这样写比较麻烦，小编教你一种偷懒的方法，你可以在文章首段和标题中加入关键词，比如我这篇文章是讲title、keywords、description的，那么在文章首段和标题中就加入这些内容，然后直接将文章首段的内容复制到description中即可。</p><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>3个标签按重要性来分：<code>title &gt; description &gt; keywords</code></p><blockquote><p>非商用，侵删，转自: <a href="https://jingyan.baidu.com/article/ab69b2709d2c082ca7189fbe.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/ab69b2709d2c082ca7189fbe.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;title（网站标题）&quot;&gt;&lt;a href=&quot;#title（网站标题）&quot; class=&quot;headerlink&quot; title=&quot;title（网站标题）&quot;&gt;&lt;/a&gt;title（网站标题）&lt;/h3&gt;&lt;p&gt;title，就是浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到（搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。）title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。 &lt;/p&gt;
&lt;p&gt;用法：&lt;code&gt;&amp;lt;title&amp;gt;网站标题&amp;lt;/title&amp;gt;&lt;/code&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="SEO" scheme="https://heiyehk.github.io/blog/categories/%E5%89%8D%E7%AB%AF/SEO/"/>
    
    
      <category term="前端" scheme="https://heiyehk.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="SEO" scheme="https://heiyehk.github.io/blog/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客初体验</title>
    <link href="https://heiyehk.github.io/blog/hexo%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://heiyehk.github.io/blog/hexo%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-04-29T06:15:36.000Z</published>
    <updated>2020-05-20T08:59:52.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>hexo是一款快速、简洁且高效的博客框架。<br>中文文档<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a>  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><a id="more"></a><p>网上有很多好看并且SEO优化的很好的主题，我选择了<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">Yilia</a>这款主题作为博客的新主题😁。</p><h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"我的博客"</span> == hexo new <span class="string">"我的博客"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo p == hexo publish</span><br><span class="line">hexo g == hexo generate <span class="comment">#生成</span></span><br><span class="line">hexo s == hexo server <span class="comment">#启动服务预览</span></span><br><span class="line">hexo d == hexo deploy <span class="comment">#部署</span></span><br><span class="line">hexo cl == hexo clean <span class="comment">#删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除所有缓存并运行</span></span><br><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h3 id="文章内容模板编辑"><a href="#文章内容模板编辑" class="headerlink" title="文章内容模板编辑"></a>文章内容模板编辑</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: 使用Hexo搭建个人博客</span><br><span class="line">layout: post</span><br><span class="line">date: 2014-03-03 19:07:43</span><br><span class="line">comments: <span class="literal">true</span></span><br><span class="line">categories: Blog <span class="comment">#归档和tag尽量把大分类放在前面</span></span><br><span class="line">tags: [Hexo]</span><br><span class="line">keywords: Hexo, Blog</span><br><span class="line">description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。</span><br></pre></td></tr></table></figure><h3 id="网站的SEO优化"><a href="#网站的SEO优化" class="headerlink" title="网站的SEO优化"></a>网站的SEO优化</h3><h4 id="添加站点"><a href="#添加站点" class="headerlink" title="添加站点"></a>添加站点</h4><p>进入<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度站长平台</a>，然后进入个人中心，添加你的网站，把验证内容下载下来放入<code>source/assets</code>这个文件夹中。<br>进入<a href="https://search.google.com/search-console/welcome" target="_blank" rel="noopener">google search console</a>，选择<code>网址前缀</code>，输入你的域名，然后下载验证文件，把验证内容下载下来放入<code>source/assets</code>这个文件夹中。<br>当然也可以使用其他的验证方式进行验证。</p><h4 id="生成站点地图和rss"><a href="#生成站点地图和rss" class="headerlink" title="生成站点地图和rss"></a>生成站点地图和rss</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 谷歌sitemap</span></span><br><span class="line">npm install hexo-generator-sitemap</span><br><span class="line"><span class="comment"># 百度sitemap</span></span><br><span class="line">npm install hexo-generator-baidu-sitemap</span><br><span class="line"><span class="comment"># rss</span></span><br><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><p>然后在<code>站点根目录的_config.yml</code>配置如下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">plugin:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-sitemap</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><h3 id="添加-robots-txt"><a href="#添加-robots-txt" class="headerlink" title="添加 robots.txt"></a>添加 robots.txt</h3><p>如果是放在<code>blog</code>目录下的话，sitemap可使用其他生成sitemap的工具进行生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;blog&#x2F;</span><br><span class="line">Allow: &#x2F;blog&#x2F;archives&#x2F;</span><br><span class="line"></span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line">Disallow: &#x2F;categories&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: https:&#x2F;&#x2F;heiyehk.github.io&#x2F;sitemap.xml</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;heiyehk.github.io&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure><h3 id="提交sitemap"><a href="#提交sitemap" class="headerlink" title="提交sitemap"></a>提交sitemap</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">1000</span> <span class="comment">## 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">alili.tech</span> <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">xxxxx</span> <span class="comment">## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment">## 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;hexo是一款快速、简洁且高效的博客框架。&lt;br&gt;中文文档&lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io/zh-cn/docs/&lt;/a&gt;  &lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://heiyehk.github.io/blog/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://heiyehk.github.io/blog/tags/hexo/"/>
    
  </entry>
  
</feed>
